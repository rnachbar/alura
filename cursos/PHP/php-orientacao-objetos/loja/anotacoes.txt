################# 1. Classes e Objetos #################

Bem vindo ao nosso curso de PHP e Orientação a Objetos. No decorrer deste módulo entenderemos alguns dos principais conceitos e recursos de OO e colocaremos isso em prática na aplicação que foi desenvolvida no curso de PHP e MySQL. Não se preocupe se você não fez o outro curso, no primeiro exercício deste capítulo você receberá instruções para baixar o projeto e configurar o banco para continuar a partir deste ponto.
Uma forma melhor de representar um Produto
Da forma que está, as informações de um Produto estão todas espalhadas pelas assinaturas das nossas funções. Você pode notar isso no método insereProduto, do arquivo banco-produto.php:

function insereProduto($conexao, $nome, $preco, $descricao, $categoria_id, $usado) {

    $query = "insert into produtos (nome, preco, descricao, categoria_id, usado) 
        values ('{$nome}', '{$preco}', '{$descricao}', '{$categoria_id}', {$usado})";

    return mysqli_query($conexao, $query);
}
Um dos problemas disso é que a cada nova informação que um produto venha a ter, um novo argumento precisa ser passado. Com o passar do tempo, a assinatura da função insereProduto vai ficando ainda maior, com mais argumentos, difícil de ler e cada vez mais difícil de manter.

Ao passar todas as informações do produto espalhadas dessa forma, fica fácil confundir a ordem desses argumentos. Podemos por engano passar o email no lugar do nome e assim por diante.

Uma das primeiras propostas para escrever um código orientado a objetos é que se um elemento é importante em nosso contexto, ele deve ser representado por um tipo próprio. Claramente um Produto é extremamente importante para nossa aplicação de loja, portanto, nada mais justo do que criar um tipo Produto para representá-lo, no lugar de trabalhar com suas informações espalhadas. Nosso código ficará muito mais organizado.

Criando uma classe em PHP
Dentro de loja, vamos criar a pasta class, dentro dela criaremos o arquivo Produto.php, com a definição inicial de um Produto. Isso pode ser feito da seguinte forma:

<?php

class Produto {
    // ...
}

?>
Repare que a estrutura de uma classe é bem simples, ela começa com a palavra reservada class, seguida de seu nome e um par de chaves. Uma classe é um molde, uma receita de como criar determinado objeto de nosso sistema.

Convenção de nomes para classes
O ideal é que você sempre dê nomes significativos para suas classes, refletindo bem o que determinado objeto desse tipo representa em seu sistema. Por esse motivo é bastante recomendado que você não use muitas abreviações ao declarar seu nome.

Além disso, por padrão, uma classe deve começar com letra maiúscula e ter seu case alterado a cada nova palavra (o famoso CamelCase ou CamelCaps). Você pode ler mais sobre convenções de código PHP aqui.

Propriedades da classe
A classe Produto, por enquanto, está vazia, mas uma classe deve representar tudo o que um objeto desse tipo tem e tudo o que ele faz. Por enquanto, vamos focar no que um Produto tem, que já sabemos ser um nome, preco, etc. Podemos fazer isso da seguinte forma:

<?php

class Produto {

    public $id;
    public $nome;
    public $preco;
    public $descricao;
    public $categoria_id;
    public $usado;
}

?>
Não se intimide com a presença desse novo modificador, o public. Ele e outros modificadores de visibilidade serão melhor detalhados mais à frente. Apesar de se parecer muito com uma variável normal, esse tipo especial de variável é conhecido como propriedade (property). Comumente também são chamadas de variáveis de classe, variáveis membro, atributos ou fields.

As propriedades de uma classe também podem ser inicializadas, caso necessário. Em cada novo produto, podemos explicitamente declarar o valor das propriedades , mas há um detalhe importante, o valor padrão precisa ser uma expressão constante. Não podemos, por exemplo, atribuir uma variável, uma outra propriedade ou mesmo uma chamada de função. O seguinte código é inválido:

class Produto {

    // inválido, não pode receber uma variável
    public $id = $algum_atributo;

    // ok, isso é válido
    public $nome = 'Iphone 6 dobrável';

    // inválido, não pode receber outra propriedade
    public $preco = $nome;

    // inválido, tem que ser constante
    public $descricao = 'alguma '.'descricao';

    // inválido, não pode receber uma função
    public $categoria_id = retornaCategoriaPadrao();
}
Classes e objetos são a mesma coisa?
É completamente natural confundir esses dois conceitos no início, mas é fundamental saber distinguir o que é classe e o que é objeto. E na verdade, veremos que isso é bem simples.

Vimos que uma classe é como um protótipo, um molde para criar um objeto de determinado tipo. Mas como isso funciona? A ideia é que a nossa loja possa ter zilhares de produtos, mas haverá apenas uma classe Produto. Um único molde. A partir dele, diversos objetos serão criados.

Uma analogia interessante é comparar uma classe com uma receita de bolo. A pergunta é certeira: você come uma receita de bolo? Não. Precisamos instanciá-la, criar um objeto bolo a partir dessa especificação (a classe) para utilizá-la. Podemos criar centenas de bolos a partir dessa classe (a receita, no caso), eles podem ser bem semelhantes, alguns até idênticos, mas são objetos diferentes.

Já vimos como criar uma classe, mas como utilizá-la?

Criando e usando objetos
Queremos a partir do molde Produto, construir (instanciar) um novo objeto desse tipo. Para fazer isso basta utilizar a palavra reservada new, seguida do nome da classe e opcionalmente os parênteses como a seguir:

$produto = new Produto();
Note que criamos uma variável $produto para que futuramente possamos nos referenciar a esse novo objeto que está sendo criado. Através dessa variável, podemos acessar e atribuir valores a ele, como por exemplo:

$produto->nome = "Livro da Casa do Código";
Utilizamos o operador ->, conhecido como Object Operator, para fazer essa atribuição. Da mesma forma podemos popular as propriedades preco, descricao, categoria e usado. Um exemplo seria:

$produto->nome = "Livro da Casa do Código";
$produto->preco = 29.90;
$produto->descricao = "Livro de tecnologia";
$produto->usado = "true";
$produto->categoria_id = 1;
É importante perceber que, mesmo que as propriedades tenham sido declaradas com o prefixo $, nós não usamos esse simbolo ao atribuir valores para elas. Sendo assim, o seguinte código é inválido:

<?php

// Código inválido!!!
$produto->$nome = "Livro da Casa do Código";
Colocando o conhecimento em prática
Agora que já temos uma base, vamos modificar nosso arquivo adiciona-produto.php para utilizar nossa classe Produto. No lugar de fazer:

$nome = $_POST["nome"];
$preco = $_POST["preco"];
$descricao = $_POST["descricao"];
$categoria_id = $_POST["categoria_id"];
if(array_key_exists('usado', $_POST)) {
    $usado = "true";
} else {
    $usado = "false";
}
Vamos criar um novo objeto do tipo Produto, e atribuir esses valores a ele. O código deve ficar assim:

$produto = new Produto();

$produto->nome = $_POST['nome'];
$produto->preco = $_POST['preco'];
$produto->descricao = $_POST['descricao'];
$produto->categoria_id = $_POST['categoria_id'];

if(array_key_exists('usado', $_POST)) {
    $produto->usado = "true";
} else {
    $produto->usado = "false";
}
Lembrando que para usar a classe Produto, precisaremos fazer o import do arquivo Produto.php. Para isso basta adicionar a linha junto com os outros imports no início do arquivo adiciona-produto.php:

require_once("class/Produto.php");
Feito isso, em nosso if, no lugar de fazer:

if (insereProduto($conexao, $nome, $preco, $descricao, $categoria_id, $usado)) { ?>
Podemos passar apenas o $produto como argumento:

if (insereProduto($conexao, $produto)) { ?>
Muito mais simples e declarativo, não acha? Vamos agora modificar a função insereProduto, no arquivo banco-produto.php, para que passe a funcionar dessa forma. O código agora está assim:

function insereProduto($conexao, $nome, $preco, $descricao, $categoria_id, $usado) {

    $query = "insert into produtos (nome, preco, descricao, categoria_id, usado) 
        values ('{$nome}', '{$preco}', '{$descricao}', '{$categoria_id}', {$usado})";

    return mysqli_query($conexao, $query);
}
A primeira mudança será na assinatura dessa função, que deve ficar:

function insereProduto($conexao, $produto) {
    // código omitido
}
E agora, em todo lugar que utilizávamos as variáveis diretamente, passaremos a usar a sintaxe do object operator (->) que acabamos de conhecer. O código deve ficar assim:

function insereProduto($conexao, Produto $produto) {

    $query = "insert into produtos (nome, preco, descricao, categoria_id, usado) 
        values ('{$produto->nome}', {$produto->preco}, '{$produto->descricao}', 
            {$produto->categoria_id}, {$produto->usado})";

    return mysqli_query($conexao, $query);
}
Tudo pronto, rode o código para ver o resultado. Tudo continua funcionando.

É interessante desde já perceber que essa simples mudança proporciona uma manutenibilidade e legibilidade melhor em nosso código. Se precisarmos adicionar um novo campo no Produto, a assinatura da função não vai mudar. Nenhum lugar que chama a função insereProduto precisará ser tocado.

PHP Orientado a Objetos
Apesar do PHP não ser uma linguagem puramente orientada a objetos, ela possui suporte à programação orientada a objetos e cada vez mais a comunidade e bibliotecas tem utilizado essa abordagem. A orientação a objetos é um paradigma que busca tornar seu código mais organizado e reutilizável, dividindo responsabilidades de forma clara dentro do sistema.

Muitos imaginam que as linguagens orientadas a objetos são coisas novas e que só apareceram da década de 90 pra cá. Na verdade, a orientação a objetos é um paradigma antigo e que foi implementado inicialmente na linguagem Smalltalk. Uma linguagem que surgiu na década de 70, apenas para estudos. Teve uma versão real da linguagem nos anos 80 e com os estudos e evolução da linguagem, outras foram seguindo o mesmo paradigma. C++, Java, C# e Ruby são algumas delas.

Mesmo com o grande incentivo da comunidade PHP para que ela se torne uma linguagem puramente orientada a objetos, muito legado ainda existe, o que dificulta a mudança de toda a linguagem e ferramentas. Neste capítulo, vimos algumas das muitas vantagens desse paradigma. Colocaremos tudo isso em prática em nossa aplicação.

(Obrigatório) Configuração do projeto Sugerir melhoria
Para o treinamento, você pode instalar o XAMPP.
XAMPP é um ambiente de desenvolvimento PHP! São vários componentes que vem com um único instalador para simplificar instalação e configuração. Os componentes são:

Apache - o servidor web (lá vão ficar as páginas HTML).
MariaDB - é a versão aberta do MySQL .
PHP - nossa linguagem de desenvolvimento WEB.
Perl - outra linguagem, mas não será utilizada durante do curso.
Para instalar o XAMPP entre primeiro no site: https://www.apachefriends.org/download.html.

E escolha a versão Windows, Linux ou Mac OSX.

MAC OSX

1 - Clique em Download na versão que lhe agrada. Por exemplo a v5.6.21 (PHP 5.6.21).

2 - Abra o arquivo DMG . 3 - Execute o programa dentro do DMG.

4 - Siga o processo de instalação.

5 - Teste acessar http://localhost.

6 - Vá para o terminal e execute o comando de stop e start, uma vez que o MySQL vem desligado:

/Applications/XAMPP/xamppfiles/xampp stop
/Applications/XAMPP/xamppfiles/xampp start
7 - Faça o download dos arquivos do curso aqui, extraia-os e copie o projeto loja para dentro de /Applications/XAMPP/xamppfiles/htdocs/:

8 - Acesse o phpMyAdmin, no menu superior da direita, clique em Banco de Dados e crie o banco de dados loja.

9 - Ainda no phpMyAdmin, selecione o database loja e clique na opção Import do menu principal, após isso selecione o arquivo loja.sql (que foi descompactado juntamente com o projeto loja) e clique em Executar.

10 - Acesse http://localhost/loja/index.php.

LINUX

1 - Clique em Download na versão que lhe agrada. Escolha corretamente se sua instalação é 32 ou 64 bits.

2 - Na linha de comando entre no diretório de Downloads e execute o instalador:

cd Downloads
su
chmod 755 xampp-linux-x64-5.6.21-0-installer.run
./xampp-linux-x64-5.6.21-0-installer.run
3 - Teste http://localhost.

4 - Por padrão o MySQL vem desligado, pare e reinicie os serviços do XAMPP:

su
/opt/lampp/lampp stop
/opt/lampp/lampp start
5 - Faça o download dos arquivos do curso aqui, extraia-os e copie o projeto loja para dentro de /opt/lampp/htdocs/. Dê permissão para seu usuário escrever neste diretório. No exemplo a seguir damos permissão para qualquer usuário ler e seu usuário escrever:

cd ~/Downloads
unzip curso-php-oo.zip
su
cp -R ~/Downloads/curso-php-oo/loja /opt/lampp/htdocs/
chmod u=rw,g=rw,o=r /opt/lampp/htdocs/loja
chown meu_usuario_linux /opt/lampp/htdocs/loja
exit
6 - Acesse o phpMyAdmin, no menu superior da direita, clique em Banco de Dados e crie o banco de dados loja.

7 - Ainda no phpMyAdmin, selecione o database loja e clique na opção Import do menu principal, após isso selecione o arquivo loja.sql (que foi descompactado juntamente com o projeto loja) e clique em Executar.

8 - Acesse http://localhost/loja/index.php.

WINDOWS 32 bits

1 - Clique em Download na versão do PHP que lhe agrada. Baixe o instalador (Installer).

2 - Rode o instalador e siga por todo o processo. Faça a instalação no diretório padrão (c:\xampp).

3 - Teste http://localhost.

4 - Como o MySQL não está rodando por padrão, abra a central de controle e clique no start do MySQL:

c:\xampp\xampp-control.exe
5 - Caso prefira usar o console ao invés do painel, rode o stop e start:

\xampp\xampp_stop.exe
\xampp\xampp_start.exe
6 - Faça o download dos arquivos do curso aqui, extraia-os e copie o projeto loja para dentro de c:\xampp\htdocs\:

7 - Acesse o phpMyAdmin, no menu superior da direita, clique em Banco de Dados e crie o banco de dados loja.

8 - Ainda no phpMyAdmin, selecione o database loja e clique na opção Import do menu principal, após isso selecione o arquivo loja.sql (que foi descompactado juntamente com o projeto loja) e clique em Executar.

9 - Acesse http://localhost/loja/index.php.

WINDOWS 64 bits

1 - Entre em http://www.wampserver.com/en/#download-wrapper.

2 - Selecione o download do WampServer com o PHP. O Wamp notificará que você deve instalar primeiro um pacote de Visual C. Instale primeiro este pacote, depois baixe o WampServer 64 bits.

3 - Siga o processo de instalação no diretório padrão c:\wamp. Não se preocupe com a configuração de e-mail, uma vez que usaremos o Gmail como servidor de e-mail.

4 - Abra o Wamp, indo em Start –> All Programs –> WampServer –> start WampServer.

5 - O Wamp aparecerá na barra de tarefas no canto de seu Windows. Clique nele e escolha Start all services.

6 - Abra seu navegador em http://localhost.

7 - Faça o download dos arquivos do curso aqui, extraia-os e copie o projeto loja para dentro de c:\wamp\www\:

8 - Acesse o phpMyAdmin, no menu superior da direita, clique em Banco de Dados e crie o banco de dados loja.

9 - Ainda no phpMyAdmin, crie e depois selecione o database loja e clique na opção Import do menu principal, após isso selecione o arquivo loja.sql (que foi descompactado juntamente com o projeto loja) e clique em Executar.

10 - Acesse http://localhost/loja/index.php.

Fim da instalação.


################# 2. Evoluindo a listagem de produtos #################

Estamos esquecendo de uma coisa. Categoria é um elemento importante em nossa aplicação, portanto, pode (e deve) ser representado como um objeto. Dentro da pasta class, vamos criar o arquivo Categoria.php com a classe Categoria e suas duas propriedades:

<?php 

class Categoria {
    public $id;
    public $nome;
}

?>
E a classe Produto passará a ter uma categoria, e não uma categoria_id:

<?php

class Produto {

    public $id;
    public $nome;
    public $preco;
    public $descricao;
    public $categoria;
    public $usado;
}

?>
Evoluindo nossas listagens
Agora que estamos trabalhando com objetos, podemos modificar um pouco nossas listagens de produto e categoria. Podemos começar pela função listaProdutos, do arquivo banco-produto.php. Note que estamos utilizando o mysqli_fetch_assoc para criar um array com os dados de cada produto:

function listaProdutos($conexao) {

    $produtos = array();
    $resultado = mysqli_query($conexao, "select p.*, c.nome as categoria_nome 
        from produtos as p join categorias as c on c.id=p.categoria_id");

    while($produto = mysqli_fetch_assoc($resultado)) {
        array_push($produtos, $produto);
    }

    return $produtos;
}
No lugar de trabalhar com esses arrays diretamente na página, podemos a cada iteração criar um objeto Produto com todas as informações necessárias. Para fazer isso, basta modificar o método listaProdutos como a seguir:

function listaProdutos($conexao) {

    $produtos = array();
    $resultado = mysqli_query($conexao, "select p.*, c.nome as categoria_nome 
        from produtos as p join categorias as c on c.id=p.categoria_id");

    while($produto_array = mysqli_fetch_assoc($resultado)) {

        $categoria = new Categoria();
        $categoria->nome = $produto_array['categoria_nome'];

        $produto = new Produto();
        $produto->id = $produto_array['id'];
        $produto->nome = $produto_array['nome'];
        $produto->descricao = $produto_array['descricao'];
        $produto->categoria = $categoria;
        $produto->preco = $produto_array['preco'];
        $produto->usado = $produto_array['usado'];

        array_push($produtos, $produto);
    }

    return $produtos;
}
Feito isso, precisaremos mudar a forma que estamos lidando com esses valores no arquivo produto-lista.php. No lugar de fazer:

<table class="table table-striped table-bordered">

    <?php
    $produtos = listaProdutos($conexao);
    foreach ($produtos as $produto) :
    ?>
        <tr>
            <td><?= $produto['nome'] ?></td>
            <td><?= $produto['preco'] ?></td>

            <!-- continuação do código omitido -->
        </tr>
    <?php
    endforeach
    ?>    
</table>
Passaremos a utilizar a sintaxe de objetos, com o ->. Repare:

<table class="table table-striped table-bordered">

    <?php
    $produtos = listaProdutos($conexao);
    foreach ($produtos as $produto) :
    ?>
        <tr>
            <td><?= $produto->nome ?></td>
            <td><?= $produto->preco ?></td>

            <!-- continuação do código omitido -->
        </tr>
    <?php
    endforeach
    ?>    
</table>
Devemos modificar todo o arquivo para utilizar a sintaxe de objetos (->).

Excelente. Podemos fazer o mesmo que fizemos com a listagem de produtos com a listagem de categorias, que por enquanto ainda usa um array. A alteração é bem simples, na verdade, exatamente o que fizemos agora com o produto. Basta abrir o arquivo banco-categoria.php e editar a função listaCategorias:

<?php
require_once("conecta.php");
require_once("class/Categoria.php");        

function listaCategorias($conexao) {

    $categorias = array();
    $query = "select * from categorias";
    $resultado = mysqli_query($conexao, $query);

    while($categoria_array = mysqli_fetch_assoc($resultado)) {

        $categoria = new Categoria();
        $categoria->id = $categoria_array['id'];
        $categoria->nome = $categoria_array['nome'];

        array_push($categorias, $categoria);
    }

    return $categorias;
}
Agora no arquivo produto-formulario-base.php podemos alterar os lugares que usam o array de categorias para a forma orientada a objetos:

<tr>
    <td>Categoria</td>
    <td>
        <select name="categoria_id" class="form-control">
            <?php
            foreach($categorias as $categoria) : 
                $essaEhACategoria = $produto->categoria->id == $categoria->id;
                $selecao = $essaEhACategoria ? "selected='selected'" : "";
            ?>
                <option value="<?=$categoria->id?>" <?=$selecao?>>
                    <?=$categoria->nome?>
                </option>
            <?php
            endforeach
            ?>
        </select>
    </td>
</tr>
Excelente, após essas alterações podemos executar o código e tudo continuará funcionando conforme esperado.

Relacionamento de objetos
Podemos notar que a categoria até então era controlada por um id, referenciado no produto. Porém, queremos manter nosso sistema orientado a objetos. Dessa forma, criamos também, além da classe Produto, a classe Categoria. Essa classe vai representar uma Categoria em nosso sistema.

Agora que temos duas classes, Produto e Categoria, podemos e devemos criar um relacionamento entre elas. Sempre que criarmos um objeto Produto, poderemos colocar um outro objeto na propriedade $categoria. Nosso código de instância de Produto ficará assim:

// Propriedades comuns
$produto->nome = "Livro da Casa do Código";
$produto->preco = 29.90;
$produto->descricao = "Livro de tecnologia";
$produto->usado = "true";

// Novo objeto Categoria
$produto->categoria = new Categoria();
Assim, usaremos a propriedade de classe $categoria como uma referência a outro objeto, criando um relacionamento entre o objeto Produto e Categoria.


################# 3. Métodos #################

Vimos que o uso de classes já torna algumas coisas mais interessantes em nosso sistema. Temos uma forma forte de representar elementos importantes em nosso código. Mas até agora, nossas classes Produto e Categoria só tem propriedades, ou seja, só guardam estado. Uma classe também pode, e deve, ter comportamentos. Por exemplo, como faríamos para aplicar um desconto de 10% no valor real do produto? Uma forma simples de fazer seria:

$produto->preco -= $produto->preco * 0.1;
Estamos subtraindo da propriedade $preco o seu próprio valor, multiplicado por 0.1. O código funciona, mas vamos copiar e colar em todos os lugares que precisamos dessa conta? Não é uma boa ideia. Podemos criar uma função que receba um Produto por parâmetro, para que seja possível reutilizar esse comportamento uma vez definido:

function precoComDesconto(Produto $produto) {
    $produto->preco -= $produto->preco * 0.1;
    return $produto->preco;
}
Agora, para aplicar o desconto, basta fazer:

$produto = new Produto();
$produto->preco = 50.00;
precoComDesconto($produto); // 45.00
Estamos no caminho certo, mas ainda há um problema. Onde essa função deverá ser definida? No arquivo que ela será usada? E se forem vários arquivos? Criamos um arquivo novo só pra ela? Adicionamos no banco-produto.php? Mas ela não é uma função de banco. Nenhuma das soluções parecem muito satisfatória, não é?

E que tal criarmos essa função dentro da própria classe Produto? Dessa forma, todos que tem acesso ao Produto, terão acesso a esse comportamento em comum. Além disso, a função já terá acesso fácil à propriedade $preco, também definida nessa classe. Essa é uma solução muito mais interessante do que deixar a função em um local desatrelado das informações do Produto. Assim mantemos o estado e comportamento juntos.

Chamamos de método as funções que definimos dentro de uma classe, já que elas definem a forma (método) de fazer operações em determinado objeto.

Vamos fazer a alteração. A classe Produto deve ficar assim:

<?php

class Produto {

    public $id;
    public $nome;
    public $preco;
    public $descricao;
    public $categoria;
    public $usado;

    public function precoComDesconto() {
        $this->preco -= $this->preco * 0.1;
        return $this->preco;
    }
}
?>
Repare que no lugar de recebermos um $produto como argumento, não recebemos mais nada, e agora estamos usando a pseudo variável $this, para nos referenciar ao objeto que está chamando essa função. Para executar o método precoComDesconto, também utilizaremos o ->. O termo usado para isso é invocação de método.

$produto->precoComDesconto();
Podemos deixar esse método ainda mais mais flexível, recebendo o valor do desconto como um argumento (parâmetro) no lugar de sempre aplicar o valor fixo de 0.1.

function precoComDesconto($valor) {
    $this->preco -= $this->preco * $valor;
    return $this->preco;
}
Podemos passar quantos argumentos, ou parâmetros (como são chamados), forem necessários para nossos métodos. Um parâmetro nada mais é do que uma variável comum, chamada também de temporária ou local, pois, ao final da execução desse método, ela deixa de existir.

Agora, ao invocar o método precoComDesconto, podemos passar o valor que deverá ser calculado. Um exemplo seria:

$produto->precoComDesconto(0.1);
Vamos colocar esse código em prática na listagem de produtos. Podemos criar uma nova coluna, ao lado do valor real do produto, mostrando seu valor com desconto. No arquivo produto-lista.php:

<table class="table table-striped table-bordered">

<?php
$produtos = listaProdutos($conexao);
foreach ($produtos as $produto) :
?>
    <tr>
        <td><?= $produto->nome ?></td>
        <td><?= $produto->preco ?></td>
        <td><?= $produto->precoComDesconto(0.1) ?></td>
        <!-- continuação da tabela -->
Mas há um problema: o que acontecerá se algum desenvolvedor fornecer um valor negativo de desconto? Vamos adicionar juros ao produto! E se fosse um valor maior que 50%? Provavelmente teremos um prejuízo! Um exemplo:

$produto = new Produto();
$produto->preco = 50.00;
$produto->precoComDesconto(0.7); // 15.00
$produto->precoComDesconto(-1); // 100.00
Não podemos permitir que nenhuma dessas situações aconteça. Podemos criar uma função para que seja possível reutilizar esse comportamento uma vez definido, e dentro dela já validar que o valor de desconto só é válido se for maior que 0 e menor ou igual a 0.5 (que representa 50%) , antes de aplicar ao preço do produto:

function precoComDesconto($valor) {
    if ($valor > 0 && $valor <= 0.5) {
        $this->preco -= $this->preco * $valor;
    }
    return $this->preco;
}
Para Saber Mais: Sobrecarga com parâmetros opcionais
Um recursos interessante e que pode ser bastante útil são os parâmetros opcionais. Quando necessário, você pode atribuir um valor padrão para o parâmetro como a seguir:

function precoComDesconto($valor = 0.1) {
    if ($valor > 0 && $valor <= 0.5) {
        $this->preco -= $this->preco * $valor;
    }
    return $this->preco;
}
Neste exemplo, caso o valor do desconto não tenha sido fornecido, ele será de 10%. Esse recurso é bastante utilizado quando precisamos fazer uma sobrecarga de método, já que em PHP não podemos ter métodos com o mesmo nome.

Uma regra importante é que quando temos os dois tipos de parâmetros (opcionais e não opcionais) declarados, os opcionais tem que ser os últimos na lista de parâmetros. Por exemplo:

function precoComDesconto($paramObrigatorio, $valor = 0.1) {
    // ...
}
Declarar o $paramObrigatorio por último resultaria em um erro.

Como chamamos o comportamento definido em classes?

Resposta correta: Métodos
Repare que usamos a mesma palavra chave function para definir o método na classe:

class Produto {

    public $id;
    public $nome;
    public $preco;
    //outros atributos omitidos

    public function precoComDesconto($valor = 0.1) {
        $this->preco -= $this->preco * $valor;
        return $this->preco;
    }
}
No entanto, essa função precoComDesconto agora é associada com a classe e só podemos chamá-la com um objeto em mãos, nunca sozinha! Veja o exemplo:

$produto = new Produto();
$produto->preco = 40;

//chamando método a partir do $produto
$produto->precoComDesconto(0.1);
Nunca podemos chamar apenas a função solta:

precoComDesconto(0.1); //nao funciona! nao tem produto

Uma das principais diferenças entre programação procedural e orientada a objetos é:
a) No paradigma procedural você só concentra comportamentos enquanto que no outro você só concentra estados(atributos).

b) No paradigma procedural o estado e o comportamento não vivem juntos enquanto que no outro eles vivem.

c) No paradigma procedural o estado e o comportamento vivem juntos enquanto que no outro eles vivem separados.

Qual das afirmações está correta?

Resposta correta: b
No paradigma procedural o estado e o comportamento não vivem juntos, só concentra comportamento. No paradigma orientado a objetos o estado e o comportamento vivem juntos.

Em outras palavras, um produto tem todas as características de um produto e também possui o comportamento relacionado com o produto! Assim juntamos os dados e o comportamento em um lugar só que é a classe. Isso cria uma organização melhor do nosso código.

Veja a classe abaixo que representa uma conta:
class Conta {

    public $saldo;
    public $numero;

    function deposita($valor) {
        //codigo
    }
}
O que devemos colocar no lugar de //codigo para depositar corretamente o valor na conta?

O correto é:
$this->saldo += $valor;
Podemos escrever o mesmo código de forma mais extensa:

$this->saldo = $this->saldo + $valor;
A palavra chave $this é para mostrar que esse é um atributo, e não uma variável simples (por exemplo $valor é apenas uma variável simples). Você pode pensar que $this é a referência ao objeto atual.

Para testar o método podemos escrever:

$conta = new Conta();
$conta->deposita(300);

################# 4. Encapsulamento #################

Ao criar o método precoComDesconto, resolvemos apenas uma parte do problema. Ele já torna nosso comportamento mais centralizado na classe Produto, evitando repetições, já que isola essa regra em comum. Mas ainda é possível fazer:

$produto->preco -= $produto->preco * 99999;
Em outras palavras, ninguém garante que o usuário dessa classe vai sempre usar o método precoComDesconto, já que ele pode acessar o $preco do produto diretamente. Isso é um problema bem grave, nunca queremos permitir que nossa regra de negócio seja violada.

Como resolver isso? A melhor forma seria proibindo o acesso direto ao atributo $preco, assim o usuário da classe Produto só conseguirá aplicar um desconto utilizando o método precoComDesconto, que faz todas as validações necessárias.

Para fazer isso, basta modificar a visibilidade do atributo para private. Dessa forma ele será acessível apenas por dentro da própria classe:

class Produto {

    private $preco;
    // outras propriedades escondidas

    function precoComDesconto($valor = 0.1) {
        if ($valor > 0 && $valor <= 0.5) {
            // eu posso acessar, estou na mesma classe
            $this->preco -= $this->preco * $valor;
        }
        return $this->preco;
    }
}
O private que utilizamos agora é, assim como o public, um modificador de visibilidade (acesso). Ao manter um atributo ou método como private, estamos fechando completamente sua visibilidade para todas as demais classes do sistema, exceto a própria classe que o declarou.

Modificadores de visibilidade
Isso é excelente e já resolve nosso problema! Ninguém mais consegue aplicar um desconto em um produto sem ser passando pelo método precoComDesconto. Mas ainda não terminamos, pois o seguinte código da listagem passa a dar erro:

<table class="table table-striped table-bordered">

    <?php
    $produtos = listaProdutos($conexao);
    foreach ($produtos as $produto) :
    ?>
        <tr>
            <td><?= $produto->nome ?></td>
            <td><?= $produto->preco ?></td>
            <td><?= $produto->precoComDesconto(0.1) ?></td>
            <!-- continuação da tabela -->
O problema está na linha que imprime o preço do produto:

<td><?= $produto->preco ?></td>
Esse código agora é inválido, já que não podemos mais acessar o preço do produto fora da sua classe.

É muito comum, e faz todo sentido, que suas propriedades sejam private e quase todos seus métodos sejam public (não é uma regra!). Desta forma, toda conversa de um objeto com outro é feita por troca de mensagens, isto é, acessando seus métodos. Algo muito mais educado que mexer diretamente em um atributo que não é seu!

Melhor ainda! O dia em que precisarmos mudar, como é feito no desconto em nosso Produto, adivinhe onde precisaríamos modificar? Apenas no método precoComDesconto, o que faz pleno sentido. Como exemplo, imagine que o desconto em algum momento precise ser no máximo 30%. Basta você modificar ali, na classe Produto e nenhum outro código fora dela. Além disso, as classes que usam esse método nem precisam ficar sabendo de tal modificação! Ganhamos muito em esconder o funcionamento do nosso método na hora de dar manutenção e fazer modificações.

A ideia de esconder os membros de uma classe (como fizemos com o preço do produto), além de esconder o funcionamento interno de seus métodos, é conhecida como encapsulamento. Encapsular é fundamental para que seu sistema seja suscetível a mudanças: não precisaremos mudar uma regra de negócio em vários lugares, mas sim em apenas um único lugar, já que essa regra está encapsulada.

Getters e Setters
Já que não conseguimos acessar o preco do produto diretamente, como faremos para mostrá-lo na tela de listagem, já que não podemos acessá-lo nem mesmo apenas para leitura?

Precisamos de uma forma de fazer esse acesso, um comportamento (método) com essa responsabilidade. Podemos fazer isso de forma simples, criando um método getPreco:

class Produto {

    private $preco;
    // outras propriedades omitidas

    public function precoComDesconto($valor = 0.1) {
        if ($valor > 0 && $valor <= 0.5) {
            $this->preco -= $this->preco * $valor;
        }
        return $this->preco;
    }

    public function getPreco() {
        return $this->preco;
    }
}
E a partir de agora, podemos acessar o $preco do produto apenas por esse método. Em nossa listagem faremos:

<td><?= $produto->getPreco() ?></td>
Note que agora estamos permitindo acesso a esse atributo de forma controlada. E não chamamos esse método de getPreco por acaso, essa é uma convenção muito conhecida. Sempre que queremos retornar (pegar) um valor, chamamos o método de get seguido do nome do atributo. Neste caso, getPreco. De forma similar, quando queremos mudar (inserir) um valor, chamamos o método de set. Um exemplo seria:

public function setPreco($preco) {
    $this->preco = $preco;
}
Ainda podemos definir uma "regra" para esse preço, podemos dizer que o preço passado para o método setPreco não pode ser negativo:

public function setPreco($preco) {
    if ($preco > 0) {
        $this->preco = $preco;
    }
}
Note como fica nossa classe, agora com todas as propriedades private e seus devidos getters e setters.

class Produto {

    private $id;
    private $nome;
    private $preco;
    private $descricao;
    private $categoria;
    private $usado;

    public function precoComDesconto($valor = 0.1) {
        if ($valor > 0 && $valor <= 0.5) {
            $this->setPreco($this->preco - $this->preco * $valor);
        }
        return $this->preco;
    }

    public function getId() {
        return $this->id;
    }

    public function setId($id) {
        $this->id = $id;
    }

    public function getNome() {
        return $this->nome;
    }

    public function setNome($nome) {
        $this->nome = $nome;
    }

    public function getPreco() {
        return $this->preco;
    }

    public function setPreco($preco) {
        if ($preco > 0) {
            $this->preco = $preco;
        }
    }

    public function getDescricao() {
        return $this->descricao;
    }

    public function setDescricao($descricao) {
        $this->descricao = $descricao;
    }

    public function getCategoria() {
        return $this->categoria;
    }

    public function setCategoria($categoria) {
        $this->categoria = $categoria;
    }

    public function isUsado() {
        return $this->usado;
    }

    public function setUsado($usado) {
        $this->usado = $usado;
    }

}
Note que o setter sempre recebe um argumento, que é o valor que deve ser atribuído. Para adicionar o preço do produto, por exemplo, faremos:

<?php
    $produto = new Produto();
    $produto->setPreco(59.90);
?>
Feito isso, precisaremos modificar todos os lugares onde acessamos as propriedades da classe Produto diretamente. O código agora está encapsulado! Um exemplo será no arquivo produto-lista.php. Ele deve ficar assim:

<?php
require_once("cabecalho.php");
require_once("banco-produto.php");
?>

<table class="table table-striped table-bordered">
    <?php
    $produtos = listaProdutos($conexao);
    foreach($produtos as $produto) :
    ?>
        <tr>
            <td><?= $produto->getNome() ?></td>
            <td><?= $produto->getPreco() ?></td>
            <td><?= $produto->precoComDesconto() ?></td>
            <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
            <td><?= $produto->getCategoria()->getNome() ?></td>
            <td>
                <a class="btn btn-primary" 
                    href="produto-altera-formulario.php?id=<?=$produto->getId()?>">
                    alterar
                </a>
            </td>
            <td>
                <form action="remove-produto.php" method="post">
                    <input type="hidden" name="id" value="<?=$produto->getId()?>">
                    <button class="btn btn-danger">remover</button>
                </form>
            </td>
        </tr>
    <?php
    endforeach
    ?>
</table>

<?php include("rodape.php"); ?>
Esse está pronto, mas ainda precisamos mudar os outros arquivos que fazem o acesso direto. Nos exercícios mudaremos um por um, mãos na massa!

Sobre a visibilidade dos atributos e métodos em PHP, julgue as afirmativas abaixo:
1- Quando não declaramos o modificador de acesso dos atributos de uma classe , por padrão o atributo terá um acesso public.

2- Quando colocamos um atributo como private , apenas a própria classe consegue acessar e alterar diretamente os seus atributos.

3- Ao contrário dos atributos, quando não declaramos um modificador de acesso nos métodos de uma classe, ele por padrão é private.

Em PHP, quando não especificamos o modificador de acesso, por padrão, tanto métodos como atributos são considerados public.
O modificador private serve para restringir o acesso a atributos e métodos da classe, permitindo apenas a própria classe acessar e modificar os seus atributos.

Então, as alternativas corretas eram apenas a 1 e 2.

Também existe o modificador de acesso protected, que não foi usado neste vídeo, mas que será explicado mais à frente no treinamento.

Qual das opções abaixo cria um método chamado precoComFrete($distancia), que atende aos seguintes requisitos:
Se a distância for maior que 10km, adiciona 10 reais ao valor do preço.
Mas caso a distância seja superior a 20km, adiciona 30 reais ao preço.
Se a distância for até 10km (inclusive), adiciona um valor simbólico de 2 reais ao preço.
Considere que a distância já está em km quando for passada para o método.

function precoComFrete($distancia) {
    if ($distancia > 10 && $distancia <= 20) {
        return $this->preco + 10;
    } elseif ($distancia > 20) {
        return $this->preco + 30;
    }
    return $this->preco + 2;
}
Esta correto por que apenas se a distancia for até 10, o valor 2 será adicionado ao preço. O restante dos valores seguem regra semelhante, sendo exclusivas umas das outras.

Qual o comportamento do código abaixo?
class Pessoa {

    private $nome;

    public function getNome() {
        return $this->nome;
    }

    private function setNome($nome) {
        $this->nome = $nome;
    }

}

O atributo nome pode ser lido, mas não pode ser alterado por outras classes.
Está correto porque o nome pode ser lido por causa do método getNome, mas não alterado por que o método setNome está privado.

Modifique a visibilidade de todas as propriedades da classe Produto para private.
class Produto {

    private $preco;
    // mude também as outras propriedades
}
O que acontece se você tentar acessar a listagem de produtos, ou fazer qualquer outra operação com essa classe agora?

Dessa forma, a propriedade só será acessível dentro da própria classe.
A classe Produto ficará assim:

<?php

class Produto {

    private $id;
    private $nome;
    private $preco;
    private $descricao;
    private $categoria;
    private $usado;

    public function precoComDesconto($valor = 0.1) {

        if ($valor > 0 && $valor <= 0.5) {
            $this->preco -= $this->preco * $valor;
        }

        return $this->preco;
    }

}

?>

Crie os getters e setters da sua classe Produto. Exemplo:
class Produto {

    private $id;
    private $nome;
    private $preco;
    private $descricao;
    private $categoria;
    private $usado;

    public function getId() {
        return $this->id;
    }

    public function setId($id) {
        $this->id = $id;
    }

    // faça o mesmo para as outras propriedades
}

Vale lembrar que nem sempre devemos criar setters para tudo. O ideal é criar apenas quando e se for necessário.
Segue a classe Produto completa:

<?php

class Produto {

    private $id;
    private $nome;
    private $preco;
    private $descricao;
    private $categoria;
    private $usado;

    public function getId() {
        return $this->id;
    }

    public function setId($id) {
        $this->id = $id;
    }

    public function getNome() {
        return $this->nome;
    }

    public function setNome($nome) {
        $this->nome = $nome;
    }

    public function getPreco() {
        return $this->preco;
    }

    public function setPreco($preco) {
        $this->preco = $preco;
    }

    public function getDescricao() {
        return $this->descricao;
    }

    public function setDescricao($descricao) {
        $this->descricao = $descricao;
    }

    public function getCategoria() {
        return $this->categoria;
    }

    public function setCategoria($categoria) {
        $this->categoria = $categoria;
    }

    public function isUsado() {
        return $this->usado;
    }

    public function setUsado($usado) {
        $this->usado = $usado;
    }

    public function precoComDesconto($valor = 0.1) {

        if ($valor > 0 && $valor <= 0.5) {
            $this->preco -= $this->preco * $valor;
        }

        return $this->preco;
    }
}

?>

http://blog.caelum.com.br/nao-aprender-oo-getters-e-setters/

################# 5. Comparando objetos #################

Para conhecer um pouco mais sobre objetos, vamos escrever e executar o seguinte código onde comparamos dois produtos com o mesmo preço e nome:

<?php
    require "class/Produto.php";

    $produto = new Produto();
    $produto->setPreco(59.9);
    $produto->setNome("Livro da Casa do Codigo");

    $outroProduto = new Produto();
    $outroProduto->setPreco(59.9);
    $outroProduto->setNome("Livro da Casa do Codigo");

    if ($produto == $outroProduto) {
        echo "sao iguais";
    } else {
        echo "sao diferentes";
    }
?>
O resultado impresso será: sao iguais. Isso acontece pois quando utilizamos o == para comparar objetos em PHP, as instâncias são consideradas iguais se são instâncias da mesma classe e têm as mesmas propriedades e valores. Como $produto e $outroProduto são instâncias da classe Produto e tem o mesmo $preco e $nome preenchidos, a comparação será verdadeira.

Se você não esperava isso, pode comparar com o operador de identidade === (3 iguais). Neste caso a comparação só será verdadeira se os objetos se referem à mesma instância da mesma classe. Em outras palavras, só será igual se for o mesmo objeto. Em exemplo, vamos mudar a comparação para === e executar o código novamente.

<?php
    require "class/Produto.php";

    $produto = new Produto();
    $produto->setPreco(59.9);
    $produto->setNome("Livro da Casa do Codigo");

    $outroProduto = new Produto();
    $outroProduto->setPreco(59.9);
    $outroProduto->setNome("Livro da Casa do Codigo");

    if ($produto === $outroProduto) {
        echo "sao iguais";
    } else {
        echo "sao diferentes";
    }
?>
Dessa vez a saída será sao diferentes, afinal, apesar de terem o mesmo valor, são produtos diferentes na memória.

Objetos são acessados por referência
É fundamental sempre lembrarmos que uma variável de instância guarda apenas a referência (um número/endereço), apontando para o local da memória onde as informações sobre um objeto estão guardadas. Sendo assim, a cada classe que criamos a referência será diferente.

Para que a comparação anterior seja verdadeira, podemos fazer algo como:

$produto = new Produto();
$produto->setPreco(59.9);
$produto->setNome("Livro da Casa do Codigo");

$outroProduto = new Produto();
$outroProduto->setPreco(59.9);
$outroProduto->setNome("Livro da Casa do Codigo");

$outroProduto = $produto;
Note que dessa forma, $outroProduto passa a referenciar o mesmo objeto que a variável $produto referencia. Sendo assim, ao comparar os dois com o operador de identidade === elas serão consideradas iguais. O código fica assim:

<?php

    require "class/Produto.php";

    $produto = new Produto();
    $produto->setPreco(59.9);
    $produto->setNome("Livro da Casa do Codigo");

    $outroProduto = new Produto();
    $outroProduto->setPreco(59.9);
    $outroProduto->setNome("Livro da Casa do Codigo");

    $outroProduto = $produto;

    if ($produto === $outroProduto) {
        echo "sao iguais";
    } else {
        echo "sao diferentes";
    }

?>
Ao executar, o valor são iguais será exibido.

Pesquise quando devemos usar == ou ===. Qual a melhor opção quando estamos comparando objetos?

Depende muito do tipo de comparação que queremos fazer. Se queremos saber se as propriedades de dois objetos diferentes são iguais, devemos usar o ==. Já quando queremos saber se dois objetos são iguais (mesma referência), partimos para o ===.

Observe o seguinte código onde comparamos dois Produtos:
<?php

    require "class/Produto.php";

    $produto = new Produto();
    $produto->setPreco(30.5);
    $produto->setNome("Livro da Casa do Codigo");

    $outroProduto = new Produto();
    $outroProduto->setPreco(59.9);
    $outroProduto->setNome("Livro da Casa do Codigo");

    if ($produto == $outroProduto) {
        echo "sao iguais";
    } else {
        echo "sao diferentes";
    }

?>
Qual será a saída ao executá-lo? Você pode realizar um teste em sua máquina.

O resultado impresso será: sao diferentes. Isso acontece pois quando utilizamos o == para comparar objetos em PHP, as instâncias são consideradas iguais se são instâncias da mesma classe e têm as mesmas propriedades e valores. Veja que cada instância possui um valor diferente.

E se mudarmos para === (operador de identidade). O que acontece?
<?php

    require "class/Produto.php";

    $produto = new Produto();
    $produto->setPreco(59.9);
    $produto->setNome("Livro da Casa do Codigo");

    $outroProduto = $produto;
    $outroProduto->setPreco(100.6);
    $outroProduto->setNome("Livro da Casa do Codigo");

    if ($produto === $outroProduto) {
        echo "sao iguais";
    } else {
        echo "sao diferentes";
    }

?>

Neste caso a comparação será verdadeira, ou seja, será impresso sao iguais, pois quando usamos === estamos verificando se as variáveis apontam para o mesmo objeto na memória.

################# 6. Magic methods #################

Sempre que instanciamos uma novo objeto, utilizando a palavra reservada new, o PHP executa um método especial chamado __construct em sua classe. Você pode definir esse método para executar alguma ação toda vez que um objeto daquele tipo for criado. Um exemplo seria:

class Produto {

    private $id;
    // outras propriedades

    function __construct() {
        echo "Construindo um Produto";
    }
    // outros métodos
}
Agora que temos esse método definido, toda vez que alguém criar um novo Produto, a mensagem construindo um Produto será exibida. É como um evento que será executado sempre que uma classe desse tipo for instanciada.

Outro ponto interessante é que o método __construct pode receber parâmetros, sendo assim podemos inicializar nossas propriedades ou qualquer outra informação que seja necessária. Por exemplo, vamos criar um construtor que já receba o nome e preço do Produto:

class Produto {

    private $nome;
    private $preco;
    // outras propriedades

    function __construct($nome, $preco) {
        $this->nome = $nome;
        $this->preco = $preco;
    }
    // outros métodos
}
Note que agora, ao tentar criar um Produto sem passar nome ou preco como parâmetro, receberemos o seguinte warning:

Warning: Missing argument 1 for Produto::__construct(), called in
/Users/turini/Desktop/cursophp/loja/index.php on line 9 and defined in
/Users/turini/Desktop/cursophp/loja/produto.php on line 12

Warning: Missing argument 2 for Produto::__construct(), called in
/Users/turini/Desktop/cursophp/loja/index.php on line 9 and defined in
/Users/turini/Desktop/cursophp/loja/produto.php on line 12
Para resolver isso, tudo que precisamos fazer é mudar a forma que estamos criando o Produto. Mas antes, vamos mudar o construtor para receber todos os atributos da classe, exceto o $id:

function __construct($nome, $preco, $descricao, Categoria $categoria, $usado) {
    $this->nome = $nome;
    $this->preco = $preco;
    $this->descricao = $descricao;
    $this->categoria = $categoria;
    $this->usado = $usado;
}
Agora, no lugar de fazer:

$produto = new Produto();
$produto->setNome("Livro da Casa do Codigo");
$produto->setPreco(59.90);
$produto->setDescricao("Livro de PHP");
$produto->setCategoria(new Categoria());
$produto->setUsado("false");
Passaremos a fazer:

$produto = new Produto("Livro da Casa do Codigo", 59.90, "Livro de PHP", new Categoria(), "false");
Normalmente utilizamos o construtor quando queremos forçar a passagem de um valor obrigatório. Se todo Produto obrigatoriamente precisa pelo menos de um nome, um preco ou qualquer outro atributo para existir, como garantir que essas informações serão passadas? Podemos criar um método __construct que receba os parâmetros necessários.

Outro recurso interessante do PHP são os métodos destrutores. Você pode criar um método chamado __destruct em sua classe, que será chamado assim que todas as referências para esse objeto específico forem removidas, ou ainda caso ele tenha sido destruído explicitamente.

Um exemplo seria:

class Produto {

    private $id;
    // outras propriedades

    function __construct($nome, $preco, $descricao, Categoria $categoria, $usado) {
        $this->nome = $nome;
        $this->preco = $preco;
        $this->descricao = $descricao;
        $this->categoria = $categoria;
        $this->usado = $usado;
    }

    function __destruct() {
        echo "Destruindo o produto ".$this->nome;
    }
    // outros métodos
}
Após utilizar o produto que criamos, a seguinte mensagem será exibida:

Destruindo o produto Livro da Casa do Codigo
Representando o objeto como um texto
Outra necessidade comum do dia-a-dia é representar nossos objetos como um texto. Sabemos que para mostrar o nome do Produto, por exemplo, podemos fazer:

echo $produto->getNome();
Mas o que acontece se eu mandar imprimir a variável produto inteira?

echo $produto;
Bem, nesse caso a saída não será muito agradável. Receberemos o fatal error a seguir:

Catchable fatal error: Object of class Produto could not be converted to string
    in /Users/turini/Desktop/cursophp/loja/index.php on line 24
O Produto não pode ser convertido como um texto. Claro, podemos usar o var_dump para ter um resultado mais perto do que esperamos. Seria algo como:

var_dump($produto);
Neste caso a saída (formatada, para melhor legibilidade) será:

object(Produto)#1 (6) { 
    ["id":"Produto":private]=> NULL 
    ["nome":"Produto":private]=> string(24) "Livro da Casa do Codigo" 
    ["preco":"Produto":private]=> float(59.9) 
    ["descricao":"Produto":private]=> string(13) "Livro de PHP"
    ["categoria_id":"Produto":private]=> NULL 
    ["usado":"Produto":private]=> bool(false) 
}
Já é bem melhor, mas queremos algo mais simples. Quando imprimir um produto seria interessante mostrarmos apenas seu nome e preco, como a seguir:

Livro da Casa do Codigo: R$ 59.90
Podemos utilizar outro método bastante comum para nos ajudar nesta tarefa, o __toString. Ele ensina ao PHP como se comportar caso algum objeto desse tipo seja convertido para uma string. Neste caso, na classe Produto, faremos:

function __toString() {
    return $this->nome.": R$ ".$this->preco;
}
Tudo pronto, qual a saída ao executar a instrução echo $produto?

Para saber mais: Magic methods
Como vimos, os métodos __construct, __destruct e __toString tem um significado especial no PHP. Eles são conhecidos como Magic Methods. Se quiser, você pode ler mais a respeito e conhecer outros métodos mágicos pela documentação da linguagem, aqui.

Os métodos que começam com __ em PHP tem um sentido especial, esses são os conhecidos magic methods. Além do __construct, __destruct e __toString que já vimos, existem vários outros
