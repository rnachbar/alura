JavaScript é uma linguagem de programação, baseada em script que funciona em várias plataformas (ex: navegadores)
No servidor: node.js

############### 1. Introdução ###############

Introdução
Javascript é uma das linguagens mais importantes de nosso tempo, justamente por ser entendida pelos mais diversos navegadores (desktop/mobile) sem a necessidade de instalação de plugins ou qualquer outro artifício.

Além de ser a lingua franca da web, ela é cada vez mais usada em servidores web devido ao sucesso do Node.js que revigorou a ideia de se trabalhar com esta linguagem no lado do servidor, algo que a Netscape havia tentado no passado, mas que não emplacou.

Há ainda smartphones que permitem criar aplicativos com Javascript como o Windows Phone 8.

O padrão ECMASCRIPT
O nome Javascript esta no coletivo imaginário dos desenvolvedores, mas na verdade a linguagem segue o padrão ECMA-262. Este padrão foi criado para tentar unificar a sintaxe e garantir a compatibilidade entre os diversos navegadores do mercado.

Você aprenderá neste treinamento a sintaxe do ECMASCRIPT versão 5, permitindo aplicar seu conhecimento em qualquer plataforma que suporte a linguagem, sejam elas navegadores, smartphones ou servidores que suportem este padrão.

Navegador como plataforma
Javascript é uma linguagem interpretada, isto é, os scripts são lidos linha a linha e cada instrução é traduzida por um interpretador. Para facilitar seu aprendizado e dispensar qualquer configuração extra em sua máquina, utilizaremos o Google Chrome como plataforma, ele será nosso ambiente de execução de Javascript.

Escolhemos o Chrome, mas nada impede que você escolha outro navegador como Firefox, Safari, entre outros. O importante é que o navegador escolhido suporte o ECMASCRIPT 5, padrão suportado por navegadores modernos.

Preparando o ambiente e considerações gerais
Independente do sistema operacional que você use ou editor de texto favorito, por uma questão de organização, sugerimos que você crie uma pasta com o nome alura-js com a finalidade de armazenar as páginas que forem pedidas ao longo dos capítulos.

Qual editor de texto usar? Aquele que você já domina, claro! Até mesmo o mais simples dos editores é suficiente para o seu treinamento. Nos vídeos o instrutor estará utilizando o Sublime Text 2 para Ubuntu.

Ao decorrer do curso, utilizaremos uma página HTML com o título do capítulo em questão, ela deve ser criada na pasta alura-js com o nome introducao.html e com a seguinte estrutura:

<!-- introducao.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
    </body>
</html>
Ah, não se esqueça de que "grandes poderes trazem grandes responsabilidades" e que o aprendizado da linguagem Javascript abrirá novas portas para você, seja no desenvolvimento web, mobile ou no lado do servidor.

Como o browser interpreta seu código
Vimos que a linguagem Javascript pode ter diferentes hospedeiros e que neste treinamento usaremos o seu navegador que não necessita maiores configurações. Ainda sem entrar nos detalhes da linguagem, se quisermos exibir na tela uma alert com o texto "bem-vindo" podemos usar o seguinte script:

alert("bem-vindo");
E agora? Onde adicionar esse código em nossa página? Que tal adicionarmos dentro da tag <body> da página introducao.html que criamos? Veremos o que acontece quando colocamos um código Javascript dentro de uma pagina html normalmente:

<!-- introducao.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      alert("bem-vindo");
    </body>
</html>
Quando visualizamos a página (basta dar dois cliques sobre o arquivo), vemos que nosso script é exibido como texto, isto é, o navegador não fez nenhum tratamento especial para interpretar aquele código como um script:

código não interpretado pelo navegador

Faz todo sentido, já que criamos uma página HTML que está preparada para exibir conteúdo em forma de texto.

A tag SCRIPT
Precisamos dar uma pista para que o navegador deixe de olhar aquele trecho de código como HTML e comece a vê-lo como um script que deve ser interpretado. Para isso, usamos a tag <script>:

<!-- introducao.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
    <script>
            alert("bem-vindo");
       </script>
    </body>
</html>
Código interpretado pelo navegador

Agora sim! Quando a página é recarregada no navegador (você pode recarregá-la pressionando F5 ou CTRL + R) nosso trecho de script é interpretado como um código e não como conteúdo qualquer da página e o alerta é exibido.

A tag <script> pode ser tanto adicionada dentro da tag <head> ou logo antes do fechamento da tag <body>. Neste treinamento trabalharemos sempre com a tag <script> como ultimo elemento da tag <body>.

Para testar a tag <script>, você também pode usar o comando prompt, que irá exibir uma janela pedindo que você digite um texto qualquer:

<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      <script>
        prompt();
      </script>
    </body>
</html>
Note que nessa janela está escrito undefined em cima do campo, isso acontece pois você não informou qual texto deve aparecer. Para informá-lo, basta passá-lo dentro do parênteses.

No exemplo abaixo, o texto que aparecerá será "Digite seu nome":

<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      <script>
        prompt("Digite seu nome");
      </script>
    </body>
</html>
Legal! Mas de que adianta você digitar seu nome se essa informação é perdida logo em seguida, certo? Nós podemos, a fim de evitar esta perda, armazenar o que o usuário digitar em uma variável(não se preocupe com a sintaxe por enquanto, no próximo capítulo iremos entender variáveis bem mais profundamente):

<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      <script>
        var nome = prompt("Digite seu nome");
      </script>
    </body>
</html>
Agora você pode, inclusive, mostrar o seu nome em um alert:

<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      <script>
        var nome = prompt("Digite seu nome");
        alert(nome);   
      </script>
    </body>
</html>
HTML 5 e a tag <SCRIPT>
Um ponto importante aqui é que você pode já ter visto a declaração da tag <script> utilizando o atributo type:

<script type="text/Javascript">
</script>
Quando utilizando o padrão HTML5, não somos obrigados a adicionar o atributo type. Para isso, precisamos dizer ao navegador que estamos utilizando HTML5, o que pode ser feito utilizando-se a tag abaixo no inicio do seu html:

<!DOCTYPE html>
Apesar do Javascript ser um mundo diferente do HTML, com esta declaração precisamos digitar menos em nossa tag script, algo que é muito bem-vindo, não?

Interagindo com o console
Quando programando em Javascript, nós podemos utilizar o comando alert citado anteriormente para mostrar coisas na tela. Se quisermos mostrar duas informações ao mesmo tempo, podemos utilizar dois alerts:

<script>
alert("primeiro");
alert("segundo");
</script>
Porém, ao rodar esse código você perceberá que o segundo alert só aparece após termos fechado o primeiro, o que o torna pouco prático. Além disso, o alert é um comando que existe apenas no navegador, ou seja, não funcionará caso usado em outras plataformas como o Node.js, por exemplo.

Por esse motivo, o substituiremos pelo comando: console.log

<script>
console.log("bem-vindo");
</script>
No lugar de exibir uma janela na tela, a instrução console.log imprime no console do navegador(ou do servidor caso tivéssemos rodando nosso código nele). O problema é que se recarregarmos a página nada é exibido! Como assim?

Não se preocupe, o texto foi mostrado no console, nós só precisamos abrí-lo! Para isso o atalho no Windows e Linux: CONTROL + SHIFT + J ou no MAC OS CMD + OPT + J). Para escondê-lo, basta executar a mesma tecla de atalho novamente:

Exibindo console

Script como arquivo externo
Agora que você já entendeu que para o navegador interpretar seu script ele precisa estar envolvido pela tag <script> e que para visualizar a saída no console precisa abrí-lo. Está na hora de organizarmos melhor o nosso código.

Até agora estamos escrevendo html e Javascript no mesmo arquivo, o que pode se tornar confuso rapidamente. Para evitarmos isso, podemos escrevê-los em arquivos separados!

Podemos, por exemplo, criar o arquivo intro.js na mesma pasta do arquivo introducao.html. A diferença é que moveremos nosso código que exibe a mensagem no console para dentro deste arquivo:

// intro.js
console.log("bem-vindo");
Note que, dentro do nosso arquivo .js, nós teremos apenas código Javascript, nada de tags html como o <script> aqui!

A nossa tag <script> continuará na nossa pagina introducao.html. Porém, agora não terá nenhum conteúdo, em vez disso apontará para o arquivo Javascript que criamos através do atributo src:

<script src="intro.js"></script>
O resultado da página deve continuar o mesmo.

Identificando problemas
Somos seres humanos e pode acontecer de esquecermos de importar o script, digitarmos a tag errada ou até mesmo apontarmos para um arquivo que não exista. Você não quer ficar horas olhando para seu arquivo script procurando por um erro se sequer ele foi carregado, não é mesmo?

É por isso que é uma boa prática verificar se o arquivo importado através da tag script foi carregado! Fazemos isso também com o console aberto, mas no lugar de selecionarmos a aba "console", selecionamos a aba "rede" (ou "network", caso seu navegador esteja em inglês). Não esqueça de recarregar sua página toda vez que mudar para esta aba.

A aba "rede" exibe uma lista de todos os arquivos externos carregado, logo, se tudo correu bem com nosso arquivo intro.js ele deve aparecer na lista. Se estiver vermelho, significa que o arquivo não existe ou está em outro diretório:

Exibindo recursos carregados

Uma grande vantagem de termos nosso código em um arquivo separado é que, caso ele tenha algum erro, é possível acessar diretamente a linha problemática no próprio navegador, algo que não somos capazes quando adicionamos diretamente nosso código na página. Vejamos um exemplo alterando nosso intro.js:

// intro.js
console.log("bem-vindo");
console.log("bem-vindo);
No código anterior, adicionamos mais uma saída para o console, mas com problema. Conseguiu descobrir onde? O texto não termina com aspas simples, algo considerado um erro pelo Javascript.

Ao abrir sua página mais uma vez uma mensagem de erro será exibida no console e no canto direito aparece um link para o arquivo intro.js que indica a linha do erro, inclusive você pode clicar no link que ele exibirá o código para você:

Console exibindo mensagem de erro

Exibindo a linha do erro

Existem outras vantagens de deixarmos o nosso código num arquivo separado, a que vimos é uma delas e as outras serão apresentadas ao longo do treinamento.

Agora que você já sabe como as coisas se encaixam, inclusive como encontrar a causa de problemas em seu código mesmo antes de aprender a linguagem, podemos continuar nossa caminhada, pois o "kit de sobrevivência" já lhe foi dado.

No próximo capítulo veremos como o Javascript lida com variáveis, algo indispensável numa linguagem de programação, mas esteja atento:

Você escreverá seu código em arquivos separados, ajudando na depuração do seu código.
Você precisará associar o arquivo à página através da tag script.
A saída da sua aplicação utilizará o console, reforçando ainda mais seu uso.
Erros em seu código podem ser encontrados como mensagem do console em vermelho, inclusive você pode clicar no link do canto direito da tela que o levará diretamente para a linha com problema.
O projeto do curso
Ao fim de nosso curso, teremos uma aplicação de agenda de pacientes, com funcionalidade para calcular o IMC de cada um deles a partir de um botão e adicionar novos pacientes.

O resultado será parecido com o seguinte:



Então vamos lá! Mãos à obra e boa sorte!

Segue uma vez o código da página introducao.html e intro.js:

<!-- introducao.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Introdução</title>
    </head>
    <body>
      <h1>Bem-vindo</h1>
      <script src="intro.js"></script>
    </body>
</html>

// intro.js
console.log("bem-vindo");
console.log("bem-vindo");

O Javascript é uma das linguagens mais importantes de nosso tempo porque:

é uma linguagem que, além de ser a padrão nos navegadores atuais, vem expandindo para outras áreas como servidores como o Node.js
Javascript é a linguagem da web, a única entendida pelo navegador sem a necessidade de instalação de plugins ou algo do tipo. Inclusive hoje atua no lado do servidor devido ao sucesso do Node.js.

O nome Javascript é muito difundido, mas na verdade hoje os navegadores seguem um padrão. Que padrão é esse?

ECMA 262
O Javascript é o nome de uma implementação do padrão ECMA 262, isto é, quando dizemos que programamos em Javascript, na verdade programamos em ECMASCRIPT. Este padrão historicamente foi criado para resolver os problemas de compatibilidade da linguagem entre navegadores.

Para rodarmos nossos scripts precisamos de uma plataforma, que pode ser:

Para rodarmos nossos scripts precisamos de uma plataforma, que pode ser:

o navegador ou um servidor como Node.js
Tanto os navegadores do mercado quanto servidores como o Node.js são capazes de interpretar o padrão ECMA 262. Isso torna a linguagem ainda mais atrativa, porque possibilita criar soluções web completas utilizando apenas uma linguagem.
É claro que existem diferenças, já que no servidor não temos uma página para manipular, logo, não existe DOM (a estrutura da página html em memória) nem mesmo podemos exibir alertas com a alert porque não existe um navegador.

Ainda assim, podemos aplicar o conhecimento do core da linguagem nos dois ambientes.

Sabemos que o navegador entende apenas HTML e que se colocarmos scripts diretamente no corpo da mensagem ele será interpretado como texto. Como resolvemos isso?

Através da tag <script></script>. Tudo que estiver dentro dela será interpretado como script e não texto.
Este problema é resolvido utilizando-se a tag <script></script>, que pode vir tanto dentro da tag <head> quanto dentro da tag <body>. Tudo que estiver dentro da tag script será interpretado como Javascript e não como texto.

Vimos que é melhor criar nossos scripts em arquivos externos e importá-los em nossa página para facilitar a depuração de nosso código. Qual dos exemplos abaixo apresenta a configuração correta da tag script para tal finalidade?

<script src="meuscript.js"></script>
Um exemplo válido é <script src="meuteste.js"></script>. É através do atributo srcque indicamos o nome do arquivo com nossos scripts. É importante que a tag abra e feche, por exemplo, o seguinte exemplo é uma importação inválida:
<script src="meuteste.js">.

Complete o script abaixo que lê a idade do usuário, com a pergunta "Qual é a sua idade?", e exibe um alerta com a idade em seguida:
<script>
    var idade =  ######### 
    alert(#######);
</script>
Diga o que está na parte oculta (######), na ordem que aparece no código:

prompt("Qual é a sua idade?"); e idade

Quando queremos ler uma informação que o usuário digita, devemos utilizar o comando prompt(). Como queremos que apareça uma pergunta também, devemos utilizar o comando prompt() com o texto entre aspas dentro do parênteses, desta forma:
var idade = prompt("Qual é a sua idade?");

Como salvamos a informação digitada pelo usuário na variável idade, para exibi-la devemos usar o alert somente com o nome da variável, sem aspas, desta forma:

alert(idade);

O script completo ficará assim:

<script>
    var idade = prompt("Qual é a sua idade?");
    alert(idade);
</script>

mos a importância do console, aliás, como o exibimos mesmo?

No Windows e Linux: CONTROL + SHIFT + J No MAC: CMD + OPT + J
Mesmo antes de você aprender a programar em Javascript já vimos a importância de consultarmos o console. Ele é um "oráculo" que tudo sabe do seu código Javascript. Se algo der errado, não só ele exibe a mensagem de erro, mas também indica a linha problemática. O atalho para acessá-lo é : CONTROL + SHIFT + J, no Windows e Linux ou no CMD + OPT + J, no Mac OS.
Existe a tecla de atalho F12, mas que pode não focar diretamente na aba do console, por isso o atalho que vimos é mais recomendado.

############### 2. Variáveis e comandos básicos ###############

Variáveis e comandos básicos
Agora que você já tem ideia de o que é o Javascript, por que devemos usá-lo e do ambiente que usaremos nesse curso, está na hora de começarmos a colocar a mão na massa!

Declarando variáveis
Para começar, vamos entender como funcionam variáveis no Javascript, lembre-se sempre de utilizar o console para executar nossos comandos.

No Javascript, tudo que precisamos para criar uma variável é digitar a palavra var seguida do nome de sua variável e atribuir um valor à ela. Sendo assim, podemos criar uma variável chamada idade simplesmente digitando:

var idade = 19;
Assim que o interpretador de Javascript passar por essa linha, ele criará uma variável com o nome "idade" e atribuirá a ela o valor 19. Do mesmo jeito que você consegue declarar uma variável e atribuir a ela um número inteiro, você consegue atribuir um número decimal:

var peso = 57.5;
O mesmo você consegue fazer com textos (ou strings), basta atribuir algo que esteja entre aspas duplas:

var nome = "Leonardo";
Entendendo a tipagem dinâmica do Javascript
Note que nós não dissemos o tipo dessa variável em nenhum momento, quem vai definir o tipo será o interpretador, dependendo do valor que você estiver atribuindo à variável.

Você pode verificar o tipo de uma variável utilizando o comando typeof, veja o exemplo abaixo:

var idade = 19;
console.log(typeof idade); // Vai imprimir number
No caso da nossa variável peso, o valor que atribuímos foi um número decimal, mas para o Javascript não tem diferença de tipos, perceba que ao utilizarmos o comando typeof a saída também será number:

var peso = 57.5;
console.log(typeof peso); // Vai imprimir number
Se criássemos uma variável nome e atribuíssemos um texto, como abaixo, o tipo da variável seria string, como você pode conferir abaixo:

var nome = "Leonardo";
console.log(typeof nome); // Vai imprimir string
Isso acontece pois o Javascript possui um sistema de tipagem que chamamos de tipagem implícita - ou seja, não dizemos explicitamente o tipo de uma variável - e dinâmica, o que quer dizer que, se mudarmos o valor dessa variável, o tipo dela também mudará.

Por exemplo, se atribuirmos o valor 10 à variável nome que criamos acima, o tipo da variável passará a ser Number:

var nome = "Leonardo";
console.log(typeof nome); // imprime "string"

nome = 10;
console.log(typeof nome); // imprime number
Caso você crie uma variável com o valor true ou false, o tipo dela será boolean;

var ehEstagiario = true;
console.log(typeof ehEstagiario); // imprime "boolean"
Nós também podemos gerar variáveis com valores booleanos(verdadeiro ou falso) a partir de operadores de comparação.

Por exemplo, podemos criar uma variável chamada ehIgual que será verdadeira ou falsa de acordo com uma comparação de igualdade, que é feita utilizando o operador ==

var ehIgual = (2 == 2);

console.log(ehIgual); //imprime true

//-----------

var ehIgual = (2 == 3);

console.log(ehIgual); //imprime false
Ou uma variável chamada ehDiferente, que será verdadeira se dois valores forem diferentes. Para comparar se os valores são diferentes utilizaremos o operador !=:

var ehDiferente = (2 != 1);

console.log(ehDiferente); //imprime true;

//-----------

var ehDiferente = (2 != 2);

console.log(ehDiferente); //imprime false;
Além das comparações de igualdade e diferença, podemos também comparar se um valor é maior que outro

5 > 4 // true
5 > 10 // false
Se é menor

4 < 5 // true 
4 < 0 // false
Se é maior ou igual

 5 >= 5 //true
 5 >= 0 //true
 5 >= 6 //false
E se é menor ou igual

4 <= 4 // true
4 <= 5 // true
4 <= 3 // false
Esses tipos: boolean, number e string são os três tipos básicos no Javascript. Além desses, ainda existem outros que serão abordados mais para frente neste curso.

Operações aritméticas básicas
Agora que já aprendemos como declarar uma variável e como funciona o sistema de tipagem dinâmica do Javascript, vamos fazer algumas contas simples com elas.

Para dividir um número por outro, por exemplo, basta utilizar operador de divisão, que é representado pelo caractere barra("/"), sendo assim, ao digitarmos 12/2 no console, temos o resultado 6. O mesmo funciona com outras operações básicas, como multiplicação(utiliza-se o operador *), soma(+) e subtração(-).

Deste modo, podemos colocar em prática uma fórmula de calculo de salário anual, por exemplo, onde o valor acumulado é igual a 13 vezes o valor mensal + um bonus de 10% sobre o salario mensal:

var salarioMensal = 1400;
var salarioAnual = 13*salarioMensal+salarioMensal*0.10;
console.log(salarioAnual); // imprime 18340;
Projeto para baixar
Baixe o projeto nessa URL: https://s3.amazonaws.com/caelum-online-public/javascript-linguagem/projeto.zip.

Abra a pasta no Sublime ou seu editor favorito. Também abra no browser para ver o HTML que já demos pronto pra você.

Calculo de IMC de um paciente
Imagine que temos uma variável contendo o peso de um paciente e outra contendo a altura, a partir destas duas variáveis, é possível calcular o IMC(índice de massa corporal) deste paciente, que é resultado do peso dividido pela altura ao quadrado, ou peso/(altura*altura).

Vamos então calcular o IMC de um paciente que pesa 100 quilos e tem 2 metros de altura. Para isso, vamos declarar a variável peso e a variável altura:

var peso = 100;
var altura = 2.00;
Agora basta utilizar a formula de calculo de IMC:

var peso = 100;
var altura = 2.00;

var imc = peso / altura * altura;

console.log(imc); // imprime 100
Mas espere, o resultado da conta deveria ser 25, mas foi 100!

Isso aconteceu pois as operações aritméticas são executada pelo interpretador de Javascript da esquerda para a direita. Portanto, a conta que foi de fato efetuada foi:

peso / altura = 50
50 * altura = 100
Então, para nossa formula funcionar, precisamos dizer que a operação altura*altura(altura ao quadrado) deve ser executada primeiro! Para isso, basta envolver essa operação utilizando parênteses:

var peso = 100;
var altura = 2.00;

var imc = peso / (altura * altura);

console.log(imc) // 25
Agora sim, calculamos o IMC com sucesso!

Fluxo de dados com If/Else
Agora já conseguimos fazer contas básicas, mas o que aconteceria se o valor da variável altura fosse 0?

A conta seria:

100 / (0*0) -> 100 / 0
Estamos tentando dividir um numero por 0! Ao executar essa conta, teríamos a saída Infinity no console, indicando que o resultado dessa operação não é tangível, afinal é impossível dividir um número por 0!

Precisamos então executar a conta apenas se altura for diferente de 0. Para isso, envolveremos o nosso código no comando if, que tem como objetivo filtrar a execução de um determinado bloco de código com base em uma condição. Para usarmos o comando if, precisamos passar para ele um valor booleano, ou seja, uma condição, que decidirá se o código será executado ou não.

Nós só podemos executar a conta se a altura for diferente de 0, ou seja, quando altura != 0, então é essa condição que vamos passar para o if:

if(altura != 0){
    var imc = peso / (altura * altura);
    console.log(imc) // 25
}
Mas agora nós simplesmente paramos de efetuar a conta, seria legal mostrar uma mensagem para que soubéssemos o por quê de não termos executado a conta. Ou seja, quando a condição do if não for verdadeira, queremos mostrar uma mensagem. Para isso, podemos usar o comando else:

if(altura != 0){
    var imc = peso / (altura * altura);
    console.log(imc) // 25
}else{
    console.log("Não posso executar uma divisão por 0!");
}
Tratando vários casos com Ifs
Imagine que, na nossa fórmula de calculo de salário anual, o bônus varie de acordo com o salário mensal. Por exemplo:

se o salário mensal for maior que 0 e menor que 1000, o bonus é 5%

se não cair na condição anterior e o salário mensal for menor que 2000, o bonus é 10%

se não cair na condição anterior, o bonus é 15%

Mas antes de pensar em todas essas condições, vamos pensar só na primeira: se o salário for maior que 0 e menor que 1000, temos que usar 5% de bônus. Perceba que nós temos duas condições que precisamos respeitar: salarioMensal > 0 E salarioMensal < 1000, para isso vamos utilizar o operador &&, que fará com que o if só seja executado se as duas condições forem verdadeiras:

if(salarioMensal > 0 && salarioMensal < 1000){
    var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
    console.log(salarioAnual);
}
Além do operador and(&&) há também o operador or(representado por ||), que faz com que, se pelo menos uma das duas condições for verdadeira, o if seja executado!

Por exemplo, suponha que só queremos calcular o salarioAnual de um funcionário se o tipoDoFuncionario for "estagiário" OU "CLT", teríamos então um código parecido com o seguinte:

if(tipoDoFuncionario == "estagiário" || tipoDoFuncionario == "clt"){

    if(salarioMensal > 0 && salarioMensal < 1000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
        console.log(salarioAnual);
    } 

}
Legal, mas até agora só estamos respeitando a primeira condição para calcular o bônus do salário, vamos partir para a próxima: se não cair na condição anterior e o salário mensal for menor que 2000. Precisamos então só executar determinado código se o if anterior não for executado! Você se lembra do comando que faz isso? O else! Teríamos então o seguinte código:

if(tipoDoFuncionario == "estagiário" || tipoDoFuncionario == "clt"){

    if(salarioMensal > 0 && salarioMensal < 1000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
        console.log(salarioAnual);
    }else{
        var salarioAnual = 13*salarioMensal+salarioMensal*0.10;
        console.log(salarioAnual);
    }

}
Mas espere, o bonus só é 10% se não cair na condição anterior e se o salário mensal for menor que 2000! Vamos então colocar mais essa condição no nosso código:

if(tipoDoFuncionario == "estagiário" || tipoDoFuncionario == "clt"){

    if(salarioMensal > 0 && salarioMensal < 1000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
        console.log(salarioAnual);
    }else{
        if(salarioMensal < 2000){
            var salarioAnual = 13*salarioMensal+salarioMensal*0.10;
            console.log(salarioAnual);    
        }
    }

}
Agora estamos respeitando a condição, mas note que nós estamos encadeando muitos ifs, fazendo com que o nosso código cresça horizontalmente! Para evitar isso, temos o comando else if, que é exatamente o que parece: uma junção do else com um if, podemos então substituir o if encadeado no nosso código:

if(tipoDoFuncionario == "estagiário" || tipoDoFuncionario == "clt"){

    if(salarioMensal > 0 && salarioMensal < 1000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
        console.log(salarioAnual);
    }else if(salarioMensal < 2000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.10;
        console.log(salarioAnual);    
    }
}
Agora só falta a ultima parte de nossa lógica: se o ultimo if não for executado, o bonus é 15%. Para isso, basta adicionarmos um else ao fim de nosso ultimo if:

if(tipoDoFuncionario == "estagiário" || tipoDoFuncionario == "clt"){

    if(salarioMensal > 0 && salarioMensal < 1000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.05;
        console.log(salarioAnual);
    }else if(salarioMensal < 2000){
        var salarioAnual = 13*salarioMensal+salarioMensal*0.10;
        console.log(salarioAnual);    
    }else{
        var salarioAnual = 13*salarioMensal+salarioMensal*0.15;
        console.log(salarioAnual);    

    }
}

Em javascript podemos atribuir comparações a uma variável. No código abaixo, qual será a saída de cada console.log();?
var ehIgual = (2 == 3);
var ehDiferente = (2 != 3);

console.log(ehIgual);
console.log(ehDiferente);

false e true
A saída é false e true. O javascript realiza a comparação, verifica se ela é verdadeira ou falsa e então atribui o resultado a variável. No caso, 2 não é igual 3, a comparação é falsa, então o valor da variável ehIgual é false. Em ehDiferente, a comparação é verdadeira concorda? 2 realmente é diferente de 3, e por isso seu resultado é true.
E agora, qual o tipo dessas variáveis? boolean! Podemos conferir isso no console com:

typeof ehIgual;
typeof ehDiferente;

Ao se executar o seguinte código, o que é impresso no console? Você pode testar o código abaixo dentro da tag <script> no arquivo ifs-encadeados.html.
var nome = "Leonardo";
console.log(typeof nome);

nome = 10;
console.log(typeof nome); 

nome = "20";
console.log(typeof nome);

string number string

Lembre-se que typeof retorna o tipo da variável, ou seja
typeof "pessoa" retorna uma string.

Lembrando que as strings são sempre palavras com "aspas" em volta.

typeof 10 retorna number

Pois não tem as aspas em volta e é um número.

typeof "10" retorna uma string

Esse é o caso mais complicado, pois apesar de ser um número, está com as "aspas" em volta, ou seja, acaba por se tornar uma string.

Sabendo disso já deve ser possível responder a pergunta.

############### 3. Conhecendo o DOM e organizando nosso código com objetos ###############

Conhecendo o DOM e manipulando páginas
Até agora, nós apenas criamos variáveis e atribuímos sempre o mesmo valor a elas, por exemplo, o código var peso = 55.7 sempre criará uma variável com valor 55.7, mas qual a utilidade de uma variável se ela não variar, certo?

A ideia então é que agora nós comecemos a utilizar os valores da nossa página, ou seja, criar variáveis com base nos valores do nosso html, mas no mundo do Javascript, para pegar alguma informação de uma página, temos que, primeiro, entender o que é o tal do DOM.

O que é DOM e como usá-lo?
DOM é um acrônimo para Document Object Model, basicamente ele é uma representação de uma página html no mundo Javascript e pode ser acessado a partir da variável document, que representa a raiz de nossa página.

Utilizando esta variável, conseguimos, por exemplo, pegar o conteúdo de uma tag html. O que eu quero dizer com isso? Considere a seguinte página html:

<!DOCTYPE html>
<html lang="pt-br">
    <head>
      <meta charset="utf-8">
      <title>Javascript, a linguagem</title>
    </head>
    <body>
      <h1 id="titulo">Olá, mundo!</h1>
    </body>
</html>
Caso queiramos pegar o conteúdo da tag <h1> que possui o atributo id="titulo", podemos pedir ao document para selecionar um elemento que o id seja titulo:

var titulo = document.getElementById("titulo"); // Seleciona o titulo
É importante notar que, caso não exista nenhuma tag com o atributo id="titulo" em nossa página, o conteúdo da variável será undefined. Com o elemento em mãos, podemos pegar o conteúdo dele do seguinte modo:

var titulo = document.getElementById("titulo"); // Seleciona elemento
var conteudo = titulo.textContent; // Pega texto dentro do elemento
console.log(conteudo); // Imprime "Olá, mundo!"
Pronto! Agora já conseguimos pegar o conteúdo de uma tag html e colocar em uma variável, então agora vamos pensar na nossa aplicação do curso, a lista de pacientes.

O que queremos fazer é conseguir pegar a variável altura e peso de nosso primeiro paciente na nossa tabela, para isso vamos analisar a estrutura dela:

<table>
    <tr>
        <th>Nome</th>
        <th>Peso</th>
        <th>Altura</th>
        <th>IMC</th>
    </tr>
    <tr>
        <td id="nome-1">Leonardo</td>
        <td id="peso-1">50.0</td>
        <td id="altura-1">1.60</td>
        <td id="imc-1"></td>
    </tr>
    <tr>
        <td id="nome-2">Paulo</td>
        <td id="peso-2">100</td>
        <td id="altura-2">2.00</td>
        <td id="imc-2"></td>
    </tr>
</table>
Vamos montar um paciente com as informações do primeiro da tabela, ou seja, o "Leonardo". Para isso, basta utilizar o comando que acabamos de aprender, o document.getElementById("id-para-selecionar"):

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente
Modificando sua página
Agora que nós já conseguimos declarar variáveis com valores que estão em nossas páginas, podemos calcular o IMC a partir desses valores aplicando o nosso código original:

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente

if(altura != 0){
    var imc = peso / (altura * altura);
    console.log(imc) // 25
}else{
    console("Não posso executar uma divisão por 0!");
}
Bacana! Já calculamos o IMC, mas ainda temos uma coluna vazia na nossa tabela, precisamos preenchê-la com o valor calculado!

Para isso, vamos começar selecionando o <td> que queremos preencher:

var tdDoImc = document.getElementById("imc-1"); // pega o td do imc do paciente 1
Lembra que para pegarmos o conteúdo de uma tag nós utilizamos o textContent? Para modificar o seu conteúdo também usaremos ele, mas atribuindo um valor, como se fosse uma variável!

var tdDoImc = document.getElementById("imc-1"); // pega o td do imc do paciente 1
tdDoImc.textContent = imc; //Altera o conteúdo do td para o valor da variável imc
Prontinho! Então o nosso código final será parecido com o seguinte:

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente

if(altura != 0){
    var imc = peso / (altura * altura);

    var tdDoImc = document.getElementById("imc-1"); // pega o td do imc do paciente 1
    tdDoImc.textContent = imc; //Altera o conteúdo do td para o valor da variável imc

    console.log(imc) // 25
}else{
    console("Não posso executar uma divisão por 0!");
}
Agora você já sabe como selecionar elementos do DOM e modificá-los! Durante o curso você aprenderá mais modos de selecionar e mais propriedades que poderá alterar, fique ligado!

Organizando nosso código com objetos
Agora nós já conseguimos calcular o IMC de um paciente, mas para isso nós usamos duas variáveis separadas: a altura e o peso.

Seria legal se tivéssemos um modo de juntar essas duas variáveis para que ficasse claro que elas pertencem a um paciente. Para isso, vamos aprender como declaramos objetos em Javascript!

A notação de objetos do Javascript
Um objeto em Javascript, nada mais é que uma variável que possui, dentro dela, chaves e valores. O que queremos fazer é um objeto chamado paciente que terá as chaves (ou atributos) altura e peso.

Para criarmos esse objeto, utilizaremos os caracteres { para abrir o objeto e } para fechá-lo.

var paciente = {};
Simplesmente assim nós já criamos o nosso objeto paciente, porém, ele ainda não tem nenhum atributo. Nós podemos, então, dentro das chaves, adicionarmos o atributo peso com seu valor separado por dois pontos(:):

var paciente = { peso : 100 };
Agora nós temos, dentro de nosso objeto paciente, a propriedade peso, que pode ser acessada a qualquer momento utilizando a seguinte sintaxe:

paciente.peso
Repare que utilizamos um ponto(.) para dizermos ao interpretador de Javascript que queremos acessar um atributo desse objeto, essa notação é chamada de dot notation. Outra forma menos usada de acessar um atributo sería a partir de colchetes com o nome do atributo:

paciente["peso"];
Agora só falta adicionarmos o ultimo atributo, a altura. Para isso, basta adicioná-lo após o peso separado por uma vírgula:

var paciente = {peso : 100, altura : 2.00}
Pronto! Temos um paciente completo, com peso e altura! Mas ele terá sempre o mesmo valor de peso e de altura, seria legal se nós pegássemos essa informação da página, como fazíamos antes:

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente

var paciente = {
    peso : peso,
    altura : altura
}
Note que quebramos a linha para cada atributo por questões de legibilidade, essa é uma notação bem usada quando o objeto tem muitos atributos.

Mas ainda está faltando um atributo no nosso paciente: o nome. Agora o paciente já está criado, mas conseguimos adicionar novos atributos mesmo assim utilizando o dot notation e atribuindo um valor a ele:

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente

var paciente = {
        nome:nome, //Para poder chamar no comando abaixo
    peso : peso,
    altura : altura
}

paciente.nome = document.getElementById("nome-1").textContent; // pega nome do paciente
Agora que organizamos mais o nosso código juntando as informações do paciente, vamos ver como ficaria o nosso cálculo de IMC utilizando esse novo objeto:

var peso = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura = document.getElementById("altura-1").textContent; // pega a altura do paciente
var nome = document.getElementById("nome-1").textContent; // pega o nome do paciente

var paciente = {
    peso : peso,
    altura : altura,
    nome : nome
}

if(paciente.altura != 0){
    var imc = paciente.peso / (paciente.altura * paciente.altura);

    var tdDoImc = document.getElementById("imc-1"); // pega o td do imc do paciente 1
    tdDoImc.textContent = imc; //Altera o conteúdo do td para o valor da variável imc

    console.log(imc);
}else{
    console("Não posso executar uma divisão por 0!");
}
Para saber mais
Repare que os objetos em Javascript são um pouco diferentes do que você pode estar acostumado em outras linguagens orientadas a objetos como o Java. Quando estamos utilizando Javascript, nós não precisamos declarar uma classe para, a partir desta, instanciar um objeto, basta criar um objeto diretamente.

Quais das frases abaixo define corretamente o DOM?

DOM é a representação de uma página HTML em Javascript e pode ser acessado através da variável document, que representa a raiz de nossa página.
DOM é a representação de uma página HTML e pode ser acessado através da variável document que representa a raiz de nossa página.
Podemos buscar um elemento a partir do document usando a função getElementById.

Por exemplo, tendo um elemento HTML com a id titulo:

<h1 id="titulo">Aprendendo DOM</h1>
Podemos buscar esse elemento usando:

var titulo = document.getElementById("titulo");

Dado um HTML:
<h1 id="titulo">Bom dia</h1>
e buscando o elemento pelo DOM:

var titulo = document.getElementById("titulo");
Como podemos acessar o texto do elemento a partir da variável titulo?

titulo.textContent
Devemos usar a propriedade (property) textContent:
var titulo = document.getElementById("titulo");
titulo.textContent
Através dela também podemos atribuir um novo texto ao elemento HTML:

titulo.textContent = "Boa tarde";

Qual das notações abaixo é a correta ao se declarar um objeto em Javascript?

var paciente = { peso : 100, altura : 2.00 };
A notação correta é:
var paciente = { peso : 100, altura : 2.00 };
Dentro do nosso objeto, nós temos as chaves ligadas aos valores que elas representam (No exemplo, peso e altura são chaves e 100, 2.00 são os respectivos valores). Lembrando também que podemos marcar nossas chaves do objeto com aspas, ficando mais fácil a leitura do código:

var paciente = {
    "peso" : 100, 
    "altura" : 2.00        
};

Vimos na aula como criar um objeto JavaScript, por exemplo o nosso paciente:
var paciente = { peso : 100, altura : 2.00 };
Como podemos acessar a altura desse paciente?

paciente.altura
Podemos usar a Dot Notation, ou seja usando o ponto:
paciente.altura;
Alternativamente podemos usar a Bracket Notation:

paciente["altura"];

############### 4. Coleções e loops ###############

Coleções de dados com Arrays
A nossa aplicação possui uma lista de pacientes, e agora já estamos calculando o IMC de um paciente!

Imagine então que eu quero ter a altura de todos os meus pacientes na minha aplicação, se eu tivesse 3 pacientes eu teria três variáveis:

var altura1 = 1.57;
var altura2 = 2.00;
var altura3 = 1.64;
Note que, para cada paciente, teríamos uma nova variável. Porém, nós gostaríamos de organizar melhor esse código e não precisar criar uma variável para cada altura.

Para isso, poderíamos criar uma coleção de alturas, também chamado de Array. Em Javascript, podemos criar um Array simplesmente criando uma variável e atribuindo a ela o valor []:

var alturas = [];
Deste modo, estamos criando um Array vazio, caso queiramos adicionar um elemento ao array basta colocá-lo dentro dos colchetes:

var alturas = [1.57, 2.00, 1.64];
Mas como vamos acessar essas alturas agora que elas estão todas em uma mesma variável? Para acessarmos valores dentro de um Array, temos que dizer, entre colchetes, qual a posição do Array que queremos acessar. Note que o primeiro elemento, está na posição 0:

var alturas = [1.57, 2.00, 1.64];

var primeiraAltura = alturas[0];

console.log(primeiraAltura); // 1.57
Então, caso queiramos pegar o segundo elemento do Array, utilizaríamos a posição(ou índice) 1, se quisermos o terceiro, utilizaríamos 2 e assim por diante:

var alturas = [1.57, 2.00, 1.64];

console.log(alturas[0]); // 1.57
console.log(alturas[1]); // 2.00
console.log(alturas[2]); // 1.64
Legal, agora organizamos melhor as alturas dos nossos pacientes, mas seria melhor se utilizássemos o que aprendemos sobre objetos, para colocarmos pacientes inteiros dentro de nosso Array, e não só alturas.

Para isso, criaremos dois pacientes, como já fazíamos anteriormente, e criaremos um Array chamado pacientes contendo estes objetos.


var peso1 = document.getElementById("peso-1").textContent; // pega o peso do paciente
var altura1 = document.getElementById("altura-1").textContent; // pega a altura do paciente
var nome1 = document.getElementById("nome-1").textContent; // pega nome do paciente

var leonardo = {
    peso : peso1, 
    altura : altura1,
    nome : nome1
}

var peso2 = document.getElementById("peso-2").textContent; // pega o peso do paciente
var altura2 = document.getElementById("altura-2").textContent; // pega a altura do paciente
var nome2 = document.getElementById("nome-2").textContent; // pega nome do paciente

var paulo = {
    peso : peso2, 
    altura : altura2,
    nome : nome2
}

var pacientes = [leonardo, paulo];
Para acessar o leonardo, basta acessar a posição 0 do Array, mas note que agora ele irá retornar um objeto:

//monta pacientes

var pacientes = [leonardo, paulo];

console.log(pacientes[0]) // imprime {altura : (altura do seu primeiro paciente), peso : (peso do primeiro seu paciente), nome: (nome do primeiro seu paciente)}
Para acessarmos a altura desse paciente, basta utilizarmos a dot notation, como vimos anteriormente:

//monta pacientes

var pacientes = [leonardo, paulo];

var primeiroPaciente = pacientes[0];
console.log(primeiroPaciente.altura); // imprime altura do primeiro paciente

//pacientes[0].altura; tería o mesmo resutado.
Agora nosso código já está bem mais organizado!

Percorrendo arrays utilizando os comandos while e for
Agora nós temos uma coleção de pacientes, mas e se quisermos calcular o IMC de cada paciente? Precisaríamos calcular individualmente para cada item de nosso Array, copiando o código que calcula o IMC para cada um deles:

//monta pacientes

var pacientes = [leonardo, paulo];

var primeiroPaciente = pacientes[0];

if(primeiroPaciente.altura != 0){
    var imcDoPrimeiroPaciente = primeiroPaciente.peso / (primeiroPaciente.altura * primeiroPaciente.altura);
    console.log(imcDoPrimeiroPaciente) // 22.31...
}else{
    console.log("Não posso executar uma divisão por 0!");
}


var segundoPaciente = pacientes[1];

if(segundoPaciente.altura != 0){
    var imcDosegundoPaciente = segundoPaciente.peso / (segundoPaciente.altura * segundoPaciente.altura);
    console.log(imcDosegundoPaciente) // 25
}else{
    console.log("Não posso executar uma divisão por 0!");
}
Com dois pacientes ainda não é tão ruim, mas imagina se tivéssemos 100 deles? Teríamos de copiar esse código 100 vezes, um para cada paciente!

O que queremos fazer é executar um mesmo código para cada uma das posições de nosso Array, seria legal se pudéssemos fazer isso de forma automática, de algum modo, com que um bloco de código seja executado várias vezes. Ou seja, um Loop! Algo como o seguinte:

enquanto(naoEhOUltimoElementoDoArray){

    if(pacienteAtual.altura != 0){
        var imcDoPacienteAtual = pacienteAtual.peso / (pacienteAtual.altura * pacienteAtual.altura);
        console.log(imcDoPacienteAtual)
    }else{
        console.log("Não posso executar uma divisão por 0!");
    }

}
Para fazermos nosso código ser executado para cada item do Array, utilizaremos o comando while. Para utilizá-lo, precisamos dar uma condição que será usada para, enquanto for verdadeira, executar o bloco de código. A condição que queremos é: se a posição atual não é a última do array, continua executando o loop. Para verificarmos se a posição atual é a última ou não, precisamos descobrir o tamanho do array, o que pode ser feito acessando o atributo length do array:

//monta pacientes

var pacientes = [leonardo, paulo];

console.log(pacientes.length); // imprime 2
Lembre-se de que as posições do Array começam de 0, portanto, a última posição é o tamanho do array menos um (pacientes.length - 1). Sendo assim, a condição que precisamos é posicaoAtual <= pacientes.length - 1, e é essa condição que usaremos em nosso comando while:

var posicaoAtual = 0;
while(posicaoAtual <= pacientes.length - 1){

    var pacienteAtual = pacientes[posicaoAtual];
    if(pacienteAtual.altura != 0){
        var imcDoPacienteAtual = pacienteAtual.peso / (pacienteAtual.altura * pacienteAtual.altura);
        console.log(imcDoPacienteAtual);
    }else{
        console.log("Não posso executar uma divisão por 0!");
    }

}
Mas note que, deste modo, a posicaoAtual sempre valerá 0 e, portanto, a condição nunca será falsa! Entramos em um loop infinito! Para evitar esse problema, devemos somar 1 à posicaoAtual a cada loop:

var posicaoAtual = 0;
while(posicaoAtual <= pacientes.length - 1){
    //resto do código

    posicaoAtual = posicaoAtual + 1;

}
Incrementar 1 a uma variável é algo bem comum no Javascript, por isso já existe um atalho, que faz a mesma coisa. Podemos substituir a linha que soma 1 por posicaoAtual++, que terá o mesmo resultado!

O resultado será:

//monta pacientes

var pacientes = [leonardo, paulo];

var posicaoAtual = 0;
while(posicaoAtual <= pacientes.length - 1){

    var pacienteAtual = pacientes[posicaoAtual];
    if(pacienteAtual.altura != 0){
        var imcDoPacienteAtual = pacienteAtual.peso / (pacienteAtual.altura * pacienteAtual.altura);
        console.log(imcDoPacienteAtual);
    }else{
        console.log("Não posso executar uma divisão por 0!");
    }

    posicaoAtual++;
}
Repare que, agora, não importa quantos pacientes tivermos, iremos imprimir o IMC de todos eles apenas utilizando esse código! Porém, temos alguns códigos que iriam se repetir em qualquer loop que quisermos construir:

a declaração da variável posicaoAtual (também conhecida como variável de controle)
a condição do loop
o incremento ao fim do loop.
Se não quisermos gastar 3 linhas no nosso código, uma para cada item, podemos utilizar o comando for, em vez do while. A diferença do comando for é que ele recebe três argumentos separados por ponto-e-vírgula:

for("declaracao" ; "condicao" ; "incremento"){
    //bloco de código
}
Portanto, podemos substituir o while que construímos anteriormente por:

//monta pacientes

var pacientes = [leonardo, paulo];

for(var posicaoAtual = 0; posicaoAtual <= pacientes.length - 1; posicaoAtual++){

    var pacienteAtual = pacientes[posicaoAtual];
    if(pacienteAtual.altura != 0){
        var imcDoPacienteAtual = pacienteAtual.peso / (pacienteAtual.altura * pacienteAtual.altura);
        console.log(imcDoPacienteAtual) // 25
    }else{
        console.log("Não posso executar uma divisão por 0!");
    }

}
Bacana, já estamos mostrando os IMCs de todos os pacientes do Array! Mas essa coleção sempre terá dois elementos, pois estamos montando apenas dois pacientes e colocando dentro dele, o que não é muito útil, pois poderíamos ter mais pacientes em nossa tabela!

O que queremos agora é montar o nosso Array a partir dos dados da nossa tabela, para isso, vamos analisá-la:

<table>
    <tr>
        <th>Nome</th>
        <th>Peso</th>
        <th>Altura</th>
        <th>IMC</th>
    </tr>
    <tr>
        <td id="nome-1">Leonardo</td>
        <td id="peso-1">50.0</td>
        <td id="altura-1">1.60</td>
        <td id="imc-1"></td>
    </tr>
    <tr>
        <td id="nome-2">Paulo</td>
        <td id="peso-2">100</td>
        <td id="altura-2">2.00</td>
        <td id="imc-2"></td>
    </tr>
</table>
Note que cada paciente é representado por uma tag <tr>, o que poderíamos selecionar utilizando a função document.getElementsByTagName do seguinte modo:

var nossosTrs = document.getElementsByTagName("tr");
Isso nos devolveria um Array de objetos que representam nossas tags <tr>, mas espere! O primeiro <tr> de nossa tabela não é um paciente!

Para pegarmos somente os pacientes, poderíamos adicionar um atributo class para diferenciá-los:

<table>
    <tr>
        <th>Nome</th>
        <th>Peso</th>
        <th>Altura</th>
        <th>IMC</th>
    </tr>
    <tr class="paciente">
        <td id="nome-1">Leonardo</td>
        <td id="peso-1">50.0</td>
        <td id="altura-1">1.60</td>
        <td id="imc-1"></td>
    </tr>
    <tr class="paciente">
        <td id="nome-2">Paulo</td>
        <td id="peso-2">100</td>
        <td id="altura-2">2.00</td>
        <td id="imc-2"></td>
    </tr>
</table>
Note que nós não usamos id pois ele deve ser único na página, diferente de class.

Agora, para selecionar apenas o elementos que possuem class="paciente", podemos usar a função document.getElementsByClassName:

var nossosTrs = document.getElementsByClassName("paciente");
Bacana, agora precisamos montar nossos pacientes a partir desses <tr>, para isso precisamos percorrê-los utilizando o comando for que vimos anteriormente:

var nossosTrs = document.getElementsByClassName("paciente");

for(var posicaoDoTrAtual = 0; posicaoDoTrAtual <= nossosTrs.length - 1; posicaoDoTrAtual++){

    var trAtual = nossosTrs[posicaoDoTrAtual];

    //monta e adiciona paciente no array 'pacientes'     

}
Agora só precisamos montar os pacientes a partir do trAtual, ou seja, pegar as informações(<td>) de dentro do trAtual e criar um objeto a partir delas!

Para pegar um <td> dentro do trAtual, podemos chamar a função getElementsByTagName não em document como antes, mas no trAtual, que é o elemento que queremos usar como raíz:

var nossosTrs = document.getElementsByClassName("paciente");

for(var posicaoDoTrAtual = 0; posicaoDoTrAtual <= nossosTrs.length - 1; posicaoDoTrAtual++){
    var trAtual = nossosTrs[posicaoDoTrAtual];
    var informacoes = trAtual.getElementsByTagName("td"); // pega todos os tds dentro do tr
}
Mas repare que apesar de termos pego todos os <td> dentro do trAtual, nós não temos ideia de qual é o peso, qual é o nome, etc.

Precisamos dar um jeito de buscar especificamente o <td> que precisamos, vamos então dar classes a eles:

<table>
    <tr>
        <th>Nome</th>
        <th>Peso</th>
        <th>Altura</th>
        <th>IMC</th>
    </tr>
    <tr class="paciente">
        <td class="info-nome">Leonardo</td>
        <td class="info-peso">50.0</td>
        <td class="info-altura">1.60</td>
        <td class="info-imc"></td>
    </tr>
    <tr class="paciente">
        <td class="info-nome">Paulo</td>
        <td class="info-peso">100</td>
        <td class="info-altura">2.00</td>
        <td class="info-imc"></td>
    </tr>
</table>
Agora podemos pegar o <td> com class="info-nome" facilmente utilizando o trAtual.getElementsByClassName("info-nome"). Mas lembre que o getElementsByClassName sempre retorna um Array, pois pode existir mais de um elemento com a mesma class, portanto pegaremos a primeira posição desse Array:

var nossosTrs = document.getElementsByClassName("paciente");

for(var posicaoDoTrAtual = 0; posicaoDoTrAtual <= nossosTrs.length - 1; posicaoDoTrAtual++){
    var trAtual = nossosTrs[posicaoDoTrAtual];
    var nomeTd = trAtual.getElementsByClassName("info-nome")[0]; // pega td do nome do paciente atual
    var pesoTd = trAtual.getElementsByClassName("info-peso")[0]; // pega td do peso do paciente atual
    var alturaTd = trAtual.getElementsByClassName("info-altura")[0]; // pega td da altura do paciente atual
}
Agora podemos criar nosso objeto paciente:


var nossosTrs = document.getElementsByClassName("paciente");

for(var posicaoDoTrAtual = 0; posicaoDoTrAtual <= nossosTrs.length - 1; posicaoDoTrAtual++){
    var trAtual = nossosTrs[posicaoDoTrAtual];
    var nomeTd = trAtual.getElementsByClassName("info-nome")[0]; // pega td do nome do paciente atual
    var pesoTd = trAtual.getElementsByClassName("info-peso")[0]; // pega td do peso do paciente atual
    var alturaTd = trAtual.getElementsByClassName("info-altura")[0]; // pega td do altura do paciente atual

    var paciente = {
        nome : nomeTd.textContent,
        peso : pesoTd.textContent,
        altura : alturaTd.textContent
    }


}
Pronto! Agora nossos pacientes serão gerados dinamicamente para cada <tr> na página! Basta agora pegar o IMC do paciente que montamos e modificar o <td> de IMC do <tr> atual:

var nossosTrs = document.getElementsByClassName("paciente");

for(var posicaoDoTrAtual = 0; posicaoDoTrAtual <= nossosTrs.length - 1; posicaoDoTrAtual++){
    var trAtual = nossosTrs[posicaoDoTrAtual];
    var nomeTd = trAtual.getElementsByClassName("info-nome")[0]; // pega td do nome do paciente atual
    var pesoTd = trAtual.getElementsByClassName("info-peso")[0]; // pega td do peso do paciente atual
    var alturaTd = trAtual.getElementsByClassName("info-altura")[0]; // pega td do altura do paciente atual
    var imcTd = trAtual.getElementsByClassName("info-imc")[0]; // pega td do imc do paciente atual

    var paciente = {
        nome : nomeTd.textContent,
        peso : pesoTd.textContent,
        altura : alturaTd.textContent
    }

    if(paciente.altura != 0){
        var imcDoPaciente = paciente.peso / (paciente.altura * paciente.altura);

        imcTd.textContent = imcDoPaciente;

        console.log(imcDoPaciente); // 25
    }else{
        console.log("Não posso executar uma divisão por 0!");
    }

}

Qual das alternativas abaixo é o modo correto de criar um Array?

var numeros = [1, 2, 3];
Usamos colchetes e cada elemento fica separado com uma vírgula:
var numeros = [1, 2, 3];
Para saber o tamanho de um array:

console.log(numeros.length); //imprime 3
E podemos acessar um elemento do array através do seu índice, que sempre começa com 0:

console.log(numeros[0]); //imprime 1
console.log(numeros[2]); //imprime 3

Um laço com for possui 3 partes:
Um comando que é executado a cada iteração
Uma inicialização que é executada antes da primeira iteração
Uma condição que é testada no inicio de cada iteração
Qual é a ordem correta desses comandos?

for (inicialização; condição; iteração)
A ordem correta é: for (inicialização; condição; iteração)
Por exemplo:

var numeros = [1,2,3,4];

for(var i = 0; i < numeros.length; i++) {
    console.log(numeros[i]);
}
Bom, essa pergunta foi fácil, vamos continuar?

Um programador Javascript estava desenvolvendo um site para uma barraquinha de frutas. Em um determinado pedaço do seu código, ele queria exibir no console o nome de cada fruta do seu array de frutas, porém no console a única fruta que aparecia era banana.
Conserte o código dele para que ele consiga imprimir todas as frutas corretamente no console:

var frutas = ["banana","maçã", "uva", "laranja", "pêssego", "limão", "melão", "melancia"];
var posicao = 0;

while( posicao <= frutas.length ){
    var frutaAtual = frutas[posicao];
    console.log(frutaAtual);
}

O código do nosso amigo programador contêm 2 falhas, uma grave e outra um pouco mais leve.
A falha grave é que ele entra em um loop infinito! Se você reparar, ele não altera o valor da posição após imprimir a frutaAtual, então por este motivo ele fica imprimindo "banana" repetidas vezes. Para consertar isto, basta adicionarmos um posicao++ após a impressão da fruta atual, ficando deste jeito:

var frutas = ["banana","maçã", "uva", "laranja", "pêssego", "limão", "melão", "melancia"];
var posicao = 0;

while( posicao <= frutas.length ){
    var frutaAtual = frutas[posicao];
    console.log(frutaAtual);
    posicao++;
}
Agora o código termina, porém ainda acontece algo esquisito... ele imprime um undefined depois de imprimir todas as frutas. Isto ocorre por que dentro do loop while, ele percorre até frutas.length , e como aprendemos neste capítulo, os arrays começam com 0, então apesar do nosso array frutas[...] ter 8 elementos, a sua última posição é a frutas[7].

Para resolver este pequeno bug, podemos adicionar um -1 dentro do nosso while, desta forma:

var frutas = ["banana","maçã", "uva", "laranja", "pêssego", "limão", "melão", "melancia"];
var posicao = 0;

// Alteração dentro do while!
while( posicao <= frutas.length - 1 ){
    var frutaAtual = frutas[posicao];
    console.log(frutaAtual);
    posicao++;
}
Pronto! Agora a barraca de frutas não está mais presa apenas a bananas!

############### 5. Funções e os cidadãos de primeira classe ###############

Funções e os cidadãos de primeira classe
Até agora nós conseguimos organizar uma coleção de objetos pacientes e calcular o IMC de cada um deles sem precisar copiar e colar o código, mas ainda temos alguns pontos a melhorar no nosso programinha.

A primeira coisa que poderíamos fazer é dar um nome para a nossa lógica que calcula IMC para que fosse mais fácil entender o que ela faz! Para isso usaremos um recurso do Javascript chamado Funções.

O que são funções?
Funções são estruturas que nos possibilitam isolar uma determinada lógica e dar um nome a ela, permitindo que a chamemos em vários pontos de nosso código! Elas ajudam muito organizar o nosso código e deixar ele mais legível. Vamos tentar?

No nosso caso, a lógica que queremos isolar é a de calculo de IMC. Dentro do arquivo calcula-imc.js encontramos essa lógica:

if(paciente.altura != 0){                        
    var imc = paciente.peso / (paciente.altura * paciente.altura);                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                         

}else{                        

    console("Não posso dividir por zero!");                        
}
Para declarar uma função, basta utilizarmos a palavra function seguido do nome da função e um corpo, que seria a lógica que desejamos isolar.Portanto, podemos criar uma função chamada calculaImc com esse corpo (bem no início do arquivo calcula-imc.js):

//arquivo calcula-imc.js                        

function calculaImc(){                        
    if(paciente.altura != 0){                    
        var imc = paciente.peso / (paciente.altura * paciente.altura);                    

        var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                     
        tdImc.textContent = imc;                    

        console.log(imc);                     

    }else{                    

        console("Não posso dividir por zero!");                    
    }                    
}
Observação: Existe também uma outra forma de se criar uma função, que é atribuindo-a a uma variável:

var calculaImc = function(){                        
    // corpo da função                    
}
Neste curso, ficaremos com a primeira opção.

Vamos invocar essa função onde estava a lógica que isolamos, isto é chamar a função dentro do for. Para isso basta digitar o nome da função que definimos seguido de ():

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var paciente = { nome : tdNome.textContent, peso : tdPeso.textContent, altura : tdAltura.textContent};                            

    calculaImc(); invoca a função que declaramos anteriormente                        

}
Mas note que, na nossa função, nós estamos calculando o imc usando uma variável paciente que não existe, ou seja, não é o pacienteAtual!

Para calcular o imc de um paciente diferente para cada chamada da função, precisamos dizer que nossa função recebe um parâmetro que é um paciente e usá-lo dentro da função:

function calculaImc(paciente){                        

    if(paciente.altura != 0){                        
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        

        var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
        tdImc.textContent = imc;                        

        console.log(imc);                         

    } else{                        

        console("Não posso dividir por zero!");                        
    }                        
}
Agora, quem definirá quem é esse paciente é o código que invoca essa função. No nosso caso, o paciente será o pacienteAtual, portanto,vamos passá-lo como argumento na chamada da função:

var trsPacientes = document.getElementsByClassName("paciente");                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    //renomeamos a variaval paciente para pacienteAtual                        
    var pacienteAtual = { nome : tdNome.textContent, peso : tdPeso.textContent, altura : tdAltura.textContent};                            

    calculaImc(pacienteAtual); //passando o pacienteAtual                        
}
Agora temos um código mais legível com o mesmo comportamento!

Mas note que a nossa função, além de estar calculando o imc(que é o que o nome dela diz), ela também está modificando a variável imcTd. Além de não existir dentro da função, estamos fazendo mais coisas do que deveríamos dentro dela! Boa prática é que uma função sabe fazer uma coisa bem!

O que queríamos era somente calcular o IMC, então nossa função seria somente a seguinte:

function calculaImc(paciente){                        

    if(paciente.altura != 0){                        
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        

          //sem alteração do tdImc e console.log                    

    } else{                        

        console("Não posso dividir por zero!");                        
    }                        
}
Mas dessa maneira, nós não estamos mais sendo informados de qual é o IMC de cada paciente!

Seria legal se continuássemos a imprimir o IMC dos pacientes e modificar o tdImc, mas fora da função! Para isso ser possível, precisamos dizer que nossa função irá retornar o IMC calculado:

function calculaImc(paciente){                        
    if(paciente.altura != 0){                    
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        
        return imc; //retornando imc                        
    } else{                        

        console("Não posso dividir por zero!");                        
    }                        
}
Deste modo, podemos atribuir o retorno dessa função a uma variável quando a invocarmos dentro do for:

  var imc = calculaImc(pacienteAtual)                        
  var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
  tdImc.textContent = imc;                        

  console.log(imc);
Então, todo nosso código para calcular o imc de nossos pacientes seria o seguinte (conteúdo completo do arquivo calcula-imc.js):

function calculaImc(paciente){                        

    if(paciente.altura != 0){                        
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        
        return imc;                        
    } else{                        

        console("Não posso dividir por zero!");                        
    }                        
}                        


var trsPacientes = document.getElementsByClassName("paciente");                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = { nome : tdNome.textContent, peso : tdPeso.textContent, altura : tdAltura.textContent};                            

    var imc = calculaImc(pacienteAtual);                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                         
}
Fim do video 5.1

Adicionando comportamentos a objetos
Perceba que a função que criamos, calculaImc, é uma função global. Ou seja, podemos chamar ela em qualquer lugar. Mas faz sentido ela ser? De quem ela calcula o IMC? Do paciente, certo?

Se ela calcula o IMC do paciente, seria legal se esse fosse um comportamento do próprio paciente, e isso é possível! Podemos adicionar esse comportamento ao paciente simplesmente adicionando ao objeto:

function calculaImc(paciente){                        

    if(paciente.altura != 0){                        
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        
        return imc;                        
    } else{                        
        console("Não posso dividir por zero!");                        
    }                        
}                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    //codigo omitido                    

    var pacienteAtual = {                     
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: calculaImc //atribuindo a função ao atributos pegaImc                        
    };                         

    //codigo omitido                        
}
Deste modo, para chamarmos a função do paciente, bastaria utilizarmos o nome que definimos no objeto:

var imc = pacienteAtual.pegaImc(pacienteAtual);                        
console.log(imc);
Mas esse código ainda está meio estranho: estamos chamando a função pegaImc do objeto pacienteAtual passando o mesmo pacienteAtual como parâmetro! O ideal seria que nossa função soubesse que o paciente que queríamos usar é o mesmo que usamos para chamá-la e, assim, parar de receber um paciente como parâmetro:

function calculaImc(){ //sem parâmetro, mas funciona assim?                        

    if(paciente.altura != 0){                        
        var imc = paciente.peso / (paciente.altura * paciente.altura);                        
        return imc;                        
    } else{                        
        console("Não posso dividir por zero!");                        
    }                        
}
Mas e agora? Nós estamos usando uma variável paciente que não existe dentro da função! O que queremos é usar esse paciente, o que usamos para chamar a função. Para isso usaremos a palavra chave this:

function calculaImc(){ //sem parâmetro, mas usando this                        

    if(this.altura != 0){                        
        var imc = this.peso / (this.altura * this.altura);                        
        return imc;                        
    } else{                        
        console("Não posso dividir por zero!");                        
    }                        
}
Agora a chamada de método parece fazer mais sentido, dentro do for:

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    //codigo omitido                    

    var pacienteAtual = {                     
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: calculaImc //atribuindo a função ao atributos pegaImc                        
    };                         

    var imc = pacienteAtual.pegaImc(); //sem parâmetros!!!                        

    //codigo omitido                        
}
Deste modo, nosso código final, para montar todos os pacientes, fica:

function calculaImc(){                        

    if(this.altura != 0){                        
        var imc = this.peso / (this.altura * this.altura);                        
        return imc;                        
    } else{                        
        console("Não posso dividir por zero!");                        
    }                        
}                        

var trsPacientes = document.getElementsByClassName("paciente");                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: calculaImc                        
    };                            

    var imc = pacienteAtual.pegaImc();                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                         
}
Mas note que continuamos declarando uma função que pode ser acessada de qualquer lugar, a calculaImc, e só utilizamos ela para colocar no paciente! Alias, chamando essa função diretamente nem vai funcionar pois ela precisa de um objeto paciente.

Para evitar essa declaração, poderíamos colocá-la diretamente no objeto, da seguinte maneira:

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    //codigo omitido                    

    var pacienteAtual = {                     
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() { //declarando uma função anônima                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    var imc = pacienteAtual.pegaImc(); //sem param!!!                        

    //codigo omitido                        
}
Note que agora o nome da função é claramente o nome do atributo, ou seja, pegaImc, e só é acessível através do objeto paciente! Agora você pode apagar a função calculaImc()!

Mostrando uma vez o código completo do arquivo calcula-imc.js:

var trsPacientes = document.getElementsByClassName("paciente");                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    var imc = pacienteAtual.pegaImc();                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                         
}
Fim do video 5.2

Passando comportamentos para funções
Imagine que, além de calcular todos os IMCs de nossos pacientes, em outro ponto do sistema queremos mostrar todos os nomes de nossos pacientes.

Como vamos querer executar um mesmo código com todos os pacientes, podemos criar um novo arquivo imprime-nome.js e copiar todo o código para imprimir apenas o nome do pacienteAtual no fim do laço:

//arquivo imprime-nome.js                        

var trsPacientes = document.getElementsByClassName("paciente");                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    var pacienteTr = trsPacientes[posicaoAtual];                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    //só imprimindo nome do pacienteAtual                        
    console.log(pacienteAtual.nome);                         
}
Para testar o novo arquivo js devemos incluí-lo no arquivo index.html, lá bem no final da página:

<script src="imprime-nome.js"></script>
Uma vez adicionado o script na página index.html você já pode testar no navegador. Os nomes dos pacientes devem aparecer na console do navegador.

Código repetido
Repare que nosso código possui dois fors idênticos no momento, um no arquivo calcula-imc.js:

//arquivo calcula-imc.js                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    // monta pacienteAtual                    

    var imc = pacienteAtual.pegaImc();                    

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                         
}
e outro no arquivo imprime-nome.js:

//arquivo imprime-nome.js                        

for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                        

    // monta pacienteAtual                    

    console.log(pacienteAtual.nome);                    
}
Estamos copiando e colando código, o que nunca é bom! Para resolver, podemos pensar em criar uma função que executa a parte repetida! Vamos criar um novo arquivo percorre.js com uma função que percorre o array de trs:

//arquivo percorre.js                        
function percorreArray(trsPacientes){                        
    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    
        // executa algum código                
    }                    
}
E na nossa lógica anterior, bastaria chamar essa função passando o nosso Array como argumento trsPacientes:

percorreArray(trsPacientes);                         
percorreArray(trsPacientes);
Mas a nossa função que percorre o Array não está executando nenhum código dentro dela! O que eu queria é que, a cada vez que eu chamasse a função percorreArray, eu tivesse de passar um comportamento que seria executado em algum ponto dentro dessa função.

Então a ideia é seguinte: a função percorreArray recebe além do array (trsPacientes) um outro argumento que define o código para executar! Muita calma nessa hora :)

Em Javascript, nós envolvemos nossos comportamentos em funções, certo? Então vamos criar uma função que imprime seu imc e outra que imprime o nome de um paciente:

//imprime o imc do paciente                        
function imprimeEModificaTdDeImc(trAtual){                        
    //monta paciente como visto                    
    var imc = paciente.pegaImc(); // invoca a função no pacienteAtual                    
    imcTd.textContent = imc; // atualiza imc                    
    console.log(imc); // imprime o imc do paciente atual                    
}
//apenas loga o nome do paciente                        
function imprimeNome(trAtual){                        
    //monta paciente como visto                    
    console.log(paciente.nome);                    
}
Legal, agora o que queremos é, na nossa função percorreArray, receber um parâmetro que é esse comportamento, ou seja uma dessas funções:

function percorreArray(trsPacientes, comportamento){                        
    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    
        // executa algum código                
    }                    
}
E para executar esse comportamento, basta invocá-lo!(lembre-se, comportamentos são funções em Javascript)

//arquivo percorre.js                        

function percorreArray(trsPacientes, comportamento) {                        

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    
        comportamento();                
    }                    
}
Agora temos nosso for isolado em apenas uma função, que recebe um comportamento para ser utilizado dentro deste loop! Vamos ver como está o nosso código até agora:

Note que, apesar de recebermos um comportamento como argumento na nossa função percorreArray, nós não passamos nenhum na chamada desta.

O que queremos é que: na primeira chamada o comportamento seja imprimeNome e na segunda seja imprimeEModificaTdDeImc, então vamos passar estas funções como parâmetro:

percorreArray(pacientes, imprimeNome);                         
percorreArray(pacientes, imprimeEModificaTdDeImc);
Agora, dentro da função percorreArray, estamos chamando as funções imprimeNome(na primeira chamada) e imprimeEModificaTdDeImc(na segunda chamada):

//arquivo percorre.js                        

function percorreArray(trsPacientes, comportamento) {                        

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    
        comportamento(); //imprimeNome ou imprimeEModificaTdDeImc                
    }                    
}
Mas lembre que nossas funções imprimeNome e imprimeEModificaTdDeImc, precisam de um paciente para funcionar! Para isso, no nosso for, temos que passar o pacienteAtual como parâmetro para o comportamento:

//arquivo percorre.js                        

function percorreArray(trsPacientes, comportamento) {                        

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    

        var pacienteTrAtual = trsPacientes[posicaoAtual];                
        comportamento(pacienteTrAtual);                
    }                    
}
Agora já podemos testar o código nosso código inteiro, veja cada arquivo!

Arquivo percorre.js que possui a função que faz o loop do array trsPacientes e chamandoa função que recebe pelo segundo argumento (comportamento):

//arquivo percorre.js                        
function percorreArray(trsPacientes, comportamento) {                        

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    

        var pacienteTrAtual = trsPacientes[posicaoAtual];                
        comportamento(pacienteTrAtual);                
    }                    
}
O arquivo imprime-nome.js que busca os trsPacientes, define a função imprimeNome e chamaa função percorreArray:

//arquivo imprime-nome.js                        

var trsPacientes = document.getElementsByClassName("paciente");                        

percorreArray(trsPacientes, imprimeNome);                        

function imprimeNome(pacienteTr) {                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    console.log(pacienteAtual.nome);                         
}
E o arquivo calcula-imc.js que também busca os trsPacientes, define a função imprimeEModificaTdDeImc e chama a função percorreArray:

//calcula-imc.js                        

var trsPacientes = document.getElementsByClassName("paciente");                        

percorreArray(trsPacientes, imprimeEModificaTdDeImc);                        

function imprimeEModificaTdDeImc(pacienteTr){                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    var imc = pacienteAtual.pegaImc();                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                        
}
No Javascript é bem comum passarmos funções como parâmetros dessa maneira, o que é diferente de algumas linguagens de programação, vale a pena se acostumar!

Já podemos testar esse código, mas não podemos esquecer de importar o arquivo percorre.js napágina index.html. Seguem uma vez todos os imports da página. Importante é que o percorre.jsvem no início pois os outros dois arquivos dependem dele:

<script src="percorre.js"></script>                        
<script src="calcula-imc.js"></script>                        
<script src="imprime-nome.js"></script>
Funcionou?

Funções anônimas
Perceba que no nosso código, nós temos duas funções que só são usadas para passar um comportamento para outra função, a imprimeNome e a imprimeEModificaTdDeImc.

Como nós não temos a intenção de reaproveitar essas funções em outros pontos do nosso código, não precisamos declará-las! Podemos passar uma função diretamente para outra(como a percorreArray) da seguinte maneira:

percorreArray(trsPacientes, function(){                        
    // o que quiser fazer aqui                    
});
Note que, o que fizemos foi passar a função diretamente, sem declará-la antes e sem dar um nome a ela, por isso essas funções são chamadas de funções anônimas. Vamos então utilizar funções anônimas no lugar da imprimeNome:

percorreArray(trsPacientes, function(){                        
    //codigo que monta paciente omitido                    
    console.log(pacienteAtual.nome); // imprime o nome do paciente atual                    
});
Mas note que, desse modo, a função anônima não terá nenhum paciente para acessar, precisamos então receber um como parâmetro, como fazíamos na antiga imprimeNome:

percorreArray(trsPacientes, function(pacienteAtual){                        
    //codigo que monta paciente omitido                    
    console.log(pacienteAtual.nome); // imprime o nome do paciente atual                    
});
Basta fazer o mesmo para a imprimeEModificaTdDeImc! Assim temos o seguinte resultado:

O percorre.js que não mudou:

//arquivo percorre.js                        

function percorreArray(trsPacientes, comportamento) {                        

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){                    

        var pacienteTrAtual = trsPacientes[posicaoAtual];                
        comportamento(pacienteTrAtual);                
    }                    
}
O arquivo imprime-nome.js que usa uma função anônima

//arquivo imprime-nome.js                        

var trsPacientes = document.getElementsByClassName("paciente");                        

//agora usando uma função anonima (função sem nome)                        
percorreArray(trsPacientes, function(pacienteTr){                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    console.log(pacienteAtual.nome);                         
}); //muito cuidado pra não esquecer de fechar aqui a chamada da função
O arquivo calcula-imc.js que usa também pode utilizar uma função anônima:

//calcula-imc.js                        

var trsPacientes = document.getElementsByClassName("paciente");                        

percorreArray(trsPacientes, function (pacienteTr){                        

    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0];                         
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0];                         
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];                        

    var pacienteAtual = {                         
        nome : tdNome.textContent,                         
        peso : tdPeso.textContent,                         
        altura : tdAltura.textContent,                        
        pegaImc: function() {                        

            if(this.altura != 0){                        
                var imc = this.peso / (this.altura * this.altura);                        
                return imc;                        
            } else{                        

                console("Não posso dividir por zero!");                        
            }                        
        }                        
    };                            

    var imc = pacienteAtual.pegaImc();                        

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0];                         
    tdImc.textContent = imc;                        

    console.log(imc);                        
}); //muito cuidado pra não esquecer de fechar aqui a chamada da função
Como resultado temos um código mais conciso e elegante!

Para deixar completo, tbm segue o arquivo index.html:

<!doctype html>                        
<html lang="en">                        
    <head>                    
        <meta charset="UTF-8">                
        <title>Meus pacientes</title>                
        <link rel="stylesheet" type="text/css" href="reset.css">                
        <link rel="stylesheet" type="text/css" href="alura.css">                
    </head>                    
    <body>                    
        <header>                
            <div class="container">            
                <h1>Meus pacientes</h1>        
            </div>            
        </header>                
        <main class="container">                
            <section>            
                <h2>Meus pacientes</h2>        
                <table>        
                    <tr>    
                        <th>Nome</th>
                        <th>Peso(kg)</th>
                        <th>Altura(m)</th>
                        <th>IMC</th>
                    </tr>    
                    <tr class="paciente">    
                        <td class="info-nome">Leonardo</td>
                        <td class="info-peso" id="peso-1">57</td>
                        <td class="info-altura" id="altura-1">1.67</td>
                        <td class="info-imc" id="imc-1"></td>
                    </tr>    
                    <tr class="paciente">    
                        <td class="info-nome">Paulo</td>
                        <td class="info-peso" id="peso-2">100</td>
                        <td class="info-altura" id="altura-2">2.00</td>
                        <td class="info-imc" id="imc-2"></td>
                    </tr>    
                    <tr class="paciente">    
                        <td class="info-nome">Stuart</td>
                        <td class="info-peso" id="peso-3">120</td>
                        <td class="info-altura" id="altura-3">1.80</td>
                        <td class="info-imc" id="imc-3"></td>
                    </tr>    
                    <tr class="paciente">    
                        <td class="info-nome">Rafael</td>
                        <td class="info-peso" id="peso-4">110</td>
                        <td class="info-altura" id="altura-4">1.60</td>
                        <td class="info-imc" id="imc-4"></td>
                    </tr>    
                </table>        
                <button id="calcula-imcs" class="botao ">Calcular Imcs</button>        
            </section>            
            <section>            
                <h2>Adicionar novo paciente</h2>        
                <form>        
                    <fieldset>    
                        <label for="nome">Nome:</label>
                        <input id="campo-nome" type="text" placeholder="digite o nome do seu paciente">
                    </fieldset>    
                    <fieldset class="campo-medio">    
                        <label for="peso">Peso:</label>
                        <input id="campo-peso" type="text" placeholder="digite o peso do seu paciente">
                    </fieldset>    
                    <fieldset class="campo-medio">    
                        <label for="altura">Altura:</label>
                        <input id="campo-altura" type="text" placeholder="digite a altura do seu paciente">
                    </fieldset>    
                    <button id="adicionar-paciente" class="botao bto-principal">Adicionar</button>    
                </form>        
            </section>            
        </main>                
        <script src="percorre.js"></script>                
        <script src="calcula-imc.js"></script>                
        <script src="imprime-nome.js"></script>                
    </body>                    
</html>

Temos as seguintes afirmativas sobre funções em Javascript:
A) Uma função é um bloco de código que pode ser guardado para ser chamado assim que desejarmos, contanto que saibamos seu nome. Contudo, não é necessário sabermos a sua implementação.

B) A seguinte declaração de função é válida:

// declara a função
function exibeAlerta() {
   alert('Olá');
}

exibeAlerta(); // chama a função
C) A convenção é criarmos funções no padrão camelCase.

D) Javascript é uma linguagem funcional, por isso dominar funções é condição fundamental para criar aplicações mais complexas.

Sobre as afirmativas anteriores, podemos afirmar que:

Todas são verdadeiras
A linguagem JavaScript apesar de possuir características de linguagem procedurais como a cláusula for e blocos ela se aproxima muito mais de linguagens como Lisp e Schema, justamente por funções serem tratadas especialmente nesta linguagem e ainda por possuir closures. Inclusive Douglas Crockford, grande expoente da linguagem nos diz que podemos estar nos enganando em considerar esta linguagem como uma linguagem procedural:
JavaScript's C-like syntax, including curly braces and the clunky for statement, makes it appear to be an ordinary procedural language. This is misleading because JavaScript has more in common with functional languages like Lisp or Scheme than with C or Java. It has arrays instead of lists and objects instead of property lists. Functions are first class. It has closures. You get lambdas without having to balance all those parens. (http://www.crockford.com/javascript/javascript.html)

O navegador tem como por padrão executar todo o nosso código Javascript assim que o encontra, mas nem sempre isso é interessante. Por exemplo, podemos querer executar um código apenas quando alguma ação for realizada por um usuário e por aí vai. Interessante, não? Imagine exibirmos um alerta quando o usuário clicar em um botão? Pois é, mas o princípio para entender esse processo é o estudo de funções.

Uma função (ou funcionalidade, se ficar mais claro para você) é um bloco de código que é carregado pelo navegador, mas que não é executado automaticamente. Digamos que o navegador guarda a função em algum lugar para mais tarde alguém chamá-la. Mas para que alguém a chame (chamar significa, executá-la) precisa saber seu nome. É por isso que a declaração de uma função é:

function nomeDaFuncaoQueVoceEscolheu( ) {
     alert('Minha funcionalidade é apenas exibir o alerta');
}
Quando a função é carregada, nada acontece, mas se chamamos a função pelo seu nome, executamos todo aquele código do bloco da função:

function nomeDaFuncaoQueVoceEscolheu( ) {
     alert('Minha funcionalidade é apenas exibir o alerta');
}

nomeDaFuncaoQueVoceEscolheu( );
É através de nomeDaFuncaoQueVoceEscolheu( ) que executamos tudo que está dentro do bloco (entre { e } ) da função. Inclusive podemos chamar a função mais de uma vez:

function nomeDaFuncaoQueVoceEscolheu( ) {
     alert('Minha funcionalidade é apenas exibir o alerta');
}

nomeDaFuncaoQueVoceEscolheu( );
nomeDaFuncaoQueVoceEscolheu( );
nomeDaFuncaoQueVoceEscolheu( );
No exemplo acima, executaremos o bloco da função três vezes, porque a chamamos três vezes!

Mais uma vez, pense que essa função pode ser chamada assim que alguém clicar em um botão e o que acontecerá? Um alerta será exibido. Está ansioso para aprender isso? Muita calma primeiro, estude bastante funções que é a primeira condição para que isso aconteça.

Aliás, há uma convenção no nome de funções assim como nos nomes das variáveis, usamos o padrão camelCase. Sendo assim, toda função começa em letra minúscula e cada palavra que forma o nome da função tem apenas a primeira letra em maiúsculo, lembrando (se você bebeu muito guaraná para abstrair) a corcova de um camelo.

Então, antes de continuar lembre-se:

Função precisa ter um nome para sabermos como chamá-la depois
Todo código dentro do seu bloco só é executado quando a chamarmos, inclusive a função pode ser chamada quantas vezes quisermos
Funções são o coração do Javascript, o que lhe dá poder. Aos poucos você aprenderá a fazer mais com funções.

Recordar é viver, vejamos a seguinte função:
function imprimeFraseEntreAsteriscos() {

    alert( '***' +  'Era uma vez um leão'  + '***' );
}
Sabemos que toda função declarada com um nome precisa ser chamada para executar tudo que foi definida dentro do bloco. Sendo assim, fazemos:

imprimeFraseEntreAsteriscos()
A instrução acima exibirá um alerta com o texto "Era uma vez um leão", que é o resultado da concatenação de strings. Mas se quisermos fazer a mesma coisa com outra frase, por exemplo, "Todos amam o leão"? Teremos ir até a nossa função e alterá-la e realizarmos todo esse processo para novos nomes. Trabalhoso não, sem falar que você pode cometer algum erro de digitação, principalmente na concatenação de strings.

Aí eu te pergunto: no bloco da função, o que queremos que varie toda vez que ela for chamada? O nome, claro! Aprendemos que variável é tudo aquilo que varia (talvez, se você respondesse isso em uma prova tiraria zero, mas aqui tira 10), sendo assim, que tal trocarmos frase fixa por uma variável?

function imprimeFraseEntreAsteriscos() {

    alert( '***' +  frase + '***' );
}
Ótimo, mas você deve estar se perguntando, de onde vem o valor dessa variável? É um buraco dentro da nossa função, tornando-a incompleta. Em um mundo perfeito, eu queria muito que aquela variável ganhasse como valor o texto, ou tecnicamente falando, a string que eu passar para função quando eu chamá-la.

Já sabemos chamar uma função, certo? Só que dessa vez eu quero fazer assim:

 imprimeFraseEntreAsteriscos('Era uma vez um leão!');
 imprimeFraseEntreAsteriscos('Todos amam o leão');
 imprimeFraseEntreAsteriscos('Ninguém ama o leão');
Para cada vez que eu chamar a função, eu quero que no alerta saia aquela String que forneci quando chamei (executei) a função.

Qual das opções abaixo possui a alternativa correta que altera nossa função imprimeFraseEntreAsteriscos preparando-a para receber o texto que desejarmos?

function imprimeFraseEntreAsteriscos(frase) {

    alert( '***' +  frase + '***' );
}

A resposta correta é:
function imprimeFraseEntreAsteriscos(frase) {

    alert( '***' +  frase + '***' );
}
Veja que quando declaramos uma função, no final do seu nome usamos (), porém, se algum nome aparece dentro dos parênteses, significa que a função está esperando receber algo para que possa completar seu trabalho. No exemplo acima temos (frase). Entenda frase aqui como uma variável, mas de onde vem seu valor? O valor da variável é recebido quando chamamos a função como no seguinte exemplo:

imprimeFraseEntreAsteriscos('Era uma vez um gato guerreiro');
No exemplo acima, a variável frase da função receberá 'Era uma vez um gato guerreiro'. Agora, dentro da função, quando a variável for utilizada será considerado este valor. Podemos chamar quantas vezes quisermos nossa função e passar quantas frases assim desejarmos.

Qual das opções representam formas válidas de se declarar uma função em Javascript (selecione apenas uma)?

function nome(){...};

Vimos na aula a seguinte forma:
function nome(){...};
Funções podem receber parâmetros (argumentos) e podem ter um (apenas um) retorno. Vimos isso na função calculaImc:

function calculaImc(paciente){
    if(paciente.altura != 0){
        var imc = paciente.peso / (paciente.altura * paciente.altura);
        return imc; //retornando imc
    } else{

        console("Não posso dividir por zero!");
    }
}
Para chamar essa função basta usar o nome e passar o parâmetro:

var imc = calculaImc(pacienteAtual); //pacienteAtual deve existir
Há uma alternativa para declarar a mesma função:

var calculaImc = function(paciente){
    if(paciente.altura != 0){
        var imc = paciente.peso / (paciente.altura * paciente.altura);
        return imc; //retornando imc
    } else{

        console("Não posso dividir por zero!");
    }
}
Na hora de chamar não tem diferença!

Rita decidiu fixar seu conhecimento sobre funções, inclusive aquelas que não possuem nomes, as funções anônimas.
Primeiro, ela criou um array de números. Em seguida, inspirada no que aprendeu durante a aula, criou a função percorreArray:

<script>


function percorreArray(array) {

    for(var i = 0; i < array.length; i++) {

        console.log(array[i]);
    }

}

var numeros = [1,2,3,4,5,6];
percorreArray(numeros);
</script>
Veja que a função percorreArray recebe um parâmetro apenas, o array a ser iterado. Dentro da função há um código fixo que imprime cada número do array no console. Inclusive, você pode testar esse código em seu navegador criando o arquivo super-teste.html.

O amigo de Rita, Bernado questionou a praticidade do código. Apesar de percorreArray ter uma função bem atribuída que é percorrer o array que lhe foi passado como parâmetro, ela também define o comportamento a ser aplicado em cada elemento iterado do array.

Rita ficou na defensiva por um instante até Bernardo indagar como ela faria para que percorreArray imprimisse, por exemplo, apenas os números ímpares, ou quem sabe os números pares.

Rita então explicou que teria que copiar e colar a função percorreArray, mas como não podem haver nomes de funções iguais ela fez o seguinte:

<script>

function percorreArray1(array) {

    for(var i = 0; i < array.length; i++) {

        console.log(array[i]);
    }

}

function percorreArray2(array) {

    for(var i = 0; i < array.length; i++) {

        // se o módulo da divisão por dois for 0, o número é par
        if( array[i] % 2 == 0) {
            console.log(array[i]);
        }
    }

}

var numeros = [1,2,3,4,5,6];
percorreArray1(numeros);
percorreArray2(numeros);

</script>
Bernardo achou isso um absurdo, porque ela estaria repetindo todo o código de percorreArray, no caso aquele for definido na função. Bernardo lembrou que um dos princípios da programação é não repetir código e tentar fazer com que nosso código possa ser reaproveitado em outras situações.

Rita, desacreditando no que Bernado disse pediu para que ele então alterasse o código de uma maneira que o código da função percorreArray pudesse ser reaproveitada nos dois casos acima. Bernardo então pediu licença e reescreveu a função percorreArray da seguinte maneira:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        comportamento();
    }

}
</script>
Rita perguntou porque ele havia adicionado um novo parâmetro na função. Bernardo disse que a instrução que vai lidar com os itens do array dentro de percorreArray pode variar, então ele passará essa função como parâmetro para o método percorreArray. Os olhos de Rita brilharam e ela lembrou que funções são cidadãos de primeira classe, inclusive podem ser passadas como parâmetro.

Bernado continou e criou mais dua funções, a imprimeApenasPares e imprimeQualquerNumero:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        comportamento();
    }

}

function imprimeApenasPares(numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }
}

function imprimeQualquerNumero(numero) {

    console.log(numero);
}

var numeros = [1,2,3,4,5,6];
</script>
Bernado pediu primeiro para que Rita testasse as duas funções, carregando a página a chamando cada função passado um número. Ela fez assim no console do Chrome:

imprimeApenasPares(2); // imprimiu 2
imprimeApenasPares(1); // não imprimiu nada
imprimeQualquerNumero(1) // imprimiu 1
Rita entendeu que cada função recebe um mesmo parâmetro, um número, mas se ele será impresso ou não varia de função para função. Uma imprime apenas números pares recebidos e a outra qualquer número recebido. Ela não entendeu a relação dessas funções com a função percorreArray.

Funções como parâmetro
Bernardo fez o seguinte no código:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        comportamento();
    }

}

function imprimeApenasPares(numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }
}

function imprimeQualquerNumero(numero) {

    console.log(numero);
}

var numeros = [1,2,3,4,5,6];

percorreArray(numeros, imprimeApenasPares);
percorreArray(numeros, imprimeQualquerNumero);

</script>
Antes dele rodar o código os olhos de Rita brilharam e ela gritou pedindo que ele não rodasse o código que havia um erro. Bernardo sorrindo, perguntou para ela que erro era esse.

Rita disse que entendeu a necessidade do segundo parâmetro de percorreArray. Ela entendeu que a única coisa que varia em percorreArray é o comportamento aplicado ao item, ou seja, o que será realizado com o item que esta sendo iterado. Ela entendeu que quando Bernardo passou imprimeApenasParescomo segundo parâmetro para percorreArray, dentro da função percorreArray o parâmetro comportamento passou a ser a função passada como parâmetro. Então Rita explicou que, se comportamento em percorreArray é uma função, no caso imprimeApenasPares, a função imprimeApenasPares deve receber um parâmetro e dentro de percorreArray Bernardo apenas a chamou sem passar qualquer valor.

Bernardo disse que fez isso de propósito e pediu para que Rita corrige o código. Ela fez assim:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        // veja que a função agora esta sendo chamada recebendo um parâmetro
        comportamento(array[i]);
    }

}

function imprimeApenasPares(numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }
}

function imprimeQualquerNumero(numero) {

    console.log(numero);
}

var numeros = [1,2,3,4,5,6];

percorreArray(numeros, imprimeApenasPares);
percorreArray(numeros, imprimeQualquerNumero);

</script>
Rita agradeceu Bernardo e ainda explicou o seguinte. Na primeira chamada de percorreArray, estamos passando um array e uma função, essa função será o comportamento usado por percorreArray. Como a primeira imprime apenas números pares, o for de percorreArray só imprimirá números pares. Na segunda chamada de percorreArray, o segundo parâmetro agora é a função imprimeQualquerNumero. Essa função, quando chamada dentro de percorreArrray imprimirá todos os itens do array, pois não faz teste algum.

Funções anônimas
Quando Bernardo esta indo embora, Rita pulou da cadeira e disse que poderia melhorar ainda mais o código.

Ela disse que nem seria necessário declarar as funções imprimeApenasPares, muito menos imprimeQualquerNumero. Dessa vez, quem arregalou os olhos foi Bernardo.

Ela primeiro removeu os nomes das funções imprimeApenaPares e imprimeQualquerNumero:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        // veja que a função agora esta sendo chamada recebendo um parâmetro
        comportamento(array[i]);
    }

}

// função sem nome (anônima)
function (numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }
}

// função sem nome (anônima)

function (numero) {

    console.log(numero);
}

var numeros = [1,2,3,4,5,6];

percorreArray(numeros, imprimeApenasPares);
percorreArray(numeros, imprimeQualquerNumero);

</script>
Bernardo sorriu e disse que o código do jeito que está não funciona, porque só podemos usar funções anônimas, que nada mais são do que funções que não recebem nome em uma variável ou quando passamos elas diretamente como parâmetro. Rita deu uma piscadinha para Bernardo e fez a última alteração:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        // veja que a função agora esta sendo chamada recebendo um parâmetro
        comportamento(array[i]);
    }

}

var numeros = [1,2,3,4,5,6];

percorreArray(numeros, function (numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }

});

percorreArray(numeros, function (numero) {

    console.log(numero);
});

</script>
Bernardo, arregalando os olhos disse que o código faz sentido total. Veja que a declaração das funções, exceto seus nomes (por isso são anônimas) foram passadas direto como segundo parâmetro para a função. O resultado é o mesmo que antes, pois o parâmetro comportamento será a função passada como parâmetro.

Bernardo ainda fez um teste para imprimir apenas números ímpares:

<script>

function percorreArray(array, comportamento) {

    for(var i = 0; i < array.length; i++) {

        // veja que a função agora esta sendo chamada recebendo um parâmetro
        comportamento(array[i]);
    }

}

var numeros = [1,2,3,4,5,6];

percorreArray(numeros, function (numero) {

    if(numero % 2 == 0) {
        console.log(numero);
    }

});

percorreArray(numeros, function (numero) {

    console.log(numero);
});

percorreArray(numeros, function (numero) {

    if(numero % 2 != 0) {
        console.log(numero);
    };
});

</script>
No final, Bernardo convidou Rita para ir ao cinema, mas ela se recusou.

No arquivo percorre.js faremos loop e chamaremos a função que recebemos como segundo parâmetro:
//arquivo percorre.js

function percorreArray(trsPacientes, comportamento) {

    for(var posicaoAtual = 0; posicaoAtual <= trsPacientes.length - 1; posicaoAtual++){

        var pacienteTrAtual = trsPacientes[posicaoAtual];
        comportamento(pacienteTrAtual);//função é executada
    }
}
E no arquivo calcula-imc.js chamaremos a função percorreArray.

No código abaixo declaramos a função que imprime o IMC explicitamente. Também estamos usando a função montaPaciente do desafio anterior:

//arquivo calcula-imc.js

var trsPacientes = document.getElementsByClassName("paciente");

percorreArray(trsPacientes, imprimeEModificaTdDeImc);

function imprimeEModificaTdDeImc(pacienteTr){

    var pacienteAtual = montaPaciente(pacienteTr);    
    var imc = pacienteAtual.pegaImc();

    var tdImc = pacienteTr.getElementsByClassName("info-imc")[0]; 
    tdImc.textContent = imc;

    console.log(imc);
}

function montaPaciente(pacienteTr){
    var tdNome = pacienteTr.getElementsByClassName("info-nome")[0]; 
    var tdPeso = pacienteTr.getElementsByClassName("info-peso")[0]; 
    var tdAltura = pacienteTr.getElementsByClassName("info-altura")[0];

    var paciente = {
        nome : tdNome.textContent, 
        peso : tdPeso.textContent, 
        altura : tdAltura.textContent,
        pegaImc: function() {

            if(this.altura != 0){
                var imc = this.peso / (this.altura * this.altura);
                return imc;
            } else{

                console("Não posso dividir por zero!");
            }
        }
    }
    return paciente;
}
Como vimos na aula não é preciso declarar essa função imprimeEModificaTdDeImc explicitamente. Aproveite e use uma função anônima!

Isso já é um belo código Javascript!


############### 6. Eventos ###############

O que são eventos?
É comum, quando estamos programando em Javascript, querer adicionar um comportamento ao clique de um elemento, ao usuário passar o mouse em cima de um elemento, quando o texto de um <input> for alterado e etc, estas ações são chamadas de eventos, que serão disparados em determinado momento.

Nesse capítulo aprenderemos a como podemos ouvir um evento e executar uma ação a partir dele.

Calculando o IMC a partir de um clique
Até agora nós fomos capazes de calcular o IMC de nossos pacientes assim que a página fosse carregada, mas seria mais legal ainda se nós tivéssemos um botão "Calcular IMCs" que, só após ser clicado, preencheria a nossa tabela com os IMCs dos respectivos pacientes.

Para começar então, vamos analisar o código da nossa tabela e botão:

<table>
    <tr>
        <th>Nome</th>
        <th>Peso</th>
        <th>Altura</th>
        <th>IMC</th>
    </tr>
    <tr>
        <td id="nome-1">Leonardo</td>
        <td id="peso-1">50.0</td>
        <td id="altura-1">1.60</td>
        <td id="imc-1"></td>
    </tr>
    <tr>
        <td id="nome-2">Paulo</td>
        <td id="peso-2">100</td>
        <td id="altura-2">2.00</td>
        <td id="imc-2"></td>
    </tr>
</table>
<button id="calcular-imcs" class="botao">Calcular IMCs</button>
Neste momento, ao clicar em nosso botão, nada acontecerá, isso por que ainda não estamos ouvindo o clique dele!

Como ouvir eventos?
Para começarmos a ouvir o clique de nosso botão, vamos utilizar o atributo onclick do html, que receber como argumento um código Javascript a ser executado, podemos testar isso utilizando a função alert do javascript.

<button onclick="alert('Calculando Imcs')" id="calcular-imcs" class="botao">Calcular IMCs</button>
Mas isso não irá calcular realmente os imcs dos pacientes, para fazer isso precisamos invocar uma função que pode se chamar, por exemplo, calculaTodosImcs:

<button onclick="calculaTodosImcs()" id="calcular-imcs" class="botao">Calcular IMCs</button>
Porém, para funcionar, precisamos envolver nosso código Javascript em uma função com esse nome:

function calculaTodosImcs(){
    //pega trsPacientes
    //pega trsPrsPacientes
    percorreArray(trsPacientes, function(trAtual){
        //monta paciente
        var imc = paciente.pegaImc(); // pega o imc do paciente atual
        var trDoImc = trDoPaciente.getElementsByClassName("info-imc")[0];
        imcTd.textContent = imc; // atualiza imc
        console.log(imc); // imprime o imc do paciente atual    
    }); 
}
Legal, agora estamos chamando essa função no clique do botão. Mas espere! Note que estamos colocando Javascript no meio de nosso html, o que é uma má prática.

O ideal seria que nosso Javascript ficasse totalmente separado da nossa estrutura html, para isso teremos que ouvir o evento do botão sem utilizar o atributo onclick.

Precisamos então manipular um elemento no nosso script, lembra de como fazemos isso? Isso mesmo! Precisamos selecioná-lo!

var botao = document.getElementById("calcular-imc");
Legal, agora já temos nosso botão, mas falta ouvirmos o clique nele, para isso usaremos o atributo onclick, que recebe uma função. Note que, dessa vez, estamos fazendo isso apenas no Javascript:

var botao = document.getElementById("calcular-imc");
botao.onclick = calculaTodosImcs();
Pronto! Agora se alguém clicar no botão, uma mensagem dizendo "Alguém clicou no botão!" aparecerá no console!

O problema de se utilizar essa abordagem é que nós só conseguimos adicionar uma função por evento, ou seja, não conseguimos efetuar mais de uma função no clique de um usuário.

Por exemplo, se atribuirmos duas vezes uma função ao atributo onclick do botão, como no seguinte código, somente a ultima delas será invocada ao se clicar no botão:

var botao = document.getElementById("calcular-imc");
botao.onclick = calculaTodosImcs;
botao.onclick = function(){
    console.log("Calculando imcs");
};
Para resolver esse problema podemos utilizar a função addEventListener, presente em navegadores modernos. Essa função recebe dois parâmetros: o evento que se quer ouvir e a ação que deseja fazer:

var botao = document.getElementById("calcular-imc");

botao.addEventListener("click", function(){
    console.log("Alguém clicou no botão!");
});

botao.addEventListener("click", function(){
    console.log("Essa é outra função");
});
Deste modo podemos executar varias funções no mesmo evento! Note que quem vai executar essa função é o próprio navegador ao detectar o evento de clique. Esse tipo de função anônima que passamos como argumento para ser executada após determinada ação é denominada função de callback

Usando o evento mouseover
Além do evento de clique("click"), ainda temos outros que poderemos usar, por exemplo:

dblclick (clique duplo)
mouseover (ao passar o mouse por cima de um elemento)
keydown (ao pressionar uma tecla)
Entre outros

Com isso nós podemos, por exemplo, alterar a cor de um <tr> ao passarmos o mouse por cima dele, para isso vamos primeiro selecionar todos os <tr>s, lembre-se de que a função getElementsByTagName retorna sempre um Array

var trs = document.getElementsByTagName("tr");
Agora precisamos escutar o evento mouseover em cada um dos trs, portanto precisamos percorrer o nosso Array, lembre-se de que nós temos a função percorreArray, que faz exatamente isso:

var trs = document.getElementsByTagName("tr");
percorreArray(trs, function(trAtual){
    // ouve o evento no trAtual    
})
Agora basta ouvir o evento no trAtual e passar a função que queremos executar:

var trs = document.getElementsByTagName("tr");
percorreArray(trs, function(trAtual){
    trAtual.addEventListener("mouseover", function(){ 
        //aqui queremos pintar a tr de cinza
    });
Legal, estamos escutando o evento, agora precisamos escrever o código para pintar a <tr> que o usuário passou o mouse de cinza, essa tr pode ser acessada através da palavra reservada this dentro da função de callback. Para pintá-la, então, basta mudar o atributo bgcolor dela para grey, o que pode ser feito a partir da função setAttribute:

var trs = document.getElementsByTagName("tr");
percorreArray(trs, function(trAtual){
    trAtual.addEventListener("mouseover", function(){ 
        this.setAttribute("bgcolor", "grey");
    });
});
Alterando o DOM a partir de um evento.
Agora que já sabemos como ouvir eventos em elementos, podemos finalmente chamar a nossa função que calcula os IMCs no clique do botão. Para isso, basta passarmos a nossa função como segundo parâmetro do addEventListener:

function calculaTodosImcs(){
    //pega trsPacientes
    percorreArray(trsPacientes, function(paciente){
        //monta paciente
        var imc = paciente.pegaImc(); // pega o imc do paciente atual
        var trDoImc = trDoPaciente.getElementsByClassName("info-imc")[0];
        imcTd.textContent = imc; // atualiza imc
        console.log(imc); // imprime o imc do paciente atual    
    }); 
}

var botao = document.getElementById("calcular-imc");

botao.addEventListener("click", calculaTodosImcs);
Perceba que, o que queremos é que o próprio navegador invoque a nossa função ao evento ser acionado, portanto, nós não a invocamos ao passá-la como parâmetro!

Eventos são uma forma de chamar um código JavaScript:
a) quando algo no navegador acontece (página carregada ou descarrega, mudança no tamanho etc).
b) quando algo no banco de dados acontece (insert, update ou delete de registros)
c) para fazer uma requisição HTTP.
d) quando o usuário interage com a tela (clique no botão, inputs etc)
Quais das afirmações acima são verdadeiras?

a) e d) são verdadeiras

As afirmações a) e d) estão corretas!
a) Verdadeira ... quando algo no navegador acontece (página carregada ou descarrega, mudança no tamanho etc).

Com eventos podemos facilmente reagir quando a página foi carregada ou fechada!

b) Falsa ... quando algo no banco de dados acontece (insert, update ou delete de registros)

JavaScript é executado no navegador, normalmente tem nada a ver com o banco de dados. (ok ok, existem bancos que também usam JavaScript, mas isso não é o foco do curso. Para os curiosos, um banco famoso que usa JavaScript é o MongoDB).

c) Falsa ... para fazer uma requisição HTTP.

Para executar uma requisição HTTP com JavaScript devemos usar AJAX. Até podemos colocar esse código AJAX dentro de uma função que é chamada através de um evento mas AJAX e eventos são coisas diferentes. Veremos AJAX nos cursos de jQuery e Angular dessa trilha.

d) Verdadeira ... quando o usuário interage com a tela (botão, inputs etc)

Uso clássico de eventos. O usuário faz algo na tela (clique, aperta tecla, usa mouse etc) e é preciso executar algum código.

Tudo ok?

Alguns outros eventos famosos que poderíamos ouvir seriam:
dblclick (clique duplo)
mouseover (ao passar o mouse por cima de um elemento)
keydown (ao pressionar uma tecla)
Na página da MDN tem uma lista completa de todos os eventos. São muitos!

https://developer.mozilla.org/en-US/docs/Web/Events

Veja o HTML bem simples:
<html>
 <body>
    <p id="texto">JavaScript: Programando na linguagem da web</p>
    <script type="text/javascript" src="eventos.js"></script>
 <body>
</html>
E o arquivo eventos.js:

var pTexto = document.getElementById("texto");

pTexto.onmouseover = function() {
    console.log(this.textContent);
}

pTexto.onmouseover = function() {
    console.log(this.textContent.toUpperCase());
}
Ai vem a pergunta: Quando o usuário passa com o mouse em cima do texto do parágrafo, o console imprime em caixa alta ou baixa?

Console imprime em caixa alta
Console imprime em caixa alta! Como aprendemos, usando diretamente o atributo do evento no elemento DOM, apenas a última função será executada.
O interessante nesse exemplo é que usamos o this. Se lembra disso? Dentro da função o this representa o elemento do DOM que foi associado com o elemento, no nosso o <p> com a id texto. Por isso podemos chamar .textContent e pegar o valor do elemento. Tudo bem?



