############### 1. O que é o HTTP ###############

Nesse treinamento focaremos nos fundamentos da web. Isto é importante pois a grande maioria das aplicações hoje em dia a utilizam de alguma forma ou funcionam dentro dela. Não focaremos em nenhuma plataforma específica de desenvolvimento como Java ou PHP. Focaremos nas regras de comunicação da web. Quanto mais o desenvolvedor entender essas regras, mais fácil será a criação de aplicações web.
Cliente-Servidor
Quando alguma página na internet é acessada utiliza-se um navegador como Google Chrome, Mozilla Firefox ou o Microsoft Edge. Você, aluno que está usando a Alura, já tem esse navegador instalado. Entre ele e a Alura aconteceu uma comunicação, por isso você está vendo este curso e vídeo, fazendo exercícios e etc. Os dados são enviados através de uma rede gigante chamada Internet.

O navegador (estou usando o Google Chrome, e você?), representa nessa comunicação o cliente e a Alura o servidor. O cliente pede informações e o servidor responde. Esse modelo de comunicação, ou essa arquitetura, é chamado de Cliente-Servidor, em inglês Client-Server.

Definindo regras de comunicação
Em qualquer comunicação tem que existir algumas regras e vocabulário. Pensando no idioma português essas regras são bastante complexas e extensas. Mas ainda bem que não estamos falando sobre o português e sim apenas sobre a comunicação client-server, sobre a comunicação do seu navegador para a Alura ou algum outro site.

Por exemplo, o que acontece quando acessarmos algum curso que não existe na Alura? O servidor não saberá a resposta e precisará indicar para o navegador que não conseguiu carregar os dados. Esse comportamento deve estar definido em algum lugar. É por isso que foi criado um idioma próprio, ou melhor, um protocolo próprio que possui um vocabulário e gramática específica. Este protocolo é quem define as regras de comunicação entre cliente e servidor! Existem vários protocolos no mundo de computação e redes, mas nesse treinamento focaremos no protocolo principal usado na internet, o tal do HTTP.

Resumindo: Descobrimos que o HTTP é um protocolo que define as regras de comunicação entre cliente e servidor na internet. Vamos focar nos próximos vídeos e entender melhor esse protocolo tão importante. Agora é praticar com os exercícios, mãos a obra!

O que aprendemos neste capítulo?
Na internet sempre tem um cliente e um servidor
Entre o cliente e o servidor precisam haver regras de comunicação
As regras são definidas dentro de um protocolo
HTTP é o protocolo mais importante na internet

Olá Aluno!
Nesse treinamento vamos falar sobre a "sigla" mais importante da internet: o HTTP. O objetivo é entender o protocolo HTTP detalhadamente. Quanto mais o desenvolvedor souber sobre este protocolo, melhor, pois ele é utilizado em todas aplicações web.

No entanto, não focaremos como essas aplicações são criadas e funcionam internamente. Para isso existem várias plataformas como PHP, .NET ou Java (entre muitas outras) que não abordaremos. Temos treinamentos dedicados para conhecer estas plataformas.

Resumindo então, nosso foco será o protocolo HTTP!!

Falamos tanto sobre esta sigla, mas qual é o significado do HTTP? Pesquise na web!

Hypertext Transfer Protocol

No mundo de TI temos muitas siglas e abreviações! O que menos importa é decorar esses nomes, mas é preciso entender o que há por trás. Nesse treinamento vamos focar nos principais conceitos do protocolo HTTP, aquilo que realmente importa para o desenvolvedor.

O protocolo HTTP segue o modelo Client-Server. O que o navegador (como Chrome ou Firefox) representa nesse modelo? O cliente ou o servidor?

Cliente
 
Acertou! Nesse modelo, o navegador representa o cliente. É importante saber que não só navegadores dominam o protocolo HTTP. Ainda veremos mais sobre esses outros neste treinamento

O cliente inicia a comunicação e o servidor responde. No entanto, qual é o papel do HTTP entre Cliente e Servidor?

Estabelecer regras de comunicação

Se você compreende este texto, é porque você sabe português! Para que alguém consiga se comunicar com você, esse alguém deverá usar o português (supondo que você desconheça outro idioma, é claro). Isso significa que, sua regra (protocolo) de comunicação com o mundo é a lingua portuguesa que define a forma com que as informações devem chegar até você (através do vocabulário, regras de gramática e etc). Uma outra pessoa que conheça português irá usar do mesmo formato, já que vocês possuem um idioma em comum.
Na internet como já vimos, o idioma mais comum é o HTTP. Ele é responsável por definir a forma com que os dados são trafegados na rede através de várias regras. Portanto todo mundo que conhece o idioma HTTP poderá receber e enviar dados e participar dessa conversa!

Você já usou Torrent para baixar algum arquivo na internet? Caso sim, aproveitou um outro modelo de comunicação, o P2P ou Peer-To-Peer!
O modelo Cliente-Servidor não é o único modelo de comunicação na rede, nem sempre o mais adequado. Por exemplo, imagine que precisa contar as letras de 20 palavras. No caso do modelo Cliente-Servidor, quem fará esse trabalho é o servidor, certo? E se precisar contar as letras de 1 milhão de palavras? Muito trabalhoso para o servidor não?

O modelo Cliente-Servidor tenta centralizar o trabalho no servidor, mas isso também pode gerar gargalos. Se cada Cliente pudesse ajudar no trabalho, ou seja, assumir um pouco da responsabilidade do servidor seria muito mais rápido. Isso é a ideia do P2P! Não há mais uma clara divisão entre Cliente-Servidor, cada cliente também é servidor e vice versa!

Isto é útil quando você precisa distribuir um trabalho ou necessita baixar algo de vários lugares diferentes. Faz sentido?

Usando algum aplicativo de Torrent o protocolo utilizado não é o HTTP e sim o protocolo P2P como Bittorrent ou Gnutella.

O HTTP não é o único protocolo de comunicação que existe. Aliás, existem milhares de protocolos no mundo de TI, no entanto o HTTP é de longe o mais popular.
Na lista abaixo tem um item que não representa um protocolo para internet. Qual? Pesquise se for necessário!

SQL
 
SQL (Structured Query Language) não é um protocolo para internet e sim uma linguagem de consulta para banco de dados. Um banco de dados cuida dos dados de uma aplicação, é parecido com uma planilha de excel. O SQL ajuda muito a acessar esses dados.
Um banco de dados não se preocupa com como os dados serão visualizados, ele só administra os dados! Aqui no Alura o banco de dados guarda informações sobre os usuários, cursos, perguntas, respostas etc.

Agora a gente já sabe que existe um cliente, o navegador como Chrome e Firefox, e um servidor, o Alura. Para definir as regras de comunicação entre cliente e servidor existe o protocolo HTTP.
Também já sabemos que o servidor usa alguma plataforma como PHP, Java, .Net ou outros. Qual plataforma realmente é utilizada? Não é tão fácil de descobrir pois o HTTP, de propósito, não está focado em alguma plataforma especifica e esconde isso da gente. Bom, eu não vou esconder nada e vou contar para vocês que o Alura usa a plataforma Java e o servidor concreto se chama Tomcat.

Também já falamos que o SQL é uma linguagem para consultar o banco de dados. Alura usa SQL para acessar o banco de dados MySQL.

Com essas informações já temos uma breve ideia da arquitetura do Alura!

Cliente  <--- HTTP ---> Servidor Java  <--- SQL ---> Banco de dados

Há arquiteturas muito mais complexas, mas a grande maioria usa o protocolo HTTP no topo. O protocolo HTTP garante a conectividade. Isso quer dizer que o protocolo HTTP funciona em todos os lugares sem ter problemas com firewalls e outras regras de segurança. A gente pode se conectar sem maiores problemas com qualquer servidor no mundo!

############### 2. A web segura - HTTPS ###############

Ao acessarmos http://www.alura.com.br pelo navegador podemos perceber que há uma pequena mudança no protocolo. O nome do protocolo agora é https: a versão segura do HTTP.


Quando usamos o HTTP (sem o s no final) todos os dados enviados entre cliente e servidor são transmitidos em texto puro, inclusive dados sensíveis como login e senha! Mas por que é importante sabermos isso?

Bem, quando o navegador pede informações do Alura, nessa comunicação há vários intermediários. Por exemplo, usando uma conexão WIFI, os dados do navegador passam primeiro para o roteador WIFI e do roteador passam depois para o modem do provedor, do modem para algum servidor do provedor de internet, como Oi ou NET. É muito provável que existam outros servidores intermediários no provedor antes que os dados realmente cheguem no servidor do Alura. Com a resposta é a mesma coisa, ela volta passando por esses servidores no meio antes de chegar até nosso navegador. O problema é, quando usamos HTTP (sem s), qualquer servidor no meio pode espionar os dados enviados, algo totalmente inseguro!

Certificado digital - a identificação na web
Reparem que no navegador, ao lado do https, aparece um cadeado.



Ao clicarmos no cadeado podemos ver mais informações sobre HTTPS. Repare que existe o Alura que possui uma identidade confirmada:



A web segura trabalha bem parecida com a vida real. Uma pessoa possui uma identidade (RG ou Passaporte) para se identificar. Outras pessoas e organizações confiam nessa identidade pois ela foi emitida por um órgão confiável. Se cada pessoa criasse o seu próprio RG não teríamos certeza da confiabilidade de seus dados e esta é a razão de solicitarmos o RG de um órgão especial do governo. Na web isso funciona bem parecido, só que a identidade é chamada de certificado digital.

Autoridade certificadora
Então, ao clicar no cadeado podemos ver informações sobre o certificado digital do Alura! Esse certificado emitido é confirmado por um órgão ou entidade confiável. Nesse caso a entidade que criou o certificado do Alura se chama COMODO RSA Domain Validation:



Existem outras entidades certificadoras, mas em geral, o navegador conhece essas entidades e confia nelas como na vida real pessoas confiam que o RG foi emitido por um órgão do governo. Repare também que o certificado possui uma validade como o RG.

Chave Pública
Através do certificado o navegador consegue confirmar a identidade do Alura. Ótimo. No entanto, com isso não sabemos ainda como transmitir os dados de maneira segura. Para isso o certificado possui uma chave e essa chave é utilizada para criptografar os dados entre cliente e servidor. Ou seja, o certificado não só prova a identidade como também oferece uma chave para criptografar os dados!



Reparem que a chave na verdade é uma chave pública. Se tem uma chave pública tem que haver uma chave privada, certo? Mas cadê ela? Bom, a chave privada fica com o Alura, é só do Alura. Jamais o servidor do Alura pode oferecer essa chave para alguém, caso contrário toda comunicação se tornará insegura! Em geral, a chave publica é utilizada por qualquer um que queira se comunicar com o Alura pois faz parte do certificado. A chave privada só o Alura conhece, essa chave não é compartilhada com ninguém.

Interessante é que os dados que foram criptografados com a chave pública só podem ser descriptografados com a chave privada! As chaves criam um par e devem ser utilizadas em conjunto (também chamadas de chaves assimétricas). O contrário também é verdadeiro: os dados criptografados com a chave privada só podem ser descriptografados pela chave pública. Ou seja, basta usar essa chave pública do certificado para enviar dados para o Alura de maneira segura e teremos certeza que só o Alura pode ler estes dados! Perfeito.



Importante é mencionar que na hora de desenvolver uma aplicação web normalmente não é preciso se preocupar se é HTTP ou HTTPs, qual é a chave pública ou certificado etc. Usar HTTPS é apenas uma configuração na infraestrutura do servidor e normalmente não causa mudanças no desenvolvimento na aplicação web.

Resumindo
Aprendemos nesse capítulo que só com HTTPs a web se torna segura. Para enviar dados de maneira segura devemos utilizar uma chave pública, e o servidor usa em troca uma chave privada. A chave pública está embutida dentro de um certificado, a chave privada fica visível apenas no lado do servidor. O certificado que possui a chave pública, confirma a identidade de um site ou aplicação, possui o endereço do site e a validade. O certificado é emitido por uma autoridade certificadora que o navegador confia.

O que aprendemos nesse capítulo?
só com HTTPs a web é segura
HTTPs significa usar um certificado digital do servidor
o certificado prova a identidade e tem validade
o certificado possui uma chave publica
a chave é utilizada pelo navegador para criptografar os dados

O que acontece com nossos dados quando usamos HTTP (sem s)?

Os dados são transportados em texto puro para o servidor, visível para qualquer um.
 
Quando usamos HTTP os dados são enviados em texto puro. O que pode ser perigoso, já que estamos deixando aberto para intermediários.

Quando precisamos informar nossos dados a algum servidor queremos ter certeza que este servidor realmente representa a entidade em questão. Queremos confiar em quem estamos fornecendo nossos dados!
Um certificado digital prova uma identidade para um site, onde temos informações sobre o seu domínio e a data de expiração desse certificado.

Além disso, o certificado ainda guarda a chave pública que é utilizada para criptografar (cifrar) os dados que são trafegados entre cliente e servidor.

Aprendemos no video que o HTTPS usa uma chave pública e uma chave privada. As chaves estão ligadas matematicamente, o que foi cifrado pela chave pública só pode ser decifrado pela chave privada e vice versa. Isso garante que os dados cifrados pelo navegador (chave pública) só podem ser lidos pelo servidor (chave privada). Como temos duas chaves diferentes envolvidas, esse método de criptografia é chamado de criptografia assimétrica. No entanto, a criptografia assimétrica tem um problema, ela é lenta.

Por outro lado temos a criptografia simétrica que usa a mesma chave para cifrar e decifrar os dados, como na vida real onde usamos a mesma chave para abrir e fechar a porta. Já a criptografia simétrica é muito mais rápida mas infelizmente não tão segura. Como existe apenas uma chave, ela ficará espalhada pelos clientes (navegadores) e qualquer um, que tem a posse dessa chave, pode decifrar a comunicação.


Agora o interessante é que o HTTPS usa ambos os métodos de criptografia, assimétrica e simétrica. Como assim? Muita calma, tudo que aprendemos é verdade! Só faltou o grande final :)

No certificado vem a chave pública para o cliente utilizar, certo? E o servidor continua na posse da chave privada, ok? Isso é seguro mas lento e por isso o servidor gera uma chave simétrica ao vivo. Uma chave só para ele e o cliente com o qual está se comunicando naquele momento! Essa chave exclusiva (e simétrica) é então enviada para o cliente utilizando a criptografia assimétrica (chave privada e pública) e então é utilizada para o restante da comunicação.

Então HTTPS começa com criptografia assimétrica para depois mudar para criptografia simétrica. Essa chave simétrica será gerada no início da comunicação e será reaproveitada nas requisições seguintes. Bem-vindo ao mundo fantástico do HTTPS :)

Todas as afirmações abaixo estão corretas exceto:

HTTP significa usar um certificado digital do servidor.
As afirmações corretas são:
O certificado guarda a chave pública.
A chave privada fica no lado do servidor apenas.
O certificado prova a identidade e tem validade.
Portanto a afirmação HTTP significa usar um certificado digital do servidor não está correta.

Lembrando o HTTP não utiliza criptografia nenhuma e é inseguro! Para deixar a web segura devemos usar o HTTPs sempre.

Qual o objetivo de uma autoridade certificadora ?

Garantir que podemos confiar naquele certificado (identidade).
Para saber mais: Essa garantia é feita através de uma assinatura digital. A autoridade certificadora (CA) assina digitalmente o certificado! Como na vida real, existem também no mundo digital: assinaturas!


############### 3. Endereços sob seu domínio ###############

Você que está usando Alura, já conhece então o endereço: http://www.alura.com.br. Repare que depois do nome do protocolo vem :// seguido pelo nome do site www.alura.com.br. No vocabulário de um desenvolvedor o www.alura.com.br é o domínio (ou domain). A abreviação www representa o world wide web.

O nome do domínio é organizado em uma hierarquia que foi criada para organizar os sites na internet e para a gente ter algo fácil para se lembrar. Para ser correto, a internet funciona na verdade sem esses domínios. Aqueles nomes são coisas dos humanos, as máquinas na internet têm uma outra forma de se endereçar. Elas usam o que se chama endereços de IP, que nada mais são do que números - muito difícil para gente decorar.

Sendo assim, podemos acessar o Alura usando um IP. Para quem é muito curioso, mas muito curioso mesmo e deseja saber qual é a IP do Alura, pode digitar na linha de comando a seguinte instrução:

nslookup www.alura.com.br
...
Name:    www.alura.com.br
Address: 107.20.180.233
Esse comando procura o numero IP do Alura na internet. Podemos até usar esse endereço no navegador:

http://107.20.180.233

A página principal do Alura deve ser exibida. IP's são mais importantes para quem trabalha com rede. O desenvolvedor normalmente não precisa mexer com isso.

Observação: Esse IP pode mudar dependendo do servidor concreto onde o Alura foi instalado.

Abrindo portas
Como já falamos, quando usamos a URL http://www.alura.com.br abrimos uma conexão com o servidor que roda em algum lugar na internet. Para estabelecer uma conexão na rede é preciso saber qual é o endereço IP, e já vimos como descobri-lo. Agora imagine que o servidor é uma casa: dependendo da casa há várias portas disponíveis. O que é preciso saber é qual porta devemos utilizar quando chegarmos na casa. Ou seja, devemos saber qual porta é utilizada para o protocolo HTTP!

A porta reservada para o protocolo HTTP é o 80. Novamente um número, e como o navegador já sabe essa porta padrão podemos omiti-la, mas nada nos impede adicioná-la no endereço, por exemplo:

http://www.alura.com.br:80
Vai funcionar normalmente, tanto que o navegador esconde automaticamente :80. Vamos tentar uma outra porta, outro numero, por exemplo 81:

http://www.alura.com.br:81
Não funciona pois essa porta não existe no servidor, não podemos estabelecer uma conexão e o tempo de conexão vai esgotar. Igualmente o protocolo HTTPs possui uma porta padrão, o numero 443. Vamos testar também:

https://www.alura.com.br:443 (cuidado https)
Funciona normalmente.

Analisando o domínio
Vamos dar uma olhada com mais carinho no nome do domínio. Olhando da direita para a esquerda, o domínio começa com br, indicando um site do Brasil. O br representa o top level domain, está na raiz do domínio. Depois vem o com, abreviação de comercial e alura. O com e o alura são sub-domínios.

O www representa também um sub-domínio, no entanto seu uso é opcional, tanto que alura.com.br e www.alura.com.br funcionam e mostram a mesma página. A maioria dos site usam o prefixo www e podemos dizer que isso é algo legado que continua ser popular apesar de não ser necessário.

Usando recursos
Navegando dentro do Alura mais informações aparecem depois do nome do domínio. Por exemplo, para acessar a página principal dos cursos usamos https://www.alura.com.br/dashboard. O /dashboard é um recurso (resource) do site que gostaríamos de acessar. Existem vários outros recursos no Alura como o meu perfil (/my_profile), ou o forum de discussões (/forum). O importante é que cada recurso possua o seu nome único.

Navegando um pouco mais no Alura podemos perceber que entre o domínio e o recurso podem vir outras informações . Por exemplo, para acessar o curso Introdução ao HTML e CSS usamos http://www.alura.com.br/course/introducao-html-css. Ou seja, para acessarmos o recurso /introducao-html-css, usamos um caminho intermediário, o /course. Há vários outros exemplos no Alura que usam caminhos para chegar ao recurso concreto, como por exemplo /discussion/mine ou /user/45 e navegando no Alura você encontrará mais. Uma tarefa no dia a dia do desenvolvedor é definir esses nomes e o que deveria acontecer quando o usuário acessá-los.

Finalmente a URL
Repare que estamos usando umas regras bem definidas para descrever a localização de um recurso na web. Todos os endereços na web sempre seguem esse mesmo padrão: protocolo://dominio:porta/caminho/recurso. Esse padrão na verdade segue uma especificação que foi batizada de Uniform Resource Locator, abreviada como URL. Então as URLs são os endereços na web!

O que aprendemos nesse capítulo?
URL são os endereços da Web
Uma URL começa com o protocolo (http://) seguido pelo domínio (www.alura.com.br)
Após o domínio é especificado o caminho para um recurso (/curso/http)
Um recurso é algo concreto na aplicação que queremos acessar

Na URL abaixo, como se chama o protocolo?
smb://server/download/videos/http.avi

smb
Observação: O protocolo smb (Server Message Block) realmente existe e é utilizado para compartilhar arquivos dentro de uma rede local.

Qual é a porta padrão do protocolo HTTP?

80
Como as portas padrão são conhecidas pelo navegador, elas podem ser omitidas ao escrevermos uma URL
Parabéns, você acertou!

O que é um domínio (ou Domain name) e qual a sua importância?

O domínio é o nome do site na Web. Ele facilita a navegação do usuário que não precisa lembrar o IP de cada site.

Como funciona o DNS (Domain Name Server)?

O DNS tem como função realizar a tradução do nome de um domínio para o endereço de IP correspondente

Veja a URL a seguir:
http://g1.globo.com/index.html
Qual é o nome do recurso?

/index.html
No início da web os recursos, na grande maioria, eram arquivos com a extensão .html ou .htm. Até hoje existem vários recursos que são arquivos na web. Mas reparem que Alura não funciona dessa maneira. Em nenhum momento você acessa um arquivo no Alura. Por exemplo, para ver um curso, você usa a URL:
https://www.alura.com.br/course/introducao-html-css

Isso é um pouco mais legível e possui a vantagem que a URL não diz nada a respeito do formato. A URL não fica amarrada ao formato HTML.


############### 4. O cliente pede e o servidor responde ###############

Realizaremos um teste efetuando login no Alura. Quando preenchemos o formulário e clicamos no botão, o navegador envia o nosso login e a nossa senha para o servidor através do protocolo HTTP! Vamos detalhar um pouco esta ação.

No mundo HTTP, a requisição enviada pelo navegador para o servidor é chamada de HTTP REQUEST . Recebemos a página /dashboard como resposta já que enviamos login e senha válidos. No mundo HTTP essa resposta é chamada de HTTP RESPONSE.

A comunicação segue sempre esse modelo: o cliente envia uma requisição e o servidor responde. Requisição e Resposta ou em inglês: Request-Response. Aqui é importante saber que a comunicação sempre começa com o cliente: é ele quem pede as informações. O servidor responde apenas o que foi requisitado e nunca inicia a comunicação!

Comunicação sem estado
Vamos acessar rapidamente outro site: http://g1.oglobo.com. Ao enviarmos estamos enviando uma requisição para g1 e recebemos como resposta a página inicial.

Agora vamos navegar dentro do site e acessar algum artigo. Ao clicarmos enviamos uma nova requisição e percebemos que TODA página foi trocada. Fica mais claro ainda se acessarmos do menu acima algum link (globo esporte ou globo show). Podemos ver que todo o conteúdo do site foi trocado.

Isso também acontece no caso do Alura (talvez um pouco mais difícil de perceber). Ao acessarmos recursos diferentes todo o conteúdo no navegador foi trocado (apesar do menu parecer o mesmo, ele também foi trocado). A ideia do HTTP é justamente essa, cada recurso é independente do outro e não depende do anterior. Isso também se aplica para os dados enviados na requisição. Cada requisição é independente da outra e ela sempre deve conter todas informações para o servidor responder.

Pense que HTTP funciona como o envio de cartas pelo correio e uma carta representa uma requisição. Você fez uma viagem e gostaria de enviar 3 cartas para sua mãe. Adianta falar para os correios "eu vou colocar o endereço apenas na primeira carta, ai vocês já sabem para onde enviar a segunda e terceira carta"? Não adianta pois o correiros tratam cada carta independente, e assim também funciona o HTTP. Cada requisição (carta) precisa ter todas as informações. A mesma coisa se aplica para a resposta, precisa ter todas as informações.

Essa característica de cada requisição ser independente é chamada de stateless. É esse nome bonito mesmo! O HTTP é um protocolo que não mantém o estado de requisições. Isso significa que só com HTTP não há como se lembrar das requisições anteriores enviadas para o servidor. Por isso precisamos incluir em cada requisição todas as informações, sempre. Para o desenvolvedor este conhecimento é importante pois é justamente essa característica stateless que o atrapalha no dia a dia. Ele precisa preparar a aplicação web para que funcione bem usando o protocolo HTTP, algo que veremos nos treinamentos do Alura.

Lidando com Sessões
Reparem que, mesmo após termos realizado o login e termos enviado várias requisições, aparece o ícone com a minha imagem no menu principal.

Ou seja, o Alura se lembra de alguma forma que eu fiz login em alguma requisição anterior. Como falamos antes, cada requisição deve enviar todas as informações para gerar a resposta. Isso significa que o navegador envia em cada requisição informações sobre o meu usuário! Se cada requisição for independente da outra, e não tem como se lembrar das requisições anteriores, não tem outra explicação a não ser que o navegador envie os dados sobre o meu usuário em cada requisição! Lembre-se da carta postal, ela sempre precisa ter os dados do remetente e aqui não é diferente!

Então o navegador envia login e senha em cada requisição? Não, não seria muito elegante nem seguro fazer isso. Mas ele faz algo parecido, acreditem ou não. Quando efetuamos o login, o Alura valida os nossos dados, certo? Nesse momento, o servidor tem certeza que o usuário existe e gera uma identificação quase aleatória para o usuário. Essa identificação é um número criado ao vivo e muito difícil de adivinhar. Esse numero é a identificação temporária do usuário e ele será devolvido na resposta.

Conhecendo cookies
Então onde está esse número? O navegador grava esse número em um arquivo especial para cada site, são os famosos cookies. Como acessar esse cookie depende um pouco do navegador em uso. O mais importante é entender o porquê da existência desse número e onde ele foi gravado.

No Chrome podemos ver todos os cookies armazenados nas Configurações -> Procurando Cookies -> Configurações de conteúdo -> Todos os cookies e dados do site -> Procurar pelo Alura. Lá temos um cookie com o nome caelum.login.token que contem o número da minha identificação. Se apagarmos esse cookie perderemos nossa identificação, sendo assim, Alura exigirá um novo login pois não sabe mais que já tínhamos feito.

Normalmente o nome do cookie é algo como session-id, dependendo da plataforma utilizada ele pode se chamar de PHPSESSID ou ASP.NET_SessionId ou JSESSIONID ou outro nome que foi inventado! Como o protocolo HTTP é stateless por natureza, todas as plataformas ajudam a gerar esse número e a criar o cookie de maneira transparente. Isto é o que as plataformas gerenciam as SESSÕES com o usuário. Como isso funciona de concreto você aprenderá nas trilhas especificas.

A ideia de manter dados entre requisições é algo muito comum no desenvolvimento de aplicações na web. Um usuário que se loga no sistema web causa a criação de uma sessão. Uma sessão então é útil para guardar informações sobre o usuário e ações dele. Um exemplo clássico é um carrinho de compras. Entre várias requisições estamos usando o mesmo carrinho de compras que guarda os nossos produtos escolhidos (fizemos uma sessão de compras online).

O que você aprendeu nesse capítulo?
o protocolo HTTP segue o modelo Requisição-Resposta
sempre o cliente inicia a comunicação
uma requisição precisa ter todas as informações para o servidor gerar a resposta
HTTP é stateless, não mantém informações entre requisições
As plataformas de desenvolvimento usam sessões para guardar informações entre requisições

Qual das informações abaixo é verdadeira?

Uma requisição sempre deve ser enviada com todas as informações necessárias, o que faz uma requisição ser sempre independente das demais.

O que é uma sessão HTTP?

É o tempo que o cliente utiliza web app
Uma sessão HTTP nada mais é que um tempo que o cliente permanece ativo no sistema! Isso é parecido com uma sessão no cinema. Uma sessão nesse contexto é o tempo que o cliente usa a sala no cinema para assistir a um filme. Quando você sai da sala termina a sessão. Ou seja, quando você se desloga, o Alura termina a sua sessão.

Quando falamos de Cookies na verdade queremos dizer Cookies HTTP ou Cookie web. Um cookie é um pequeno arquivo de texto, normalmente criado pela aplicação web, para guardar algumas informações sobre usuário no navegador. Quais são essas informações depende um pouco da aplicação. Pode ser que fique gravado alguma preferência do usuário. Ou algumas informações sobre as compras na loja virtual ou, como vimos no vídeo, a identificação do usuário. Isso depende da utilidade para a aplicação web.
Um cookie pode ser manipulado e até apagado pelo navegador e, quando for salvo no navegador, fica associado com um domínio. Ou seja, podemos ter um cookie para www.alura.com.br, e outro para www.caelum.com.br. Aliás, um site ou web app pode ter vários cookies!

Podemos visualizar os cookies salvos utilizando o navegador. Como visualizar, depende um pouco do navegador em questão:

No Chrome: Configurações -> Pesquisar Cookie -> Configurações de conteúdo -> Todos os cookies -> Pesquisar www.alura.com.br

No Firefox: Preferências -> Privacidade -> excluir cookies em particular -> Pesquisar www.alura.com.br

Quando estamos autenticados em algum sistema, como o Alura, é necessário sempre enviar o E-mail e Senha a cada requisição?

Quando enviamos uma requisição HTTP, todos os dados para que ela seja respondida devem ser enviados. Mas e o email e a senha ? Quando o login é feito o Alura tem certeza de que um usuário existe e gera uma identificação quase aleatória pra esse usuário, lembra? E esse número fica salvo em um arquivo especial chamado Cookie, que é gerado e enviado por cada site :)

Qual dessas alternativas é verdadeira?

Uma comunicação com HTTP sempre é iniciada pelo cliente que manda uma requisição ao servidor esperando por uma resposta.

############### 5. Depurando a requisição HTTP ###############

Vamos fazer um teste e usar o navegador para mostrar mais detalhes sobre a comunicação HTTP. Os navegadores mais populares como Google Chrome, Mozilla Firefox ou Microsoft Internet Explorer possuem ferramentas e plugins que visualizam como o navegador trabalha e usa o HTTP.

Para habilitar as ferramentas do desenvolvedor no Chrome vá ao menu: Visualizar -> Desenvolvedor Ferramentas do desenvolvedor (Selecione a aba Network)

No Firefox vá ao menu: Ferramentas -> Desenvolvedor web -> Exibir/Ocultar ferramentas

Para o Internet Explorer aperte a tecla F12 para abrir o console do desenvolvedor e selecione aba Rede (ou Network).

Método GET do HTTP
Vamos abrir o console de desenvolvedor e acessar o http://www.alura.com.br. Aqui usaremos o navegador Chrome, mas nos outros navegadores o comportamento é bem parecido.

No console podemos ver todas as requisições HTTP executadas pelo Chrome. Mas não só isso, também aparecem alguns códigos e métodos, além do tempo de execução para cada requisição. Repare que chamamos apenas o http://www.alura.com.br, mas foram feitas várias outras requisições em seguidas.



Na primeira coluna aparece a URL (o endereço) e na segunda coluna o método HTTP. O método HTTP indica qual é a intenção ou ação dessa requisição. Enviamos uma requisição com o método GET. Queremos receber informações, sem modificar algo no servidor, que é justamente a ideia do método GET.

Primeiro código da resposta
Como resposta recebemos o código de status 301. O protocolo HTTP define alguns códigos padrões para esclarecer a resposta. Indo com o mouse em cima do 301 o Chrome mostra o significado desse código: Moved Permanently. Ou seja, o site Alura foi movido para outro lugar! Eis a questão: Onde então está o site Alura?

A localização ou a URL concreta está na resposta HTTP. Vamos clicar em cima do código de status 301 para receber mais informações. Aqui o Chrome mostra todos os cabeçalhos da requisição e da resposta. São muitos (nem tantos) mas o que nos interessa é a nova localização do site. Dentro do item Response Headers podemos ver todos os cabeçalhos que o servidor devolveu e logo logo apareceu um com o nome Location. Esse cabeçalho indica a nova URL, só que agora usando https.

Quando o navegador recebe o status 301 ele já sabe que é preciso enviar uma nova requisição e procura a nova URL no cabeçalho de resposta Location.

Redirecionando entre sites
Se alguém acessa o Alura usando http (lembrando, inseguro) automaticamente é chamado o site seguro (https). Isto é um comportamento muito comum para garantir que usamos https sempre. Se esquecermos de usar https, o servidor devolve o status 301 com a nova localização, mas agora usando https.

O navegador, ao receber 301, chama automaticamente a nova URL. No mundo de desenvolvimento web este comportamento é chamado de Redirecionamento pelo navegador, ou Redirecionamento no lado do cliente. Fomos redirecionados para o recurso correto. A tarefa do desenvolvedor é definir o código de resposta e, no caso em que algum recurso tenha mudado a URL, o código 301 será usado com o cabeçalho Location.

O código 200
Continuando no console, a segunda requisição foi para https://www.alura.com.br, novamente usando o método HTTP GET com a intenção de receber dados. Agora o código de resposta foi 200. Este é um dos códigos mais comuns e significa que tudo deu certo! Dessa vez não foi preciso fazer um redirecionamento (não tem o cabeçalho Location na resposta) e não deu nenhum outro problema. A requisição foi aceita e processada corretamente - código 200. Perfeito.

Tipos de dados diferentes
No console podemos ver que aparecem mais requisições (cada linha representa um novo request). Quando o servidor Alura devolve a resposta para o navegador vem o conteúdo da página inicial em um formato especial, chamado de HTML. O HTML define a estrutura da nossa página, define que menus, botões, links, rodapé etc. Mas dentro do HTML não vêm as imagens e outros arquivos necessários para deixar o site perfeito. Dentro dele vem apenas a URL (endereço) desses outros recursos.

Então, ao receber o HTML, o navegador dispara várias outras requisições para carregar as imagens, fontes e outros dados. Como também são requisições HTTP, o console mostra suas informações. Podemos ver que na resposta vem o tipo do conteúdo, por exemplo text/html, text/css, image/svg+xml, entre outros.

Importante é saber que o protocolo HTTP não está preso em algum formato específico. Podemos trafegar qualquer informação com ele, seja texto ou binário!

Causando um problema
Vamos fazer um teste e acessar um recurso que não existe, por exemplo: https://www.alura.com.br/nao-tem. Bom, o Alura mostra uma imagem que indica que não achou o que procuramos, mas vamos dar uma olhada no console. Repare que o código agora é 404. No mundo HTTP 404 significa que o servidor não encontrou o recurso (Not Found).

Durante o desenvolvimento de uma aplicação web podem acontecer problemas no lado do servidor. Isto é normal pois alguma lógica pode falhar, erros acontecem no desenvolvimento! A notícia boa é que o protocolo HTTP vem preparado para isso. Quando algum problema no servidor acontecer, podemos avisar o cliente através do protocolo HTTP. O código mais comum para este tipo de problema é o 500 que significa: "deu pau no servidor :)". Talvez um ou outro aluno já tenha visto um erro 500 no Alura. Isso não deveria acontecer, mas onde há humanos também há problemas, não é mesmo?

Categorias de códigos
Existem muitos códigos de resposta definidos no protocolo HTTP. Há tabelas disponíveis na web que mostram esses códigos, descrevendo o significado de cada um deles. No entanto, no dia a dia, o desenvolvedor não precisa decorar todos esses códigos. Basta consultar quando for necessário, por exemplo aqui.

Importante é saber que algo que começa com 2xx significa coisa boa, a requisição foi executada com sucesso. Quando recebemos algo como 3xx normalmente significa que o navegador precisa fazer algo a mais (o cliente precisa agir) pois algo mudou ou um recurso não existe mais. 4xx significa que o navegador enviou dados errados como por exemplo uma URL errada. Caso o servidor gere algum problema serão utilizados os códigos 5xx.

No dia a dia os códigos 200, 404 e 500 são de longe os mais utilizados!

O que você aprendeu nesse capítulo?
depurar uma requisição HTTP
o primeiro método HTTP - GET
códigos de resposta como 200, 301 e 404
cabeçalhos da resposta como Location

Qualquer resposta HTTP possui um número que informa sobre o status da requisição.
Qual dos códigos abaixo indica que a requisição foi bem sucedida?

200
200 significa OK, ou sucesso. Não houve nenhum problema no processamento da requisição e ela foi bem sucedida.
Existem mais códigos que começam com 2xx. No entanto 200 é de longe o mais utilizado, principalmente no desenvolvimento de uma aplicação web.

Na documentação oficial se diz a respeito da classe de códigos que começam com 2xx:

2xx - Sucesso
Esta classe de códigos de status indica a ação solicitada pelo cliente foi recebida, compreendida, aceita e processada com êxito.

A tabela completa de mensagens HTTP pode ser vista em: http://www.w3schools.com/tags/ref_httpmessages.asp.

Qual desses códigos representa algum problema gerado no servidor?

500
A classe de código que começam com 5xx significam que houve algum problema no servidor.
Por exemplo: 500 - Internal Server Error ou outro famoso: 503 - Service Unavailable (serviço indisponível)

O código 500 acontece com frequência quando estamos desenvolvendo uma aplicação web e, ao testar, percebemos que erramos algo na lógica que gerou um problema no servidor.

Abra uma nova aba no navegador e tente acessar:
http://g1.globo.com/algo-que-nao-existe

Qual foi o código da resposta?

Obs: Você precisa depurar a requisição HTTP para descobrir o código da resposta.

404
404 é o código clássico que indica que o recurso não foi encontrado. Em geral a classe 4xx indica que o cliente errou algo na requisição.
Segue um outro exemplo da classe 4xx, tente acessar: https://s3.amazonaws.com/caelum-online-public/http/qq.png

Nesse caso o código de resposta é 403(não permitido), o cliente não tem a permissão.

Abaixo um exemplo de uma requisição e resposta usando a ferramenta telnet. Através dele acessamos www.caelum.com.br na porta padrão 80.

telnet estabelece apenas uma conexão TCP (protocolo de rede que roda abaixo do HTTP) e permite que enviemos dados em cima dessa conexão através do terminal. Uma vez a conexão estabelecida, basta escrever no terminal e os dados serão enviados automaticamente para o servidor. Para o servidor realmente entender os dados devemos respeitar a sintaxe do protocolo HTTP!

Nesse exemplo digitamos no terminal:

GET / HTTP/1.1
HOST: www.caelum.com.br
E a resposta do servidor segue logo abaixo:

HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Vary: Accept-Encoding,User-Agent
Content-Language: pt-br
Date: Mon, 01 Jun 2015 21:00:20 GMT
Server: Google Frontend
Cache-Control: private
Agora, baseado nesses dados, qual foi o método HTTP e código da resposta?

GET e 200

Repare os cabeçalhos da requisição e resposta:

Seguem 4 afirmações:

1) O código da resposta é 302.

2) O recurso solicitado é /curso/.

3) O cliente não recebeu a resposta.

4) O servidor está pedindo um redirecionamento.

Avalie as afirmações e escolhe a resposta correta:

1,2,4 são verdadeiras
 
1) O código da resposta é 302. - Correto, o código aparece na resposta. O código 302 significa Movido Temporariamente.

2) O recurso solicitado é /curso/. - Correto, na requisição aparece: GET /curso/ HTTP/1.1 Atenção: Não confunda com o cabeçalho Location na resposta que aponta para /cursos/ (Plural)!

3) O cliente não recebeu a resposta. - Errado, pois foi enviado sim uma resposta para o cliente.

4) O servidor está pedindo um redirecionamento. - Correto, na resposta aparece o cabeçalho Location: que define o redirecionamento para http://www.caelum.com.br/cursos/.

Portanto, 1, 2 e 4 são verdadeiras.

Já vimos 3 classes do protocolo HTTP: 2xx, 4xx e 5xx.
Para que existem os códigos 3xx?

A classe do código 3xx é relacionada com o redirecionamento.


Nesse caso o cliente (navegador) deve tomar medidas extra para concluir o pedido. Normalmente são utilizados os códigos 301 ou 302 junto com o cabeçalho de resposta Location.

Por exemplo, veja a requisição, tentando acessar Alura através do protocolo HTTP (sem s):

GET / HTTP/1.1
HOST: www.alura.com.br
Na resposta recebemos o código 301 e o cabeçalho Location para enviar uma nova requisição usando o protocolo HTTPS:

HTTP/1.1 301 Moved Permanently
Server: nginx/1.6.2
Date: Tue, 02 Jun 2015 19:37:44 GMT
Content-Type: text/html
Content-Length: 184
Location: https://www.alura.com.br/

HTTP é o protocolo mais utilizado na internet e há muita documentação disponível.
Segue um link que explica os códigos HTTP de forma divertida:

https://httpstatusdogs.com/

O link atual esta fora do ar, consegui achar esta lista da microsoft para poder estudar:
https://support.microsoft.com/pt-br/kb/173971


############### 6. Parâmetros da requisição ###############

Vamos ver um outro exemplo de uma URL e acessar http://www.youtube.com. Como tem muito conteúdo no youtube vamos pesquisar, por exemplo por Neymar. Repare que, ao pesquisar no youtube, a URL mudou um pouco. O recurso acessado pela busca se chama /results (os resultados da pesquisa) mas agora temos um parâmetro da requisição indicado pela ?: http://www.youtube.com/results?search_query=Neymar

O parâmetro se chama search_query com o valor Neymar. Esses parâmetros da URL normalmente são chamados de Query Params. O HTTP permite enviar mais de uma parâmetro, basta concatenar o próximo parâmetro através do caracter &.

Por exemplo, a busca avançada do Google usa vários parâmetros para refinar a pesquisa como o idioma, o país ou data. Veja como o Google concatena os Query Params: https://www.google.com.br/?gws_rd=ssl#lr=lang_pt&tbs=lr:lang_1pt&q=neymart

Parâmetros com GET
Reparem que no console sempre aparece o tipo (ou método) da requisição, sendo GET. Uma característica da requisição GET é enviar os parâmetros pela URL! Isso é útil quando queremos deixar os parâmetros visíveis. Assim podemos facilmente guardar a URL com os parâmetros para repetir a requisição algum momento depois. Mas será que isso também é uma boa opção na hora de enviar credencias como login e senha? Queremos que apareça a senha de um usuário na URL?

Imagina que você efetue o login no seu banco e na URL apareça: https://www.bb.com.br/login?login=nico&password=supersecreto

Não parece ser uma boa solução, não é mesmo?

O método HTTP POST
Vamos efetuar um login no Alura para ver como esse sistema envia dados do usuário para o servidor. Repare que a URL para enviar o login e senha se chama https://www.alura.com.br/signin. Repare também que o método HTTP utilizado mudou. Estamos usando o HTTP POST! Usando o POST, o navegador envia os dados do formulário no corpo da requisição e não na URL! Se fosse um GET, todos os dados seriam enviados através da URL. Como o Alura não deseja que os dados do login e senha apareçam na URL do navegador, foi utilizado um HTTP POST. Faz sentido?

GET para receber, POST para criar?
Um outro exemplo de um método POST no Alura é quando criarmos uma pergunta no forum. Nesse momento o usuário submete um formulário com dados para criar um novo recurso no Alura (a pergunta do aluno se torna um recurso). O método POST foi inicialmente pensado para criar algo novo no servidor como acabamos de fazer. Ou seja, ao enviar uma requisição POST para o servidor, o nossa intenção é criar algo novo. No entanto, nem sempre isso é realmente utilizado dessa maneira. Por exemplo, acabamos de usar um POST para verificar o login, ou seja, não alteramos ou adicionamos nada no Alura. Nossa motivação para o POST era esconder os parâmetros apenas.

Como o servidor realmente reage quando recebe uma requisição POST depende da implementação, depende da lógica atrás. Os métodos como GET e POST definem uma intenção mas o que realmente será executado depende do servidor.

No dia a dia, vocês vão ver código usando GET para fazer pesquisas mas também para alterar ou remover algo no servidor. A mesma coisa podemos dizer sobre POST. Vocês vão usar o POST para inserir e alterar dados, mas também para pesquisar. As aplicações podem adaptar o significado dos métodos HTTP quando for necessário.

Outros métodos HTTP
Para finalizar o capítulo, falta mencionar que existem outros métodos HTTP como o DELETE e PUT (e acredite que tem mais ainda). O DELETE existe para enviar uma requisição com a intenção de remover um recurso, PUT para atualizar. No entanto, esses métodos são poucos utilizados no desenvolvimento de aplicações web, eles são mais importantes quando se tratam de serviços web.

Em geral, há mais recursos que o protocolo HTTP oferece, como vários outros cabeçalhos que especificam mais a requisição e resposta. Aqui nesse treinamento vimos os mais importantes métodos, códigos e cabeçalhos do protocolo HTTP.

O que você aprendeu nesse capítulo?
para declarar um parâmetro da requisição usamos ? após do recurso
vários parâmetros são separados pelo &
params são utilizados para definir detalhes da pesquisa ou enviar dados de um formulário
params no GET fazem parte da URL
existem outros métodos HTTP como POST, DELETE e PUT
params no POST fazem parte do corpo da requisição

Chegamos ao final do curso HTTP e você deve ter uma boa noção agora sobre o funcionamento do protocolo. Os próximos passos podem variar muito, dependendo dos seus objetivos e conhecimentos. Seguem alguns conselhos:
Para quem gostaria de conhecer recursos mais avançados do protocolo HTTP (e HTTP/2), otimizações e performance em geral na Web, segue dois cursos que podem ser interessante para você:

Performance Web I: otimizando o front-end
Performance Web II: Critical Path, HTTP/2 e Resource Hints
O HTTP é o protocolo da web, mas existem outras tecnologias relacionadas com a web, como HTML, CSS e JavaScript, também são chamados de Front-End. Na Alura existem uma série de cursos relacionados com essas tecnologias, da introdução até o avançado. Tenha em mente que qualquer desenvolvedor de aplicações web precisa ter um bom conhecimento sobre essas tecnologias. Para te ajudar na hora de escolher, criamos algumas carreiras (conjuntos de cursos) relacionadas com o mundo Front-End.

HTML, CSS e JavaScript são as tecnologias que o navegador entende, mas é preciso ter um servidor para produzir o conteúdo dinamicamente. Aqui entra as tecnologias que chamamos de Back-end. Tecnologias como Java, .NET, Rails, PHP são tradicionalmente usadas no Back-end e Alura também possui uma série de carreiras relacionadas com as plataformas de desenvolvimento Back-end.

Segue o link que mostra todas as carreiras disponíveis:

https://cursos.alura.com.br/careers

Bons estudos e fique a vontade para perguntar no fórum sobre como escolher o próximo curso.
