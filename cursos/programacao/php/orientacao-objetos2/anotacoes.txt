################ 1. Autoloading de classes ###############

Autoloading de classes
Vimos que é interessante criar classes para representar os objetos importantes em nosso contexto, como foi o caso do Produto e da Categoria. Assim, encapsulamos as regras de negócio e nosso código fica muito mais organizado. Outra prática importante é manter cada classe em um arquivo separado, assim como fizemos ao criar a classe Produto no arquivo Produto.php e Categoria no arquivo Categoria.php, e ambos dentro da pasta class. Mas com isso vem uma responsabilidade a mais, você precisa lembrar de escrever um include para cada classe que for utilizar.

Em outras palavras, se em um mesmo arquivo precisarmos das classes Produto e Categoria, será necessário incluí-las uma a uma:

<?php require_once("class/Produto.php"); ?>
<?php require_once("class/Categoria.php"); ?>
Ao esquecer de incluir a classe Produto, por exemplo, receberemos um fatal error como a seguir:

Fatal error: Class 'Produto' not found in /Users/turini
    /Desktop/cursophp/loja/banco-produto.php on line 21
Para simplificar esse processo, o PHP 5 introduziu um recurso conhecido como autoload. Você pode criar uma função simples que será executada automaticamente no caso de tentarmos usar uma classe que ainda não tenha sido definida. Um exemplo seria:

function carregaClasse($nomeDaClasse) {
    require_once("class/".$nomeDaClasse.".php");
}
Note que essa é uma função normal, para que ela tenha o sentido especial de autoload precisamos registrá-la:

spl_autoload_register("carregaClasse");
O spl_autoload_register nos permite passar várias implementações de autoload como parâmetro, separadas por vírgula. Dessa forma conseguimos criar estratégias de fallback.

Agora que está devidamente registrada, a função carregaClasse será executada sempre que tentarmos utilizar uma classe não definida. Assim damos ao scripting engine do PHP uma última chance para incluir esse recurso antes que seu código falhe com um fatal error.

################ 2. DAO - Data Access Object ###############

Quando queremos adicionar, remover, listar, ou fazer qualquer outra operação que envolva acesso aos dados da nossa classe Produto, vamos direto para o arquivo banco-produto.php. Isso acontece porque sabemos que essa responsabilidade está centralizada nesse arquivo.
Mesmo sem conhecer orientação a objetos, desde o início do curso escolhemos centralizar todas essas funções que faziam operações no banco de dados. Qual a vantagem? A grande ideia dessa boa prática é que facilita muito a manutenção, já que o desenvolvedor saberá onde procurar queries relacionadas a produtos, categorias, etc. Cada uma em um arquivo distinto.

Além disso, evitamos duplicação de código, já que todas essas funções podem ser reutilizadas em qualquer lugar do nosso projeto, sempre que necessário. Se em algum momento você decidir mudar de banco de dados, não precisa sair alterando todos os pontos do seu código que fazem acesso ao banco, basta mudar o arquivo que centraliza esse comportamento.

Legal, não é? Mas ainda não temos uma solução ideal, já que essas funções estão todas soltas em um arquivo. Agora que estamos trabalhando com orientação a objetos, nada mais justo do que criar uma classe para encapsular esse trabalho.

Uma instância dessa classe será um objeto responsável por acessar os dados de um produto, por isso é uma prática comum chamar esse tipo de classe de DAO (Data Access Object). Esse é um dos mais famosos padrões de projeto (design patterns) utilizados pelas linguagens orientadas a objeto, como PHP, Java e C#.

Vamos criar o nosso ProdutoDao.php dentro da pasta class. Ele pode ficar assim:

class ProdutoDao {

    function listaProdutos($conexao) {

        $produtos = array();
        $resultado = mysqli_query($conexao, "select p.*,c.nome as categoria_nome 
            from produtos as p join categorias as c on c.id=p.categoria_id");

        while($produto_array = mysqli_fetch_assoc($resultado)) {

            $categoria = new Categoria();
            $categoria->setNome($produto_array['categoria_nome']);

            $nome = $produto_array['nome'];
            $descricao = $produto_array['descricao'];
            $preco = $produto_array['preco'];
            $usado = $produto_array['usado'];

            $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
            $produto->setId($produto_array['id']);

            array_push($produtos, $produto);
        }

        return $produtos;
    }

    function insereProduto($conexao, Produto $produto) {

        $query = "insert into produtos (nome, preco, descricao, categoria_id, usado) 
            values ('{$produto->getNome()}', {$produto->getPreco()}, 
                '{$produto->getDescricao()}', {$produto->getCategoria()->getId()}, 
                    {$produto->isUsado()})";

        return mysqli_query($conexao, $query);
    }

    function alteraProduto($conexao, Produto $produto) {

        $query = "update produtos set nome = '{$produto->getNome()}', 
            preco = {$produto->getPreco()}, descricao = '{$produto->getDescricao()}', 
                categoria_id= {$produto->getCategoria()->getId()}, 
                    usado = {$produto->isUsado()} where id = '{$produto->getId()}'";

        return mysqli_query($conexao, $query);
    }

    function buscaProduto($conexao, $id) {

        $query = "select * from produtos where id = {$id}";
        $resultado = mysqli_query($conexao, $query);
        $produto_buscado = mysqli_fetch_assoc($resultado);

        $categoria = new Categoria();
        $categoria->setId($produto_buscado['categoria_id']);

        $nome = $produto_buscado['nome'];
        $descricao = $produto_buscado['descricao'];
        $preco = $produto_buscado['preco'];
        $usado = $produto_buscado['usado'];

        $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
        $produto->setId($produto_buscado['id']);

        return $produto;
    }

    function removeProduto($conexao, $id) {

        $query = "delete from produtos where id = {$id}";

        return mysqli_query($conexao, $query);
    }
}
Veja que todos os métodos dessa classe precisam receber uma conexão para fazer o acesso ao banco. Já que nosso DAO depende de uma conexão para funcionar, podemos usar um pouco mais da orientação a objetos, forçar a passagem de uma conexão como argumento no momento de criarmos o DAO. Como fazer isso? É simples, basta criar um construtor, assim como fizemos para criar um produto já passando os seus atributos.

A classe ficará assim:

<?php 

class ProdutoDao {

    private $conexao;

    function __construct($conexao) {
        $this->conexao = $conexao;
    }

    function listaProdutos() {

        $produtos = array();
        $resultado = mysqli_query($this->conexao, "select p.*,c.nome as categoria_nome 
            from produtos as p join categorias as c on c.id=p.categoria_id");

        while($produto_array = mysqli_fetch_assoc($resultado)) {

            $categoria = new Categoria();
            $categoria->setNome($produto_array['categoria_nome']);

            $nome = $produto_array['nome'];
            $descricao = $produto_array['descricao'];
            $preco = $produto_array['preco'];
            $usado = $produto_array['usado'];

            $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
            $produto->setId($produto_array['id']);

            array_push($produtos, $produto);
        }

        return $produtos;
    }

    function insereProduto(Produto $produto) {

        $query = "insert into produtos (nome, preco, descricao, categoria_id, usado) 
            values ('{$produto->getNome()}', {$produto->getPreco()}, 
                '{$produto->getDescricao()}', {$produto->getCategoria()->getId()}, 
                    {$produto->isUsado()})";

        return mysqli_query($this->conexao, $query);
    }

    function alteraProduto(Produto $produto) {

        $query = "update produtos set nome = '{$produto->getNome()}', 
            preco = {$produto->getPreco()}, descricao = '{$produto->getDescricao()}', 
                categoria_id= {$produto->getCategoria()->getId()}, 
                    usado = {$produto->isUsado()} where id = '{$produto->getId()}'";

        return mysqli_query($this->conexao, $query);
    }

    function buscaProduto($id) {

        $query = "select * from produtos where id = {$id}";
        $resultado = mysqli_query($this->conexao, $query);
        $produto_buscado = mysqli_fetch_assoc($resultado);

        $categoria = new Categoria();
        $categoria->setId($produto_buscado['categoria_id']);

        $nome = $produto_buscado['nome'];
        $descricao = $produto_buscado['descricao'];
        $preco = $produto_buscado['preco'];
        $usado = $produto_buscado['usado'];

        $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
        $produto->setId($produto_buscado['id']);

        return $produto;
    }

    function removeProduto($id) {

        $query = "delete from produtos where id = {$id}";

        return mysqli_query($this->conexao, $query);
    }
}

?>
Excelente. Sempre que criarmos um ProdutoDao, passaremos uma conexão como parâmetro. Essa conexão será mantida como uma propriedade da classe, que pode ser utilizada em todos os seus outros métodos. Como o parâmetro não é opcional, ao esquecer de passar uma conexão como parâmetro, o PHP logo nos lembrará com um erro.

Vamos alterar os lugares que chamavam os métodos de acesso ao banco diretamente, para que no lugar disso passem a utilizar o DAO. O arquivo adiciona-produto.php, por exemplo, tem um if assim:

if (insereProduto($conexao, $produto)) { ?>
Agora, com o DAO, ficará dessa forma:

$produtoDao = new ProdutoDao($conexao);

if($produtoDao->insereProduto($produto)) { ?>
Lembrando que todos os arquivos que instanciarem o ProdutoDao precisam de uma conexão, pois eles precisam passá-la para o construtor mesmo.

Para garantir que sempre teremos uma conexão, podemos fazer o mesmo que fizemos para carregar as classes, podemos importar o arquivo conecta.php no arquivo cabecalho.php. Como todas nossas páginas importam o cabeçalho, todas elas terão a conexão disponível:

<?php
error_reporting(E_ALL ^ E_NOTICE);
require_once("mostra-alerta.php"); 
require_once("conecta.php"); 

function carregaClasse($nomeDaClasse) {
    require_once("class/".$nomeDaClasse.".php");
}

spl_autoload_register("carregaClasse");

?>

<!-- restante do código omitido -->
Com isso não precisamos importar o arquivo conecta.php em nenhuma outra página, então sua importação pode ser removida do restante dos arquivos.

################ 3. Herança ###############

Livro é um tipo de produto que aparece com bastante frequência em nosso estoque, mas estamos deixando um detalhe importante passar. Todo livro precisa ter um número de ISBN (International Standard Book Number), que é seu identificador único. É fundamental manter e exibir essa informação.

Precisamos modificar a tabela produtos, adicionando uma nova coluna para o isbn. Podemos fazer isso acessando o phpMyAdmin e, na aba SQL, executando a seguinte instrução:

ALTER TABLE produtos ADD COLUMN isbn VARCHAR(255);
Vamos adicionar essa propriedade também na classe Produto, assim como seus métodos get e set. O código ficará assim:

class Produto {

    // outras propriedades
    private $isbn;

    // demais métodos

    public function getIsbn() {
        return $this->isbn;
    }

    public function setIsbn($isbn) {
        $this->isbn = $isbn;
    }
}
Ótimo, já temos o novo campo na tabela e na classe. Mas como saber se o produto é um livro ou não? Afinal, só faz sentido manter e exibir o isbn se for um livro. Verificamos se o campo isbn é nulo? Não sabemos o que fazer. Uma forma simples seria adicionar mais uma coluna na tabela produtos, que vai indicar o tipo do produto que estamos trabalhando.

ALTER TABLE produtos ADD COLUMN tipoProduto VARCHAR(255);
Agora, na classe Produto, podemos adicionar a propriedade tipoProduto, assim como seus métodos get e set.

class Produto {

    // outras propriedades
    private $tipoProduto;

    // demais métodos

    public function setTipoProduto($tipoProduto) {
        $this->tipoProduto = $tipoProduto;
    }

    public function getTipoProduto() {
        return $this->tipoProduto;
    }   
}
Como já temos o tipoProduto declarado na classe, como ficamos sabendo se ele é ou não um livro? Podemos fazer um if comparando seu o tipo com "Livro", mas sempre que quisermos saber o tipo de um produto, precisaremos repetir esse mesmo if? Isso não é legal, não é? Duplicar código nunca é. Podemos criar um novo método chamado isLivro, que já faz essa comparação para nós. Assim essa lógica fica encapsulada na classe Produto:

public function isLivro() {
    return $this->tipoProduto === "Livro";
}
Quase pronto, mas para que tudo funcione precisamos alterar os métodos de adicionar, alterar e listar os produtos. Vamos começar com o arquivo produto-formulario-base.php. Nele podemos adicionar mais dois inputs, um para o isbn e outro para o tipoProduto. No tipoProduto podemos fazer algo bem parecido com o que foi feito com as categorias, só que com um array com os tipos do produto. Esse array será percorrido, verificando se o o tipo é igual à classe do produto (sua instância, que representa o seu tipo). Se for igual, esse valor ficará selecionado:

<tr>
    <td>Tipo do produto</td>
    <td>
        <select name="tipoProduto" class="form-control">
            <?php
            $tipos = array("Livro", "Produto");
            foreach($tipos as $tipo) : 
                $esseEhOTipo = get_class($produto) == $tipo;
                $selecaoTipo = $esseEhOTipo ? "selected='selected'" : "";
            ?>
                <option value="<?=$tipo?>" <?=$selecaoTipo?>>
                    <?=$tipo?>
                </option>
            <?php
            endforeach 
            ?>
        </select>
    </td>
</tr>
<tr>
    <td>ISBN (caso seja um Livro)</td>
    <td>
        <input type="text" name="isbn" class="form-control" 
            value="<?=$produto->getIsbn()?>" />
    </td>
</tr>
Agora precisamos modificar o arquivo adiciona-produto.php, chamando o settter desses dois campos novos. A parte que deve mudar ficará assim:

$nome = $_POST['nome'];
$preco = $_POST['preco'];
$descricao = $_POST['descricao'];
$categoria = new Categoria();
$categoria->setId($_POST['categoria_id']);

if(array_key_exists('usado', $_POST)) {
    $usado = "true";
} else {
    $usado = "false";
}

$isbn = $_POST['isbn'];
$tipoProduto = $_POST['tipoProduto'];

$produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
$produto->setIsbn($isbn);
$produto->setTipoProduto($tipoProduto);

$produtoDao = new ProdutoDAO($conexao);

if($produtoDao->insereProduto($produto)) { ?>

// ...
Assim como o altera-produto.php:

$nome = $_POST['nome'];
$preco = $_POST['preco'];
$descricao = $_POST['descricao'];
$categoria = new Categoria();
$categoria->setId($_POST['categoria_id']);

if(array_key_exists('usado', $_POST)) {
    $usado = "true";
} else {
    $usado = "false";
}

$isbn = $_POST['isbn'];
$tipoProduto = $_POST['tipoProduto'];

$produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
$produto->setId($_POST['id']);
$produto->setIsbn($isbn);
$produto->setTipoProduto($tipoProduto);

$produtoDao = new ProdutoDAO($conexao);

if($produtoDao->alteraProduto($produto)) { ?>

// ...
Por fim, vamos mudar as funções insereProduto, alteraProduto, listaProdutos e buscaProduto do nosso ProdutoDAO. No momento de inserir e alterar, vamos mudar o SQL adicionando os dados das colunas isbn e tipoProduto:

function insereProduto(Produto $produto) {

    $query = "insert into produtos (nome, preco, descricao, categoria_id, 
        usado, isbn, tipoProduto) values ('{$produto->getNome()}', 
            {$produto->getPreco()}, '{$produto->getDescricao()}', 
                {$produto->getCategoria()->getId()}, {$produto->isUsado()}, 
                    '{$produto->getIsbn()}', '{$produto->getTipoProduto()}')";

    return mysqli_query($this->conexao, $query);
}

function alteraProduto(Produto $produto) {

    $query = "update produtos set nome = '{$produto->getNome()}', 
        preco = {$produto->getPreco()}, descricao = '{$produto->getDescricao()}', 
            categoria_id= {$produto->getCategoria()->getId()}, 
                usado = {$produto->isUsado()}, isbn = '{$produto->getIsbn()}', 
                    tipoProduto = '{$produto->getTipoProduto()}' 
                        where id = '{$produto->getId()}'";

    return mysqli_query($this->conexao, $query);
}
Na listagem, basta chamar o setter desses dois campos:

function listaProdutos() {

    $produtos = array();
    $resultado = mysqli_query($this->conexao, "select p.*,c.nome as categoria_nome 
        from produtos as p join categorias as c on c.id=p.categoria_id");

    while($produto_array = mysqli_fetch_assoc($resultado)) {

        $id = $produto_array['id'];
        $nome = $produto_array['nome'];
        $preco = $produto_array['preco'];
        $descricao = $produto_array['descricao'];
        $categoria = new Categoria();
        $categoria->setNome($produto_array['categoria_nome']);
        $usado = $produto_array['usado'];
        $isbn = $produto_array['isbn'];
        $tipoProduto = $produto_array['tipoProduto'];

        $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
        $produto->setId($id);
        $produto->setIsbn($isbn);
        $produto->setTipoProduto($tipoProduto);

        array_push($produtos, $produto);
    }

    return $produtos;
}
Assim como na busca:

function buscaProduto($id) {

    $query = "select * from produtos where id = {$id}";
    $resultado = mysqli_query($this->conexao, $query);
    $produto_buscado = mysqli_fetch_assoc($resultado);

    $categoria = new Categoria();
    $categoria->setId($produto_buscado['categoria_id']);

    $nome = $produto_buscado['nome'];
    $descricao = $produto_buscado['descricao'];
    $preco = $produto_buscado['preco'];
    $usado = $produto_buscado['usado'];
    $isbn = $produto_buscado['isbn'];
    $tipoProduto = $produto_buscado['tipoProduto'];

    $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
    $produto->setId($produto_buscado['id']);
    $produto->setIsbn($isbn);
    $produto->setTipoProduto($tipoProduto);

    return $produto;
}
Quase pronto, agora só falta adicionar a nova coluna no arquivo produto-lista.php.

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td><?= $produto->precoComDesconto() ?></td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
    <td><?= $produto->getCategoria()->getNome() ?></td>
    <td> ISBN: <?= $produto->getIsbn() ?></td>
    <!-- continuação do código -->
Parece tudo certo, mas ao testar:



Veja que a tabela quebrou na segunda linha. O seguinte erro foi exibido no terminal:

/loja/produto-lista.php - Call to undefined method 
    Produto::getIsbn() in /Users/turini/Desktop/cursophp
    /loja/produto-lista.php on line 17
Faz sentido, afinal só podemos chamar o getIsbn de um Livro, o Produto não tem esse método. E agora?

Já criamos o método isLivro para nos ajudar nesse trabalho, lembra? Só precisamos de um if chamando esse método condicionando a chamada do getIsbn:

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td><?= $produto->precoComDesconto() ?></td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
    <td><?= $produto->getCategoria()->getNome() ?></td>
    <td>
        <?php 
            if ($produto->isLivro()) {
                echo "ISBN: ".$produto->getIsbn();
            }
        ?>
    </td>
    <!-- continuação do código -->
Vamos testar? Podemos adicionar um novo livro chamado Livro PHP e MySQL, com preço 29.90, uma descrição qualquer e isbn 978-85-66250-30-5. Ao abrir a listagem:



Sucesso, a nova coluna com o número de ISBN foi adicionada, apenas no produto que é do tipo Livro. Mas será que essa forma que fizemos é a melhor opção?

Herança entre classes
Nosso código está funcionando, mas o problema dessa nossa alternativa é que agora temos o isbn para todos os produtos. É totalmente possível alguém esquecer de chamar o método isLivro e chamar o getIsbn para um produto que não é livro. Estranho, não é?

Em outras palavras, o problema é que a classe Produto agora tem propriedades e métodos que só dizem respeito aos produtos do tipo Livro. Se Livro é tão importante e tem informações e características próprias, nada mais justo do que criar uma classe para representar esse tipo especial de produto. Em orientação a objetos, podemos e devemos criar classes para representar os elementos importantes de nosso contexto, como é o caso do Produto, da Categoria e agora do Livro.

Vamos tirar os atributos isbn e tipoProduto, assim como seus getters e setters, da classe Produto, já que essa classe deve manter o estado e comportamento apenas do que for válido para todos os tipos de produto. O isbn será agora propriedade de uma nova classe, que vamos chamar de Livro:

class Livro {

    private $isbn;

    public function getIsbn() {
        return $this->isbn;
    }

    public function setIsbn($isbn) {
        $this->isbn = $isbn;
    }
}
Perfeito! Mas espera um pouco, um objeto do tipo Livro também vai precisar de um nome, preco, descricao e todas as outras propriedades que já existem na classe Produto. Afinal, livro é um produto. Uma forma de resolver esse problema seria copiando e colando as propriedades e métodos, mas veja como o código fica repetitivo!

class Livro {

    private $id;
    private $nome;
    private $preco;
    private $descricao;
    private $categoria;
    private $usado;
    private $isbn;

    public function getIsbn() {
        return $this->isbn;
    }

    public function setIsbn($isbn) {
        $this->isbn = $isbn;
    }

    // todos os outros métodos, getters e setters
}
Além disso, se tivéssemos mais outro tipo de produto que tem características diferentes do produto comum, seria necessário criar uma outra classe e copiar todo esse código novamente! Imagine como seria trabalhoso evoluir o código, ao adicionar uma propriedade na classe Produto, teríamos que lembrar de replicar essa mudança em todos os outros tipos de produto.

Em orientação a objetos, há uma forma muito mais elegante de resolver esse problema. Podemos relacionar as classes Produto e Livro, dizendo que um Livro tem tudo (herda) o que a classe Produto tiver. Podemos dizer que um Livro é uma extensão de Produto.

class Livro extends Produto {

    private $isbn;

    public function getIsbn() {
        return $this->isbn;
    }

    public function setIsbn($isbn) {
        $this->isbn = $isbn;
    }
}
Com isso, estamos estabelecendo uma relação de classe mãe (superclasse) e classe filha (subclasse), que neste caso são ,respectivamente, Produto e Livro. A partir do momento que dissemos que um Livro é um (extends) Produto, podemos chamar qualquer método que tenha sido declarado na classe Produto a partir de uma instância de Livro. Veja um exemplo:

$livro = new Livro("Livro de PHP e MySQL", "", "", new Categoria(), "");

echo "O nome é ". livro->getNome();
Mesmo sem ter esses métodos diretamente declarados em sua classe, uma instância de livro pode usar os getters e setters de todas as propriedades declaradas em sua superclasse Produto.

Um detalhe importante é que não existe herança multipla em PHP, isso significa que você só pode herdar de uma única classe. Claro, isso não te impede de encadear heranças, ou seja, herdar de uma classe que herda de outra. Uma classe pode ter várias filhas, mas pode ter apenas uma mãe.

O mau uso da herança
Herança é um recurso bastante interessante e que pode trazer uma série de benefícios para nosso projeto, mas cuidado para não abusar desse recurso. Imagine que a classe Pessoa tenha um ou mais comportamentos em comum com a classe Produto. Fazemos com que Produto herde de Pessoa para aproveitar esses métodos? Isso não seria nem um pouco interessante, já que Pessoa tem nome e outras propriedades que não fazem sentido para Produto. No contexto real, um produto não é uma pessoa. Por que em nosso código seria?

Vamos colocar essa mudança em prática? Podemos começar pelo produto-formulario-base.php, o value do input do ISBN está invocando o getIsbn, mas ele agora só existe se o produto for um Livro, então temos que colocar essa condição:

<tr>
    <td>ISBN (caso seja um Livro)</td>
    <td>
        <input type="text" name="isbn" class="form-control"
            value="<?php if ($produto->isLivro()) { echo $produto->getIsbn(); } ?>" />
    </td>
</tr>
Podemos começar pela adição de produtos. No arquivo adiciona-produto.php, podemos fazer um if para verificar o tipo do produto. Assim, damos new no Livro e setamos o isbn quando houver, ou damos new em Produto nas demais situações. O código pode ficar assim:

$nome = $_POST['nome'];
$preco = $_POST['preco'];
$descricao = $_POST['descricao'];
$categoria = new Categoria();
$categoria->setId($_POST['categoria_id']);
$isbn = $_POST['isbn'];
$tipoProduto = $_POST['tipoProduto'];

if(array_key_exists('usado', $_POST)) {
    $usado = "true";
} else {
    $usado = "false";
}

if ($tipoProduto == "Livro") {
    $produto = new Livro($nome, $preco, $descricao, $categoria, $usado);
    $produto->setIsbn($isbn);
} else {
    $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
}

$produtoDao = new ProdutoDAO($conexao);

if($produtoDao->insereProduto($produto)) { ?>

// ...
Já podemos testar. Primeiro vamos adicionar um produto do tipo Livro, com o isbn preenchido. O produto deve ser adicionado conforme esperado. Ótimo! Mas ao testar adicionar um produto que não seja Livro, recebemos o seguinte erro:

Call to undefined method Produto::getIsbn() 
    in /Users/turini/Desktop/cursophp/loja/
    banco-produto.php on line 36
Ops, estamos chamando o método getIsbn sempre, independente se o produto é ou não um Livro! Vamos corrigir, antes de escrever a query, basta verificar se o tipo do parâmetro $produto tem isbn. Mas e para pegar o tipo do produto? Não temos mais o método getTipoProduto. Para isso, basta pegar a classe do produto, através do método get_class, passando o produto por parâmetro:

function insereProduto(Produto $produto) {

    $isbn = "";
    if ($produto->temIsbn()) {
        $isbn = $produto->getIsbn();
    }

    $tipoProduto = get_class($produto);

    $query = "insert into produtos (nome, preco, descricao, categoria_id, 
        usado, isbn, tipoProduto) values ('{$produto->getNome()}', 
            {$produto->getPreco()}, '{$produto->getDescricao()}', 
                {$produto->getCategoria()->getId()}, {$produto->isUsado()}, 
                    '{$isbn}', '{$tipoProduto}')";

    return mysqli_query($this->conexao, $query);
}
Fazemos a mesma coisa no método de alteração:

function alteraProduto(Produto $produto) {

    $isbn = "";
    if ($produto->temIsbn()) {
        $isbn = $produto->getIsbn();
    }

    $tipoProduto = get_class($produto);

    $query = "update produtos set nome = '{$produto->getNome()}', 
        preco = {$produto->getPreco()}, descricao = '{$produto->getDescricao()}', 
            categoria_id= {$produto->getCategoria()->getId()}, 
                usado = {$produto->isUsado()}, isbn = '{$isbn}', 
                    tipoProduto = '{$tipoProduto}' 
                        where id = '{$produto->getId()}'";

    return mysqli_query($this->conexao, $query);
}
Mas sem nos esquecer de também alterar o altera-produto.php:

$id = $_POST['id'];
$nome = $_POST['nome'];
$preco = $_POST['preco'];
$descricao = $_POST['descricao'];
$categoria = new Categoria();
$categoria->setId($_POST['categoria_id']);
$isbn = $_POST['isbn'];
$tipoProduto = $_POST['tipoProduto'];

if(array_key_exists('usado', $_POST)) {
    $usado = "true";
} else {
    $usado = "false";
}

if ($tipoProduto == "Livro") {
    $produto = new Livro($nome, $preco, $descricao, $categoria, $usado);
    $produto->setIsbn($isbn);
} else {
    $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
}

$produto->setId($id);

$produtoDao = new ProdutoDAO($conexao);

if($produtoDao->alteraProduto($produto)) { ?>

// ...
O método temIsbn precisa verificar se o produto em questão é uma instância de Livro. Podemos fazer isso com o instanceof. Vamos remover o isLivro e fazer:

class Produto {

    // todo o código omitido

    function temIsbn() {
        return $this instanceof Livro;
    }
}
Teste mais uma vez para garantir que tudo está funcionando. Perfeito, agora conseguimos adicionar, mas e a listagem? Ao tentar acessá-la, recebemos um erro:

::1:56458 [500]: /loja/produto-lista.php - 
    Call to undefined method Produto::setTipoProduto() 
    in /Users/turini/Desktop/cursophp/loja/banco-produto.php 
    on line 23
Faz sentido, ainda não mudamos o método listaProdutos. Precisamos instanciar um Livro, se o seu tipo for um "Livro", ou Produto no caso contrário. O código ficará bem parecido com o que já fizemos. Algo como:

function listaProdutos() {

    $produtos = array();
    $resultado = mysqli_query($this->conexao, "select p.*,c.nome as categoria_nome 
        from produtos as p join categorias as c on c.id=p.categoria_id");

    while($produto_array = mysqli_fetch_assoc($resultado)) {

        $id = $produto_array['id'];
        $nome = $produto_array['nome'];
        $preco = $produto_array['preco'];
        $descricao = $produto_array['descricao'];
        $categoria = new Categoria();
        $categoria->setNome($produto_array['categoria_nome']);
        $usado = $produto_array['usado'];
        $isbn = $produto_array['isbn'];
        $tipoProduto = $produto_array['tipoProduto'];

        if ($tipoProduto == "Livro") {
            $produto = new Livro($nome, $preco, $descricao, $categoria, $usado);
            $produto->setIsbn($isbn);
        } else {
            $produto = new Produto($nome, $preco, $descricao, $categoria, $usado);
        }

        $produto->setId($id);

        array_push($produtos, $produto);
    }

    return $produtos;
}
Tudo certo, mas ainda falta atualizar o HTML. Não podemos mais fazer aquele if com o isLivro, já que esse método não existe mais. No lugar disso vamos usar o método temIsbn, lá no produto-lista.php:

<td>
    <?php 
        if ($produto->temIsbn()) {
            echo "ISBN: ".$produto->getIsbn();
        }
    ?>
</td>
E no produto-formulario-base.php;

<tr>
    <td>ISBN (caso seja um Livro)</td>
    <td>
        <input type="text" name="isbn" class="form-control"
            value="<?php if ($produto->temIsbn()) { echo $produto->getIsbn(); } ?>" />
    </td>
</tr>
Perfeito, mas o nosso código ainda precisa de alguns ajustes, faremos no exercício, ok?

Vamos colocar isso tudo em prática?

Acoplamento
Essa é uma discussão um pouco mais avançada, mas desde já perceba que o uso de herança aumenta o acoplamento entre as classes, isto é, o quanto uma classe depende de outra. Como há uma relação muito forte entre a classe mãe e filha, acaba sendo necessário conhecermos muitos dos detalhes de implementação da classe mãe para que tudo funcione como esperado. E o problema vai além, imagine que um certo dia a classe mãe adicione um método com o nome igual a um que já existe na classe filha. Quando alguém chamar esse método, esperando o comportamento definido na classe mãe, poderá na verdade estar chamando o da classe filha. Isso pode bagunçar toda a lógica. Em outras palavras, a classe mãe também precisa conhecer detalhes de implementação de suas filhas - que podem ainda nem existir.

Veremos mais à frente alguns outros recursos que nos ajudam a resolver esse problema.

Sobre herança em PHP, julgue as seguintes afirmativas:
1) Uma classe pode ter várias filhas, mas pode ter apenas uma mãe.

2) A partir de uma instância de uma classe filha, podemos chamar qualquer método público que tenha sido declarado na classe mãe.

3) Na classe filha, podemos escolher o que herdar da classe mãe.

4) No exemplo abaixo, Cachorro também herda tudo da classe Animal:

class Animal {
    // atributos e métodos
}

class Mamifero extends Animal {
    // atributos e métodos
}

class Cachorro extends Mamifero {
    // atributos e métodos
}
Quais das afirmativas estão corretas?

Apenas as alternativas 1, 2 e 4 estão corretas.
 
Pode-se sim chamar qualquer método da classe mãe. Uma classe pode ter diversas "filhas e netas" (que herdam umas das outras) mas não podemos escolher o que será herdado.

Qual a diferença entre private e protected?

Só a própria classe enxerga atributos/métodos private, enquanto protected é visto pela própria classe mais as classes filhas.

Temos umas classe Funcionario e outra Gerente, que é um funcionário, ou seja, temos uma relação de herança:
class Funcionario {

    private $nome;
    private $salario;

    function __construct($nome, $salario) {
        $this->nome = $nome;
        $this->salario = $salario;
    }

    public function getNome() {
        return $this->nome;
    }

    public function getSalario() {
        return $this->salario;
    }

}

class Gerente extends Funcionario {

    private $senhaDoSistema;

    public function getSenhaDoSistema() {
        return $this->senhaDoSistema;
    }

    public function setSenhaDoSistema($senhaDoSistema) {
        $this->senhaDoSistema = $senhaDoSistema;
    }

    public function imprimeGerente() {
        echo $this->nome;
    }
}
E na hora de instanciar e exibir um Gerente, o desenvolvedor do sistema implementou o seguinte código:

$gerente = new Gerente("José", 7000);
$gerente->imprimeGerente();
Utilizando o seu conhecimento de herança adquirido neste capítulo, responda a seguinte pergunta: o código acima é funcional?

Não.
 
O código não funciona por que o atributo nome é privado.

O código não funciona. Porque?
Quando o atributo é privado, ele só pode ser acessado na classe em que ele foi declarado. Ou seja, o atributo nome só é acessível na classe Funcionario. O problema deste código está no método imprimeGerente(), da classe Gerente:

public function imprimeGerente() {
    echo $this->nome;
}
Como o Gerente não tem acesso ao atributo nome, o código gera um erro. Nesse caso, temos duas soluções:

1) Utilizamos o método acessor getNome():

public function imprimeGerente() {
    echo $this->getNome();
}
2) Mudamos o modificador de acesso do atributo nome para protected:

class Funcionario {

    protected $nome;

    // restante do código
}
Um atributo protected pode ser acessado pela própria classe e por suas filhas. Mas aí cabe a discussão, sempre devemos usar o protected?

O ideal é nunca afrouxar o encapsulamento do atributo por causa da herança, então dê sempre preferência aos métodos acessores, afinal é justamente essa a finalidade deles, uma classe poder acessar um atributo no qual ela não tem acesso.

################ 4. Reescrita e Polimorfismo ###############

Precisamos exibir mais uma informação em nossa listagem de produtos, que é o valor de imposto de cada um deles. A regra é bem simples, o imposto do produto é equivalente a 19,5% de seu valor. Podemos calcular isso na própria listagem, no lugar de onde era calculado o desconto, como por exemplo:

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td><?= $produto->getPreco() * 0.195 ?></td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
    <td><?= $produto->getCategoria()->getNome() ?></td>

    <!-- restante do html omitido -->
Mas já vimos que expor nossa regra de negócio dessa forma não é legal, seria muito mais interessante encapsular esse comportamento em um método. Assim evitamos duplicação de código e facilitamos a manutenção e evolução desse comportamento.

Vamos criar o método calculaImposto na classe Produto:

public function calculaImposto() {
    return $this->preco * 0.195;
}
Perfeito, para testar vamos mudar nosso produto-lista.php para mostrar o valor do imposto com esse novo método:

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td><?= $produto->calculaImposto() ?></td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
    <td><?= $produto->getCategoria()->getNome() ?></td>

    <!-- restante do html omitido -->
Mas há uma nova regra. Quando o produto for um livro, seu desconto será de 6.5%. Se deixarmos o código como está, um livro terá o desconto de 19.5%, já que um livro é um produto, ou seja, herda esse comportamento. Como corrigir isso?

Dentre algumas outras formas, poderíamos criar um outro método na classe Livro, chamado calculaImpostoDeLivro, e fazer um if no HTML para chamar esse método caso o produto iterado seja do tipo Livro. O código ficaria parecido com:

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td>
        <?php 
            if ($produto->temIsbn()) {
                echo $produto->calculaImpostoDeLivro();
                // calcula 6.5% de imposto
            } 
            else {
                echo $produto->calculaImposto();
                // calcula 19.5% de imposto
            }
        ?>
    </td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>

    <!-- restante do html omitido -->
Mas além de confundir a todos que forem usar esse método, precisaríamos lembrar de escrever esse if sempre que fosse necessário saber o desconto do produto. Não parece uma solução ideal. Além disso, já pensou em como ficaria esse código conforme novos tipos de produto com regras de imposto diferentes forem aparecendo? Um caos.

O que queremos na verdade é modificar o comportamento herdado da superclasse. Podemos reescrever (ou sobrescrever, como também é comumente dito) todo comportamento que não quisermos herdar diretamente. É bem simples, basta criar o mesmo método (com a mesma assinatura) na classe Livro:

class Livro extends Produto {

    private $isbn;

    function getIsbn() {
        return $this->isbn;
    }

    function setIsbn($isbn) {
        $this->isbn = $isbn;
    }

    public function calculaImposto() {
        return $this->preco * 0.065;
    }
}
Mas ainda há um problema. Ao executar esse código receberemos o seguinte erro:

Undefined property: Livro::$preco in 
    /Users/turini/Desktop/cursophp/loja
    /Livro.php on line 9
Mas espera ai, o livro não tem preço? A resposta é sim, livro herda o atributo preço da classe Produto, porém não consegue acessá-lo dessa forma, afinal se trata de um atributo privado. E agora, precisamos mudar preço para public? Não precisamos e nem devemos quebrar o encapsulamento de nossas classes por causa disso. Há duas formas de resolver, uma delas seria modificando a visibilidade do preco para protected, na classe Produto:

class Produto {

    private $id;
    private $nome;
    protected $preco;
    private $descricao;
    private $categoria;
    private $usado;

    // restante do código
}
O protected é um meio termo entre public e private, onde apenas a classe e também as subclasses podem acessar o atributo. Assim o código já funcionará como estamos esperando. Mas e quanto à outra alternativa?

É ainda mais simples, basta não acessar a propriedade da classe mãe diretamente. Você pode consultar o preço do produto utilizando a interface pública da classe, isto é, seus métodos. No lugar de fazer:

public function calculaImposto() {
    return $this->preco * 0.065;
}
Podemos utilizar o getter:

public function calculaImposto() {
    return $this->getPreco() * 0.065;
}
Perfeito! Agora temos o mesmo resultado, mesmo mantendo a propriedade preco como private. Sempre prefira usar a interface pública da classe (getters, setters e outros métodos públicos) ao invés de afrouxar a regra do encapsulamento com a visibilidade protected, ainda que apenas as classes filhas acessem. Idealmente apenas a própria classe deveria acessar e modificar seu estado diretamente.

Vamos testar a alteração? Basta abrir a listagem. Agora os valores estão sendo calculados conforme esperamos, 6.5% para livros e 19.5% para os demais produtos.

Invocando métodos da superclasse
Você sempre pode utilizar a palavra reservada parent para invocar métodos estáticos da superclasse. Por exemplo, imagine que o imposto de um Livro precise ser o dobro do imposto da classe Produto. Até poderíamos ver o valor escrito no método da classe mãe e escrever o dobro dele na classe filha, mas e quando o valor da classe mãe atualizar? Precisaríamos lembrar de atualizar a classe filha. Não vai acontecer.

E que tal fazer assim:

class Livro extends Produto {

    private $isbn;

    // getIsbn e setIsbn

    function calculaImposto() {
        return parent::calculaImposto() * 2;
    }
}
Problema resolvido, com isso o imposto da classe Livro será o resultado do calculaImposto da classe Produto, que é o parent, multiplicado por dois.

Polimorfismo
Perceba que apesar de estarmos chamando o mesmo método na página, ele tem um comportamento diferente de acordo com o tipo da classe que foi instanciada, seja um Produto ou Livro. Sem esse recurso, seria necessário encadear uma série de ifs, um para cada tipo. O código ficaria parecido com:

<tr>
    <td><?= $produto->getNome() ?></td>
    <td><?= $produto->getPreco() ?></td>
    <td><?= substr($produto->getDescricao(), 0, 40) ?></td>
    <td>
        <?php 
            if ($produto->temIsbn()) {
                // calcula 6.5% de imposto
            }
            if ($produto->algumaOutraCoisa()) {
                // calcula 12% de imposto
            } else {
                // calcula 19.5% de imposto
            }
        ?>
    </td>

    <!-- restante do html omitido -->
A pior parte é que a cada novo tipo de produto, precisaríamos mudar esse código, adicionando mais um if. Isso seria um pesadelo, desde a verbosidade dessas várias linhas de código, complexidade, legibilidade, etc. Tudo isso reflete diretamente na manutenibilidade do código.

Agora veja da forma que está, com uma única chamada ao método calculaImposto. Dessa forma estamos aproveitamos a estrutura do objeto, que com certeza é um Produto, mas mudando apenas o que for preciso em suas implementações.

<td><?= $produto->calculaImposto() ?></td>
O PHP sempre vai procurar pelo método na classe mais específica, que foi instanciada com o new. Na ausência desse método, aí sim ele vai procurar na classe mãe. A ordem é sempre essa. Apesar de parecer algo muito simples, isso nos possibilita economizar montanhas de códigos como aqueles ifs todos que vimos. Esse recurso é conhecido como polimorfismo, que é a capacidade de um objeto poder ser referenciado de várias formas.

O que acontece se executarmos o código abaixo?
class Conta {

    private $numero;
    private $saldo;

    public function getSaldo() {
        return $this->saldo;
    }

    public function setSaldo($saldo) {
        $this->saldo = $saldo;
    }

    public function saca($valor) {
        $this->setSaldo($this->getSaldo() - $valor);
    }

    public function deposita($valor) {
        $this->setSaldo($this->getSaldo() + $valor);
    }

}

class ContaPoupanca extends Conta {

    public function saca($valor) {
        $this->setSaldo($this->getSaldo() - ($valor + 0.10));
    }
}

$conta1 = new ContaPoupanca();
$conta1->deposita(100.0);
$conta1->saca(50.0);
echo "Conta Poupança = ".$conta1->getSaldo();

$conta2 = new Conta();
$conta2->deposita(100.0);
$conta2->saca(50.0);
echo "Conta = ".$conta2->getSaldo();

Conta Poupança = 49.9 e Conta = 50
 
Como $conta1 é uma Conta Poupança, será descontado 0.10 ao realizar um saque. Isso não acontece com a Conta normal.

class Animal {

    public $nome;

    function __construct($nome) {
        $this->nome = $nome;
    }

    function falar() {
        return "Grrr...";
    }
}

class Cachorro extends Animal {

    function falar() {
        return "AU, AU!";
    }
}

class Gato extends Animal {

    function falar() {
        return "Miau!";
    }
}

class Boi extends Animal {

}

$animais = array(new Cachorro('Snoopy'), new Gato('Garfield'), new Boi("Flocos"));

foreach($animais as $animal) {
    print $animal->nome . " disse: " . $animal->falar() . '<br>';
}
Marque a alternativa que representa corretamente a fala de cada animal!

Snoopy disse: AU, AU!
Garfield disse: Miau!
Flocos disse: Grrr...
 
Quando estamos utilizando o polimorfismo no PHP, ele sempre tentará utilizar o método mais específico disponível nas classes filhas. No caso do nosso Gato e Cachorro, ambos possuem o método falar(), mas a classe Boi não! Por isso ela recorrerá ao método falar() da classe mãe, o que faz com que neste caso a saída seja:
Snoopy disse: AU, AU!
Garfield disse: Miau!
Flocos disse: Grrr...




