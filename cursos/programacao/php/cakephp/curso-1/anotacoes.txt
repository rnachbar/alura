############### 1. Introdução ###############

Sejam bem-vindos ao curso de Cake PHP! Aqui iremos desenvolver um sistema de estoque onde poderemos: cadastrar, alterar, remover e listar produtos, autenticar um usuário e muito mais! Para facilitar esse processo utilizaremos uma ferramenta MVC, o Cake PHP!
Nós trabalharemos com a versão 3.x do framework e, para a utilizar, precisaremos fazer a instalação na nossa máquina. Existem várias formas para tal, mas aqui utilizaremos o Composer, que é um gerenciador de dependências. Executemos o seguinte comando no Terminal:

composer create-project --prefer-dist cakephp/app [app_name]
Lembre-­se que este processo pode demorar um pouco, pois o Composer buscará todas as dependências do nosso projeto. Quando o processo terminar devemos ter uma nova pasta chamada "estoque". Essa pasta possui todos os arquivos do projeto. Agora precisamos iniciar a nossa aplicação, para isso precisamos subir um servidor PHP com este comando:

php ­S localhost:8080
Porém, como estamos utilizando um framework, precisamos subir um servidor com a configuração que o framework exige. Basta executar o comando

bin/cake server
Se tudo der certo, deveremos ver a seguinte mensagem:

Welcome to CakePHP v3.0.10 Console
­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­App : src
Path: /home/renan/Desktop/cursocake/arquivo­curso/src/
DocumentRoot: /home/renan/Desktop/cursocake/arquivo­curso/webroot ­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­ built­in server is running in http://localhost:8765/
You can exit with `CTRL­C`
Ao acessarmos a URL "localhost:8765" deverá aparecer a homepage do Cake PHP falando que deu tudo certo. Mas ao acessar tal página, o que realmente aconteceu? Quando acessamos um endereço, o Cake PHP procura uma lógica para ser executada, nós conseguimos representar essa lógica com um Controller, que por sua vez possui diversas ações e, por fim, a ação executada retorna uma visualização (HTML). O padrão do Cake PHP é o Controller Pages, o qual executa a ação display, que devolve a visualização "home.ctp".

A página inicial é um exemplo, mas o que queremos mesmo é criar a nossa própria página. Inicialmente precisamos de alguém que execute a lógica que exibe a nossa página, um Controller. Criar um Controller no Cake PHP é muito simples, basta criar um arquivo dentro da pasta "src/controller". Porém o nome do nosso arquivo precisa seguir uma convenção que é "NomeDoQueIremosControlarController". Por exemplo, se queremos criar um Controller que controla produtos, o nome do nosso arquivo será "ProdutosController". O conteúdo do nosso arquivo é uma classe com o mesmo nome do arquivo e, como todo Controller herda de AppController, a nossa classe não será diferente:

namespace App\Controller;

class ProdutosController extends AppController {

}
Se tentarmos acessar a URL "localhost:8765/produtos" vamos receber um erro, falando que a ação index não está definida. A primeira ação (método) que o Cake procura quando não definimos nada é a ação index, para corrigir esse problema adicionamos tal método no nosso Controller:

namespace App\Controller;
class ProdutosController extends AppController {

    public function index() {

    }

}
Já temos a ação, mas não definimos em nenhum lugar qual é o HTML que será definido. Precisamos criar um arquivo dentro de "Template/Produtos/" chamado "index.ctp". Perceba que só pelo nome do Controller e da ação ele consegue adivinhar qual é o arquivo.

<h1>Bem vindos ao cake</h1>
Agora sim, quando atualizamos a página, podemos ver a mensagem “Bem vindos ao cake” e, mais do que isso, um título azul apareceu na nossa página. Mas de onde que esse código veio ? O Cake possui um layout padrão que está em "Template/Layout/default.ctp". Se precisarmos de um menu que está disponível no sistema inteiro, podemos escrevê-lo apenas uma vez no arquivo "default.ctp". A nossa página funciona, mas temos um texto estático. Para mandar uma mensagem do Controller para a View criamos a variável no Controller que acessa a View:

public function index() {

    $msg = “Bem vindo ao curso de cake”;

}
E no "index.ctp":

<h1><?= $msg; ?></h1>
É fácil acreditar que este código funciona, porém o Cake PHP limita o escopo das nossas variáveis, tudo que criamos no Controller está disponível apenas no Controller. Mas podemos quebrar essa regra usando o método set() da Classe Controller.

public function index() {
    $msg = “Bem vindo ao curso de cake”;

    $this­>set(‘msg’,$msg);

}
Agora sim o nosso código funciona, veja que o método set() recebe dois parâmetros: o primeiro é o nome da variável que desejamos na View e o segundo é o seu conteúdo.

Essa foi a introdução ao framework Cake PHP. Até a próxima aula!

Para desenvolver o nosso projeto iremos utilizar um framework (cake-php) por que essa decisão foi tomada ? Qual é o papel de um framework no processo de desenvolver um software ?

Decidimos usar um framework pois isso nos permite desenvolver a aplicação se preocupando mais com as regras de negócio do que com qualquer código de infraestrutura.Portanto frameworks nos fornece uma camada de abstração que encapsula o código que não precisamos saber como funciona ou códigos que escreveriamos diversas vezes, como por exemplo pegar parâmetros da url, encontrar o método que será executado e até mesmo separar a camada de visualização da nossa lógica.

Quais são as consequencias de utilizar um framework ? Na sua opinião qual é a principal desvantagem ?

Frameworks nos ajudam padronizando código, o que torna o desenvolvimento mais ágil. Bons frameworks costumam ser bem seguros e, quando usados corretamente, possuem uma boa performance. Porém, nem tudo é um mar de rosas: os frameworks também levam um certo tempo para aprender e podem viciar o programador a só desenvolver utilizando o framework .

############### 2. Listando Produtos ###############

No capítulo anterior aprendemos a gerar uma parágrafo dinamicamente, mas na prática isso não resolve o nosso problema. Nós queremos listar produtos, então vamos começar a trabalhar nisso. A nossa listagem, que hoje tem apenas um título, deve virar uma tabela, portanto vamos editar o nosso arquivo "index.ctp" para ter uma tabela no lugar de um cabeçalho:
<table class=”table”>
    <thead>
        <tr>
            <th>Id</th>
            <th>Nome</th>
            <th>Preço</th>
            <th>Descrição</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td>1</td>
            <td>Hd de 20 gigas</td>
            <td>29.99</td>
            <td>Hd muito bom da marca mega­HD</td>
        </tr>
    </tbody>
</table>
Se atualizarmos o navegador teremos a nossa tabela, porém ela continua estática. Para resolver isso precisamos enviar os produtos pelo Controller, então representaremos o nosso produto como um array e utilizando o método set() para mandar a variável para a View:

public function index() {
    $produto = [“id”=> 1, “nome” => “Hd de 20 gigas”, “descricao” => “Hd muito bom da marca mega­HD”,”preco” => 29.99];

    $this­>set(‘produto’,$produto);
}
E no "index.ctp":

<table class=”table”>
    <thead>
        <tr>
            <th>Id</th>
            <th>Nome</th>
            <th>Preço</th>
            <th>Descrição</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><?= $produto[‘id’]; ?></td>
            <td><?= $produto[‘nome’]; ?></td>
            <td><?= $produto[‘preco’]; ?></td>
            <td><?= $produto[‘descricao’]; ?></td>
        </tr>
    </tbody>
</table>
O código só funciona para um produto. Precisamos criar um array para que funcione com vários:

public function index() {

    $produtos = [];
    $produtos[] = [“id”=> 1, “nome” => “Hd de 20 gigas”, “descricao” => “Hd muito bom da marca mega­HD”,”preco” => 29.99];
    $produtos[] = [“id”=> 1, “nome” => “Hd de 80 gigas”, “descricao” => “Hd muito bom da marca mega­HD Extreme”,”preco” => 129.99];
    $this­>set(‘produtos’,$produtos);
}
E no "index.ctp":

<table class=”table”>
    <thead>
        <tr>
            <th>Id</th>
            <th>Nome</th>
            <th>Preço</th>
            <th>Descrição</th>
        </tr>
    </thead>

    <tbody>
    <?php foreach($produtos as $produto) {
        <tr>
            <td><?= $produto[‘id’]; ?></td>
            <td><?= $produto[‘nome’]; ?></td>
            <td><?= $produto[‘preco’]; ?></td>
            <td><?= $produto[‘descricao’]; ?></td>
        </tr>
    } ?>
    </tbody>
</table>
O nosso código funciona, mas não queremos preencher todos os dados no nosso Controller. Queremos pegar essas informações de um banco de dados, nesse curso utilizaremos o MySQL. Caso já possuam este banco instalado, abra o Terminal e digite:

mysql -­uroot -­p
Se tudo der certo, já estaremos conectados ao banco de dados. Agora precisamos criar a base que usaremos neste projeto, para isso usamos o comando:

create database estoque;
Indicamos para o MySQL que queremos executar todos os próximos comandos em cima dessa base "estoque", portanto vamos executar o seguinte comando:

use estoque;
Ainda precisamos criar a tabela que irá salvar os produtos:

create table produtos (
id int(11) not null primary key auto_increment,
nome varchar(255) not null,
preco decimal(10,2) not null,
descricao text not null);
Podemos ver a estrutura da tabela utilizando o comando:

desc produtos;
Se acabamos de criar a tabela, ela está vazia. Apenas para testar, adicionemos um registro com o comando insert:

insert into produtos (nome,preco,descricao) values (‘Iphone 6 plus’,3800.00,’Celular bem caro’);
Para vermos esse registro inserido precisamos selecionar os dados da tabela, logo executamos um select:

select * from produtos
Já conseguimos ver os nossos registros. Agora precisamos integrar tudo isso com o Cake PHP. Ele nos ajuda bastante a conversar com o banco de dados, mas para isso precisamos seguir algumas convenções:

precisamos ter um classe que representa a nossa tabela,
essa classe precisa ficar dentro da nossa pasta "model/table"
e, como queremos representar a tabela produtos, criamos o arquivo "ProdutosTable":
namespace App\Model\Table;

use Cake\ORM\Table;

class ProdutosTable extends Table {

}
Repare que toda classe que representa uma tabela precisa estender a classe "Table" do Cake PHP que se encontra no "namespace Cake\ORM\Table" e, por isso, precisamos dar use nesse namespace. Precisamos usar esta classe que representa a nossa tabela, então vamos ao método index() do nosso Controller e indicamos que queremos uma "ProdutosTable". Fazemos isso através de uma fábrica que o Cake PHP disponibiliza, a TableRegistry. No lugar de preencher todos os produtos manualmente, pedimos para a nossa tabela selecionar todos os dados. Portanto teremos um método index() com esta cara:

public function index() {

    $produtosTable = TableRegistry::get(‘Produtos’);
    $produtos = $produtosTable­->find(‘all’);
    $this­>set(‘produtos’,$produtos);

}
Se tentarmos rodar o nosso método acessando o endereço "localhost:8765/produtos", um erro será lançado falando que não conseguiu se conectar com o "my_app@localhost". Isso acontece porque em nenhum lugar falamos qual é o banco de dados que vamos utilizar na nossa aplicação. Devemos acessar o arquivo "config/app.php" e, neste arquivo, temos uma seção especifica para banco de dados com um código semelhante a este:

        'default' => [

            'className' => 'Cake\Database\Connection',
            'driver' => 'Cake\Database\Driver\Mysql',
            'persistent' => false,
            'host' => 'localhost',

            /**
             * CakePHP will use the default DB port based on the driver selected
             * MySQL on MAMP uses port 8889, MAMP users will want to uncomment
             * the following line and set the port accordingly
             */

            //'port' => 'nonstandard_port_number',
            'username' => 'root',
            'password' => '',
            'database' => 'cursocake',
            'encoding' => 'utf8',
            'timezone' => 'UTC',
            'cacheMetadata' => true,

            /**
             * Set identifier quoting to true if you are using reserved words or
             * special characters in your table or column names. Enabling this
             * setting will result in queries built using the Query Builder having
             * identifiers quoted when creating SQL. It should be noted that this
             * decreases performance because each query needs to be traversed and
             * manipulated before being executed.
             */

            'quoteIdentifiers' => false,

            /**
             * During development, if using MySQL < 5.6, uncommenting the
             * following line could boost the speed at which schema metadata is
             * fetched from the database. It can also be set directly with the
             * mysql configuration directive 'innodb_stats_on_metadata = 0'
             * which is the recommended value in production environments
             */

            //'init' => ['SET GLOBAL innodb_stats_on_metadata = 0'],

        ],
Repare que nesse código ele pede o host, o usuário e a senha do nosso banco. Substituímos para o usuário do nosso banco de dados. Feito isso, o código funciona e no próximo capítulo aprenderemos a executar outras ações no banco de dados.

############### 3. Criando Entidades e Helpers ###############

Já conseguimos visualizar os produtos na tabela. Precisamos implementar o código para adicionar um novo produto. Neste momento fazemos isso no banco de dados e adicionamos manualmente. Criemos uma interface gráfica para isso. A primeira coisa que precisamos fazer é conseguir, da listagem, ir até a página que insere os produtos. Então criamos um link com a tag <a href>:
<a href=”produtos/novo”> Novo produto </a>
Recebemos um erro ao clicarmos no link, afinal não criamos a ação novo() no nosso Controller de produtos. Resolvendo isso:

class ProdutosController extends AppController {

    // codigo anterior aqui

    public function novo() {

    }

}
Se atualizarmos agora o nosso navegador, ele vai reclamar falando que não encontrou a visualização da ação. Criemos um aquivo chamado "novo.ctp" na pasta "Template/Produtos/" que, por enquanto, ficará vazio. Porém, por algum motivo, poderíamos querer mudar o link de "produtos/novo" para "produtos/cadastra" precisando mexer no HTML que criamos lá no nosso "index.ctp". Imagine um link que estará em diversas partes do nosso sistemas, atualizar todos eles daria muito trabalho e, além disso, a chance de deixar passar algum é muito alta. Para não corrermos esse risco, pedimos para o Cake PHP gerar o link utilizando o helper. Um helper é uma classe que vai nos ajudar a trabalhar com alguma parte do sistema, neste caso precisamos de um para gerar HTML, logo trocamos a nossa tag <a> para o seguinte código PHP:

<?php

echo $this­>Html­>link(‘Novo Produto’,[‘controller’ => ‘produtos’,’action’=>’novo’]);

?>
Perceba que agora o nosso link aponta direto para a ação do nosso Controller e, caso apenas a URL sofra alguma alteração, não precisaremos mexer nos links diretamente. Para criar o nosso formulário no arquivo "novo.ctp" também temos um helper:

<?php 
    echo $this­>Form­>create(['action' => 'salva']);
    echo $this­>Form­>input('id');
    echo $this­>Form­>input('nome');
    echo $this­>Form­>input('preco');
    echo $this­>Form­>input('descricao');
    echo $this­>Form­>button('Salvar');
    echo $this­>Form­>end();
?>
Porém, como o nosso helper vai saber qual é o tipo de cada campo? Ele precisa pegar como referência o formato do registro que queremos inserir no banco de dados. passamos, então, um registro vazio para o formulário. O primeiro passo é criar esse registro no nosso Controller:

public function novo() {

    $produtosTable = TableRegistry::get(‘Produtos’);
    $produto = $produtosTable­>newEntity();
    $this­>set(‘produto’,$produto);
}
E o passamos na criação do nosso formulário:

echo $this->Form->create($produto, ['url' => ['action' => 'salva']]);
Já conseguimos gerar o nosso formulário. Porém, ao voltarmos para a listagem, a coluna que exibe o preço do produto não possui nenhuma formatação. Novamente criamos um helper para resolver esse problema. Basta criar um arquivo "MoneyHelper.php" na pasta "View\Helper" (todo helper no Cake PHP herda da classe helper) e implementá-lo dessa forma:

namespace App\View\Helper;
use Cake\View\Helper;

Class MoneyHelper extends Helper {

    public function format($number) {

    }

}
Passamos o helper para a View:

return “R$”.number_format($number,2,”,”.”);
E no "index.ctp"

<td><?= $this­>Money­>format($produto[‘preco’]); ?></td>
Porém, se atualizarmos o navegador, o nosso código não funciona, afinal onde informamos que o nosso helper foi carregado? Para isso, precisamos ir na nossa classe "AppView", no método initialize() e pedir para o Cake carregar um helper:

public function initialize() {

    parent::initialize();

    $this­>loadHelper(‘Money’);

}
Ao atualizar a página, já vemos o nosso helper funcionando! Adicionemos uma nova coluna na nossa tabela, a coluna valor com desconto:

<tr>
    <td><?= $prod['id']; ?></td>
    <td><?= $prod['nome']; ?></td>
    <td><?= $this-­>Money-­>format($prod['preco']); ?></td>
    <td><?= $this-­>Money­->format(prod­>calculaDesconto()); ?></td>
    <td><?= $prod['descricao']; ?></td>
</tr>
Qual classe representa um registro do banco de dados? No Cake PHP, cada registro é um entidade, portanto o método find da nossa "ProdutosTable" retorna um array de entidades e, já que queremos criar o método calculaDesconto() para os nossos produtos, criamos a classe "Produto" em "Mode\Entity\Produto.php":

<?php
namespaceApp\Model\Entity;
useCake\ORM\Entity;

class Produto extends Entity{

    publicfunctioncalculaDesconto(){
        return$this‐>preco*0.9;
              }
}
?>
Feito isso, ao atualizar a nossa página, a coluna "valor com desconto" já estará funcionando!

############### 4. Inserindo e atualizando os produtos. ###############

Implementamos o nosso formulário na aula passada. Precisamos fazer o botão "Salvar" funcionar. Para isso escrevemos a ação salva no ProdutosController:
public function salva() {

}
Mas o que esse método tem que fazer? A primeira coisa é pegar os dados enviados pelo formulário. isto é feito através do atributo request do nosso Controller, afinal queremos pegar os dados que foram enviados pela requisição e, para isso chamamos o método data do atributo request:

public function salva() {

    $dados = $this­>request­>data();
}
Precisamos ainda criar uma entidade e mandar ela se salvar no banco de dados, mas para isso precisamos de uma referência para a nossa tabela utilizando o "TableRegistry":

public function salva() {
    $produtosTable = TableRegistry::get(‘Produtos’);
    $dados = $this­>request­>data();
}
Preenchemos uma entidade com os dados do formulário:

public function salva() {
    $produtosTable = TableRegistry::get(‘Produtos’);
    $dados = $this­->request­>data();
    $produto = $produtosTable-­>newEntity($dados);
}
E, por fim, pedimos para a nossa tabela salvar o produto:

public function salva() {

    $produtosTable = TableRegistry::get(‘Produtos’);
    $dados = $this­->request­>data();
    $produto = $produtosTable­>newEntity($dados);

    if($produtosTable­->save($produto)) {

    }else {
    }
    $this­->set(‘msg’,$msg);
}
Ao terminar de executar esse código, qual será a página carregada? Será página "salva.ctp", portanto criemos este arquivo apenas mostrando uma mensagem:

 <h1><?= $msg; ?></h1>

<?= $this­->Html­->Link(‘Voltar’,[‘controller’ => ‘produtos’,’action’ => ‘index’]); ?>
Agora, ao preenchermos o formulário corretamente e clicar em salvar o nosso produto deverá ser cadastrado no banco. Estamos listando e cadastrando produtos sem escrever sequer uma linha de SQL! Tudo isso graças ao ORM do Cake PHP. Mas e se cadastrarmos um produto errado? Ainda não temos nenhum botão de alteração. Adicionemos uma nova coluna na tabela chamada "ações" e o conteúdo dessa coluna é um botão para editar o produto:

<thead>
    <!­­ outros th ­­>
    <th>Ações</th>
</thead>

<tbody>
    <?php
    ?>
    <tr>
        $msg = “Produto salvo com sucesso.”;
        $msg = “Erro ao salvar o produto.”;

        foreach($produtos as $produto) {

        <!-- outras td -->
        <td>
            => ‘editar’]);
        </td>
    </tr>
        <?php
        }
        ?>
</tbody>
Criaremos agora o nosso método editar() no ProdutoController:

public function editar() {

}
Quando clicamos em editar queremos que apareça o nosso formulário para alterar o produto. Como o formulário é exatamente o mesmo de adicionar produto, reaproveitaremos o nosso arquivo "novo.ctp" pedindo para a ação editar simplesmente exibir este arquivo. Fazemos isso através do método render:

public function editar() {
    $this-­>render(‘novo’);
}
Mas o que acontece quando acessamos esta página? Aparecerá um erro dizendo que a variável "produto" não está definida. Quando criamos o "novo", foi pedida uma variável produto vazia. A diferença é que agora iremos pegar um produto preenchido e vamos mostrá-lo no nosso formulário. Então precisaremos saber o seu id o pegando como parâmetro:

public function editar($id) {
    $produtosTable = TableRegistry::get(‘Produtos’);
    $produto = $produtosTable-­>get($id);
    $this-­>set(‘produto’,$produto);
    $this­->render(‘novo’);
}
Para passar o id para a ação editar utilizamos a URL, portanto vamos adicionar o id no link gerado:

<td>

=> ‘editar’,$produto[‘id’]]);

</td>
Ao acessar a nossa página, o formulário já vem preenchido, mas ao clicamos em salvar um novo produto é cadastrado. Por que isso aconteceu? Qual é o código que está sendo executado? É o código de salvar, mas veja que coincidência: o método que atualiza um produto é justamente o save(). Como esse método sabe quando estamos criando um produto novo e quando estamos atualizando um produto? Ao cadastrarmos um produto seu id tem valor nulo. Então, o que o save() faz é verificar o valor do id, caso ele não seja nulo significa que queremos atualizar! Logo, apenas adicionamos o campo id no nosso formulário:

<?php
    echo $this­->Form­->create(['action' => 'salva']);
    echo $this­->Form­->input('id');
    echo $this­->Form­->input('nome');
    echo $this­->Form­->input('preco');
    echo $this­->Form­->input('descricao');
    echo $this­->Form­->button('Salvar');
    echo $this­->Form­->end();
 ?>
Desta maneira estamos atualizando e inserindo produtos usando o mesmo formulário. Um último detalhe, muito importante: quando acessamos o link "localhost:8765" nos aparece a página inicial do Cake PHP e não é isso o que queremos. Queremos que na homepage do nosso site apareça a listagem dos produtos. Resolvemos isso mexendo no arquivo "config/routes.php". Apenas alteramos a linha da rota “/” para usar o ControllerProdutos na ação:

Alteramos

$routes­->connect('/', ['controller' => 'Pages', 'action' => 'display', 'home']);
Para

$routes-­>connect('/', ['controller' => ’Produto’, 'action' => 'index']);

############### 5. Deletando os produtos ###############

Na aula anterior acabamos cadastrando um Iphone 6 plus sem querer. O que precisamos fazer com esse registro? Seria bom podermos deletá-lo. Como já temos uma coluna chamada "ações", adicionemos um link "deletar" também:
<!-- outras tds -->

<td>

<?php
    => ‘editar’,$produto[‘id’]]);

    => ‘deletar’,$produto[‘id’]]);
?>

</td>
Ao clicarmos no link, o Cake PHP vai informar que não encontrou a ação deletar(), ela precisa ser criada:

public function deletar($id) {

}
Queremos deletar os dados da nossa tabela, portanto referenciamos para ela:

public function deletar($id) {

    $produtosTable = TableRegistry::get(‘Produtos’);
}
Além disso, precisamos selecionar qual é o produto que iremos deletar e pedir para a nossa tabela de fato executar essa ação, fazemos isso utilizando o método delete():

public function deletar($id) {

    $produtosTable = TableRegistry::get(‘Produtos’);
    $produto = $produtosTable­>get($id);

    if($produtosTable­>delete($produto)) {

    }else {

    }

    $msg = “Produto removido com sucesso”;
    $msg = “Erro ao remover o produto”;

}
Mas, ao acabar a execução desse método, o Cake PHP vai procurar a view "deletar.ctp" e não é isso que queremos. Queremos que, quando terminar de deletar um produto, volte para a listagem. Para isso fazemos um redirecionamento usando o método redirect() do nosso Controller:

public function deletar($id) {

    $produtosTable = TableRegistry::get(‘Produtos’);
    $produto = $produtosTable­>get($id);

    if($produtosTable­>delete($produto)) {

    }else {

    }

    $this­>redirect(‘produtos/index’);
}
Se testarmos o nosso código tudo deve estar funcionando corretamente, mas ainda temos um problema: o que acontece se acidentalmente clicarmos no botão "apagar" de algum produto? A nossa aplicação não pensa duas vezes, removendo o produto do banco de dados. Pediremos, então, uma confirmação para o nosso usuário. Fazemos isso adicionando um terceiro parâmetro ao nosso link que é o confirm.

Além disso, estamos passando o id do produto pela URL, a qual não é uma boa prática, afinal qualquer um poderia acessá-la e deletar um produto. Usemos um formulário com o método de envio configurado para POST, assim os nossos dados não aparecerão na URL. Portanto, substituímos o nosso helper HTML pelo helper de formulário, ficando com esse código:

$msg = “Produto removido com sucesso”;
$msg = “Erro ao remover o produto”;
echo $this­>Form>PostLink(‘Apagar’,[‘controller’=>’produtos’,’action’ => ‘deletar’,$produto[‘id’],[‘confirm’ => ‘Deseja realmente remover o produto’.$produto[‘nome’].” ?”]);
Agora, se rodarmos a nossa aplicação, o Cake PHP criará um javascript solicitando a confirmação do nosso usuário.

############### 6. Flash Scope ###############

Já conseguimos inserir, deletar e apagar os nossos produtos, mas na última aula não mostramos a mensagem que criamos no Controller. Podemos criar uma variável "mensagem" e simplesmente passar um $this->set(‘msg’,$msg). Faz sentido, afinal é assim que estamos fazendo até agora. Porém, no final do método nós redirecionamos a página, então essa variável acaba se perdendo entre as requisições. Este é um problema comum e, sendo assim, alguém já pensou em uma forma de resolvê-lo: algumas mensagens nós queremos que durem o escopo de uma requisição, ou seja, quando atualizamos a página ela tem que sumir. Damos a esse recurso o nome de Flash scope, para trabalhar com ele precisamos chamar o método set() do atributo Flash do nosso Controller:
$this->Flash->set(“minha mensagem”);
Agora usamos esse recurso no nosso código de deletar produtos:

public function deletar($id) {
    $produtosTable = TableRegistry::get(‘Produtos’);    
    $produto = $produtosTable->get($id);

    if($produtosTable->delete($produto)) {
        $this->Flash->set(“Produto removido com sucesso”);
    }else {
        this->Flash->set(“Erro ao remover o produto”);
    }
    $this->redirect(‘produtos/index’);
}
Se rodarmos o nosso código e tentar deletar um produto será exibida uma mensagem em uma caixa verde falando “Produto deletado com sucesso” e, se atualizarmos, ela some por durar apenas uma requisição.

Podemos aplicar essa ideia também na hora de salvar um produto. Não precisamos mais da página "salva.ctp" e podemos usar as mensagem em Flash e redirecionar para a nossa listagem:

public function salva() {
    $produtosTable = TableRegistry::get('Produtos');
    $produto = $produtosTable->newEntity($this->request->data());

    if($produtosTable->save($produto)) {
        $this->Flash->set("Produto inserido com sucesso");
    }else {
        $this->Flash->set("Erro ao inserir o produto");
    }
    $this->redirect('Produtos/index');
}
Se tentarmos cadastrar um produto em branco será exibida uma mensagem de erro, mas ela aparece em uma caixa verde. Mensagens de erros geralmente são exibidas em caixas vermelhas, podemos resolver isso adicionando o parâmetro element ao nosso método set():

public function salva() {
    $produtosTable = TableRegistry::get('Produtos');
    $produto = $produtosTable->newEntity($this->request->data());

    if($produtosTable->save($produto)) {
        $this->Flash->set("Produto inserido com sucesso");
    }else {
        $this->Flash->set("Erro ao inserir o produto",['element'=> 'error']);
    }
    $this->redirect('Produtos/index');
    }

############### 7. Autorização ###############

Nosso sistema já está funcionando quase que plenamente. E quem pode cadastrar um produto? Qualquer pessoa que acessar o nosso site! Para restringir o acesso, criamos um sistema de login com uma tabela no nosso banco que armazena os nossos usuários, então, no Terminal:
create table users (
id int not null primary key auto_increment,
username varchar(255) not null,
password varchar(255) not null
);
Mas por que o nome "users"? No Cake PHP todo os sistema de autenticação considera que os nossos usuários estão salvos em uma tabela "users", a qual obrigatoriamente possui os campos "username" e "password". Portanto estamos seguindo uma convenção para evitar uma nova configuração.

Agora que já temos a tabela precisamos criar um formulário para poder inserir usuários na tabela. Como temos uma parte do sistema que cuida de usuários, criaremos um controlador para isso, o "UsersControllers.php":

namespace App\Controller;

class UsersController extends AppController {

}
Além de um controlador, precisamos também de uma classe que representa a nossa tabela no banco, então criamos a classe "UsersTable":

namespace App\Model\Table;
use Cake\ORM\Table;

class UsersTable extends Table {

}
Ao acessarmos a URL "localhost:8765/users" o Cake PHP reclama que não encontrou o método index(), então criemos dentro de "UsersController.php":

public function index() {

}
Como queremos adicionar um usuário, trocamos a nossa ação padrão e, além disso, precisamos criar o arquivo "adicionar.ctp" em "Template\Users\". Como é um arquivo para adicionar usuários, criamos um form utilizando o helper. Dentro de "UsersController.php"fazemos:

public function adicionar() {

}
E no "adicionar.ctp":

<h1>Cadastrar usuário</h1>
<?php
    echo $this->Form->create($user,['action' => 'save']);
    echo $this->Form->input('username');
    echo $this->Form->input('password');
    echo $this->Form->button('Cadastrar');
    echo $this->Form->end();
?>
Precisamos criar a variável $user no nosso Controller. Como estaremos cadastrando um usuário novo, precisamos passar um usuário em branco. Em "UsersController.php" fazemos:

public function adicionar() {
    $usersTable = TableRegistry::get(‘Users’);
    $user = $usersTable->newEntity();
    $this->set(‘user’,$user);
}
Ainda não escrevemos o código que salva o nosso usuário no banco. Precisamos implementar ação salvar(), que será bem parecida com a dos produtos. A única diferença é que agora trabalharemos com a "UsersTable" no lugar da "ProdutosTable":

public function salvar() {
    $usersTable = TableRegistry::get(‘Users’);
    $user = $usersTable->newEntity($this->request->data());

    if($usersTable->save($user)) {
        $this->Flash->set(‘Usuário salvo com sucesso’);
    }else {
        $this->Flash->set(‘Erro ao salvar o usuário’);
    }

    $this->redirect(‘Users/adicionar’);
}
Se preenchermos o nosso formulário já deverá ser inserido um usuário no banco, mas o que fazemos com esse usuário? Precisamos realizar o login, então programamos tal ação no "UsersController.php":

public function login() {

}
Precisamos criar uma visualização para essa ação criamos o arquivo "login.ctp" em "Template\Users\":

echo $this->Form->create();
    echo $this->Form->input('username');
    echo $this->Form->input('password');
    echo $this->Form->button('Login');
    echo $this->Form->end();
