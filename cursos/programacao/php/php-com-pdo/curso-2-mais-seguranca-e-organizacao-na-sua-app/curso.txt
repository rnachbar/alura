########## 01. Listagem de produtos ##########


Olá, meu nome é Mario, sejam bem vindos à segunda parte do curso de PHP com PDO. Neste curso, falaremos sobre o que envolve os produtos de nosso sistema, além de fazermos algumas melhorias na parte de categorias, desenvolvida na primeira parte.

Então, se você ainda não fez a primeira parte do curso, sugiro fortemente que o faça, para que você tenha toda a base necessária, com dicas sobre as conexões, as formas com as quais poderemos fazer consultas nos bancos de dados, e a manipulação de informações do mesmo.

Com isso, seguiremos trabalharemos com a preparação de queries, funcionalidade muito interessante trazida pelo PDO, que implica em basicamente passarmos um parâmetro em vez de concatenar valores diretamente em uma query.

Isto traz muito mais segurança, além de deixar o código muito mais organizado.

Então, vamos começar?

No curso anterior, conseguimos fazer a inclusão, exclusão e edição de categorias, além de visualizá-las e carregá-las em uma listagem. Porém, nosso sistema também é composto de produtos, e precisamos desenvolver todo o fluxo para lidarmos com eles também, isto é, para cadastramentos, exclusões e listagem.

Vamos começar a trabalhar com isso?

Acessando o menu "Produtos" na página do navegador, veremos "O Senhor dos Anéis" cadastrado, de id 1, com preço R$ 80,55, quantidade 2 e categoria Livros. Esta tela é um pouco mais complexa que a de categorias, por trazer mais informações.

Vamos abrir produtos.php, localizado na raiz do projeto. Ele possui basicamente a mesma estrutura dos demais arquivos com que trabalhamos anteriormente, com tabelas mocadas, isto é, fixas ao HTML, não dinâmico, servindo apenas para termos uma visão do front end.

Começaremos repetindo o que fizemos com as categorias, criando uma classe para representar a entidade Produto no sistema. Ou seja, em classes, criaremos Produto.php, em que representaremos todos os campos da parte de produtos com atributos:

<?php

class Produto
{
    public $id;
    public $nome;
    public $preco;
    public $quantidade;
    public $categoria;
}
Porém, como estas informações estão representadas no banco de dados? Para conferir, vamos abrir o script de criação do banco de dados, banco_de_dados.sql. Na parte de produtos, temos o id, nome, preco, quantidade e categoria_id, pois logo em seguida criamos uma FOREIGN KEY, fk_categorias, que funciona como chave estrangeira no banco de dados, cuja categoria_id representa o id da tabela categorias.

Para trabalharmos da mesma forma como fazemos no banco de dados na nossa classe, o atributo categoria, previamente criado, será convertido para categoria_id.

Começaremos pela listagem de produtos, que será apresentada ao usuário, e trabalharemos com o método listar() que a retornará para nós. Vamos manter o padrão estabelecido na parte de categorias - sabemos que todas as classes que representam as entidades terão o método listar() para os registros da entidade.

Para a query de consulta, você poderá estar se perguntando se não teríamos o mesmo efeito se escrevessemos "*$ FROM nome da tabela". Sim, teríamos. No entanto, isto não é nem um pouco recomendado, pois não sabemos como esta estrutura ficará futuramente. É legal sermos fiéis ao que precisamos no SELECT. Neste caso, como todos estes campos serão utilizados, deixaremos isso bem explícito em nosso código.

Faremos também a requisição de conexão, lembrando que agora não precisaremos de nenhum require_once na classe para pegarmos o método de conexão que temos, pois já temos o autoloader, então, quando este ponto for alcançado, ele tentará buscar por esta classe, cairá no autoloader, o qual fará o require, e aí, sim, o método funcionará.

Executaremos a query com o método query() para obtermos retorno a partir da função fetchAll(), da classe PDOStatement.

O código ficará assim:

<?php

class Produto
{
    public $id;
    public $nome;
    public $preco;
    public $quantidade;
    public $categoria_id;

    public static function listar()
    {
        $query = "SELECT id, nome, preco, quantidade, categoria_id FROM produtos";
        $conexao = Conexao::pegarConexao();
        $resultado = $conexao->query($query);
        $lista = $resultado->fetchAll();
        return $lista;
    }
}
Vamos testar para ver se funciona, utilizando a tag <pre> e print_r no próprio arquivo produtos.php, em que serão listadas estas informações. Antes de mais nada, faremos o require_once para o arquivo global.php, acrescentando a linha <?php require_once 'global.php' ?> no topo do código.

Agora temos o arquivo global.php, que carrega todas as informações de que nossa página precisará. Tudo que chamamos de compilador, que é este bloco de código e não é uma classe, precisa estar contido em um Try/Catch.

<?php
    try {
        $lista = Produto::listar();
        echo '<pre>';
        print_r($lista);
        echo '</pre>';
        exit;

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Feito isso, testaremos novamente, e será exibida uma página com uma matriz de vários índices, sendo que cada um é um array que representa uma linha do nosso banco de dados.

Temos os livros cadastrados, jogos, e assim por diante. Vimos, portanto, que nossa lista funciona direitinho. Podemos deletar o debug no try, mantendo apenas o método listar():

<?php
    try {
        $lista = Produto::listar();
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Agora, precisaremos ir à parte do HTML em produtos.php, em que há uma tabela e, entre as tags <tbody> e <tr> faremos o foreach para o laço que irá passar por cada linha do array e imprimir os valores de que precisamos.

Usaremos a forma alternativa de controle do PHP neste momento, pois estamos misturando-o com HTML, para fins de organização do código.

<?php foreach ($lista as $linha): ?>
<tr>
    <!-- informações referentes a um dos livros cadastrados -->
</tr>
<?php endforeach ?>
Ao abrirmos um PHP usando um comando e fechando-o logo em seguida, não é preciso utilizar o ponto e vírgula (;), pois o fechamento do PHP já é o suficiente.

Vamos testar o que foi feito até aqui! Serão impressos os mesmos valores em cinco linhas, que é o que temos no nosso banco de dados. Desta vez, queremos que apareçam os valores de cada linha.

Em relação ao preço, só estamos armazenando o valor, não o R$. Sendo assim, manteremos isto no HTML, colocando o PHP depois dele. Voltaremos a produtos.php e o deixaremos assim:

<?php foreach ($lista as $linha): ?>
<tr>
    <td><?php echo $linha['id'] ?></td>
    <td><?php echo $linha['nome'] ?></td>
    <td>R$ <?php echo $linha['preco'] ?></td>
    <td><?php echo $linha['quantidade'] ?></td>
    <td><?php echo $linha['categoria_id'] ?></td>
    <td><a href="/produtos-editar.php" class="btn btn-info">Editar</a></td>
    <td><a href="#" class="btn btn-danger">Excluir</a></td>
</tr>
<?php endforeach ?>
Testaremos novamente e veremos que temos o id de cada registro, bem como os nomes, preços e quantidades. Porém são exibidos os números das categorias, e não os nomes, e isto não é o que queremos por não ser nem um pouco prático.

Vamos trabalhar de maneira que tenhamos um carregamento completo do que precisamos desta listagem, alterando nossa query. No arquivo Produto.php, quebraremos a linha referente à query para que ela não fique muito extensa, o que não trará nenhum problema no PHP desde que se coloque o ponto e vírgula no final.

public static function listar()
{
    $query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
                        FROM produtos p
                        INNER JOIN categorias c ON p.categoria_id = c.id";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
Ao usarmos categoria_nome conseguimos diferenciar o array retornado pelo fetchAll(), que seguirá exatamente o que colocamos no SELECT. Por meio dos alias, com as, damos um apelido para o campo, que em vez de aparecer como nome, será c.nome.

Não alteraremos nada e veremos se tudo continua funcionando como antes. As categorias ainda aparecem com o número, e não o nome. Assim, no campo em que as apresentamos, usaremoscategoria_nome no foreach do HTML, em vez de imprimirmos categoria_id. Em produtos.php, portanto, teremos:

<td><?php echo $linha['categoria_nome'] ?></td>
Salvaremos e atualizaremos a página, e as categorias são apresentadas como gostaríamos, com seus nomes, e não números!

Nossa listagem de produtos está funcionando direitinho, com um pequeno porém: vocês lembram que na listagem de categorias acrescentamos um if para verificar quantos registros são retornados, e assim exibirmos uma mensagem amigável ao usuário caso não exista nada cadastrado no banco de dados?

Precisaremos fazer o mesmo nesta parte de produtos. Vamos abrir produtos.php e incluir na tabela um if com o método count():

<div class="col-md-12">
    <?php if (count($lista) > 0): ?>
    <table class="table">
        <thead>
        <tr>
            <!-- código omitido -->
        </tr>
        </thead>
    </table>
    <?php else: ?>
        <p>Nenhum produto cadastrado</p>
    <?php endif ?>
</div>
Testando no navegador, veremos que isso não afeta nossa página, isto é, tudo continua funcionando bem. Para confirmarmos, pode-se forçar a regra inversa, substituindo > por <= na linha abaixo:

<?php if (count($lista) <= 0): ?>
Assim, quando atualizamos a página, será exibida a mensagem "Nenhum produto cadastrado". Deixaremos o código da maneira como estava anteriormente.

Outro ponto feito nas categorias que ainda não implementamos são os ids dos nossos botões. Ao passarmos o mouse sobre eles, seus endereços não mostram nenhum id ou ação a ser tomada.

Em produtos.php, passaremos então o valor do id do produto via query string, simplesmente acrescentando o ponto de interrogação, e a variável igual a valor, que no caso é dinâmico.

O botão Excluir ainda não possui um link, porém poderemos estipular que ele seguirá com o mesmo padrão da página de categoria. O código ficará da seguinte maneira:

<td><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a></td>
<td><a href="/produtos-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
Feito isso, vamos salvar o arquivo e atualizar a página. Ao passarmos o mouse novamente sobre os botões, desta vez veremos nos links no canto inferior esquerdo o id correspondente aos produtos.

Parece um tanto desorganizado, porque a listagem está seguindo a ordem das categorias, e não dos nomes dos produtos. Vamos alterar isso indo à classe Produto.php, em que acrescentaremos um ORDER BY na $query:

$query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
          FROM produtos p
          INNER JOIN categorias c ON p.categoria_id = c.id
                    ORDER BY p.nome ";
Tudo certo! E você poderá organizar a listagem da maneira como achar melhor.

Nessa aula fizemos nossa classe Produto e nosso primeiro método Produto::listar(), no qual usamos um INNER JOIN na tabela de categorias para trazer o nome da categoria na listagem dos produtos. Sem isso só conseguíamos mostrar o ID da categoria, que é um campo da tabela de produtos.

Existe uma outra forma.

O que poderíamos ter feito para não usar o INNER JOIN em nosso SELECT é, dentro do foreach, da listagem de produtos, ter usado o método carrega da Classe Categoria para carregar a entidade de cada categoria e, assim, exibido o nome dela a partir da própria entidade. Isso é o que chamamos de Lasy Loading.

Embora para essa situação usar Lazy Loading não seja a melhor escolha, pois vai gerar um excesso grande de processamento, além de deixar nosso código um pouco desorganizado, vamos alterar nosso código de listagem, para ver essa técnica funcionando.

OBS: Mais pra frente em nosso curso, vamos utilizar a técnica de Lazy Loading de uma forma parecida, onde tem sua aplicabilidade muito mais válida. =)

Precisamos alterar o método listar() da classe classes/Produto.php:

public static function listar()
{
    $query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
                FROM produtos p
                INNER JOIN categorias c ON p.categoria_id = c.id
                ORDER BY p.nome ";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
E o bloco do foreach() do arquivo produtos.php:

<?php foreach ($lista as $linha): ?>
<tr>
    <td><?php echo $linha['id'] ?></td>
    <td><?php echo $linha['nome'] ?></td>
    <td>R$ <?php echo $linha['preco'] ?></td>
    <td><?php echo $linha['quantidade'] ?></td>
    <td><?php echo $linha['categoria_nome'] ?></td>
    <td><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a></td>
    <td><a href="/produtos-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
</tr>
<?php endforeach ?>

Para fazer isso, vamos começar tirando todo o bloco do INNER JOIN e suas referências de nosso SELECT dessa forma:

$query = "SELECT p.id, p.nome, preco, quantidade, categoria_id
                  FROM produtos p
                  ORDER BY p.nome ";
Agora, vamos alterar, dentro do bloco do foreach() do arquivo produtos.php, para tirar a refeência ao campo do nome da categoria que vinha em nossa query antes da alteração. Alterando a linha: <td><?php echo $linha['categoria_nome'] ?></td> para <td><?php echo $linha['categoria_id'] ?></td>.

Agora, vamos criar um novo bloco de php logo abaixo da linha do foreach() e colocar o seguinte código:

<?php $categoria = new Categoria($linha['categoria_id']); ?>
E por fim, vamos usar o comando echo com o atributo nome da classe Categoria em vez de mostrar o ID da categoria na coluna. Alterando a linha <td><?php echo $linha['categoria_id'] ?></td> para <td><?php echo $categoria->nome ?></td>

Teremos o mesmo resultado de antes, mas com uma forma diferente de obter os dados!


########## 02. Inserção de produtos ##########


Neste momento, tudo o que fizemos em relação à listagem de produtos funciona bem. Em seguida, queremos conseguir incluir novos produtos no sistema. Para isso, vamos clicar no botão "Criar novo produto" na página do navegador.

Somos redirecionados a outra página com um formulário contendo nome do produto, preço, quantidade e categoria - que não está sendo listado corretamente -, além do botão "Salvar". Começaremos ajustando esta página, produtos-criar.php, para trabalharmos em cima dela depois.

De imediato pode-se notar que estão faltando os names nos inputs, para podermos recuperar as informações quando elas forem submetidas ao servidor.

Assim, em cada um destes campos incluiremos o name correspondente no código: name="nome" para "Nome do Produto", name="preco" para "Preço do Produto", name="quantidade" para "Quantidade de Produto". E no select referente à "Categoria do Produto", acrescentaremos name="categoria_id".

Agora, precisaremos fazer com que esta lista de categorias do formulário funcione, ou seja, é necessário um método para listarmos isso. Ou poderemos usar o método que já criamos na classe Categoria.php, pois listar é uma responsabilidade delas. Vamos relembrá-lo?

Em Produto.php criamos um método estático, o que não ocorre em Categoria.php. A diferença entre eles é que um método estático não se relaciona com nada além do que existe na própria classe, no objeto propriamente dito. Significa que ele não faz referência a outros métodos ou atributos do objeto.

O método estático se encaixa bem no nosso caso, então, aproveitando, vamos regularizar isso, convertendo o método, a ser utilizado na listagem de categorias:

public static function listar()
{
    $query = "SELECT id, nome FROM categorias";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
No try de categorias.php, fazemos a instância e depois chamamos o método listar(). Como ele é estático agora, não precisaremos instanciá-lo, e o código ficará assim:

<?php
    try {
        $lista = Categoria::listar();
    } catch(Exception $e) {
        Erro::trataErro($e);
    }
Vamos conferir se a página de listagem de categorias continua funcionando como esperado.

Tendo confirmado isto, voltaremos a produtos-criar.php para fazermos o require_once do arquivo global.php, e criarmos um bloco de PHP para o Try/Catch.

Salvaremos o código e retornaremos à página de inserção de novo produto no navegador. Aparentemente, tudo funciona corretamente, mas para confirmar incluiremos o debug para popularmos o valor:

<?php require_once 'global.php' ?>
<?php
    try {
        $listaCategoria = Categoria::listar();

        echo '<pre>';
        print_r($listaCategoria);
        echo '</pre>';

        exit;
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
A listagem de categorias aparece da maneira como esperávamos! Vamos deletar o debug que fizemos, e incluir um foreach no select para termos várias opções.

No select do arquivo produtos-criar.php há dois valores, correspondentes a "Livros" e "Revistas". Vamos manter apenas um deles, e incluir o foreach:

<div class="form-group">
    <label for="nome">Categoria do Produto</label>
    <select class="form-control" name="categoria_id">
        <?php foreach ($listaCategoria as $linha): ?>
            <option value="<?php echo $linha['id'] ?>"><?php echo $linha['nome'] ?></option>
        <?php endforeach ?>
    </select>
</div>
Com isso, temos mais opções de seleção na parte de "Categoria do Produto", quando um novo produto for inserido na tabela. Para sabermos se o value está funcionando bem, podemos inspecionar o elemento no navegador e confirmar que cada categoria possui um valor diferente:

<option value="1">Livros</option>
<option value="2">Jogos</option>
<option value="3">Filmes</option>
<option value="4">Roupas</option>
<option value="5">Revistas</option>
E já que organizamos os produtos em ordem alfabética a partir dos seus nomes, vamos fazer o mesmo em relação às categorias. Na classe Categoria.php, deixaremos o query da seguinte forma:

$query = "SELECT id, nome FROM categorias ORDER BY nome";
Agora temos a listagem das categorias da tabela de produtos! Mas e se não houver nenhuma categoria cadastrada no sistema? Imaginem a situação em que um sistema acabou de ser instalado, e não existir nada além do banco de dados, e o usuário quer cadastrar um produto. O que acontecerá?

Não poderemos inserir um novo produto sem que haja uma categoria vinculada a ele.

Portanto, precisaremos fazer uma verificação que contará o número de categorias que temos. E se não existir nenhuma, não deixaremos que um usuário cadastre um novo produto.

Sendo assim, vamos retornar a produtos-criar.php e colocar o if com count antes da exibição do formulário ao usuário, entre as <div>s do título e a abertura do <form>:

<div class="row">
    <!-- código omitido -->
</div>
<?php if (count($listaCategoria) > 0): ?>
    <form action="produtos-criar-post.php" method="post">
        <!-- código omitido -->
    </form>
<?php else: ?>
    <p>Nenhuma categoria cadastrada no sistema. Por favor, crie uma categoria antes de cadastrar um produto.</p>
<?php endif ?>
Visualmente, nada foi afetado em nossa página. Então, para testarmos, usaremos a técnica de inverter o if, desta vez acrescentando !, o operador de negação, para todo o argumento:

<?php if (!(count($listaCategoria) > 0)): ?>
A mensagem será exibida corretamente. Vamos tirar a negação para voltarmos ao estado anterior.

Nossa tela de inserção de novos produtos está praticamente finalizada, falta apenas acrescentarmos o método para o cadastro em si. Faremos isto seguindo o padrão definido na parte de categorias. Então, abriremos Produto.php, em que teremos:

public function inserir()
{
    $query = "INSERT INTO produtos (nome, preco, quantidade, categoria_id)
                        VALUES ('" . $this->nome . "', " . $this->preco . ", " . $this->quantidade . ", " . $this->categoria_id . ")";
    $conexao = Conexao::pegarConexao();
    $conexao->exec($query);
}
Para verificar se o código funciona, precisaremos criar uma página na raiz do projeto, que instanciará a classe Produto.php, irá popular os atributos que queremos inserir, e que depois chamará este método, da mesma forma que fizemos com as categorias.

Também precisamos fazer com que o formulário envie os dados para este arquivo. Portanto, vamos voltar a produtos-criar.php, em que veremos que a tag <form> já está com method="post", corretamente.

Criaremos produtos-criar-post.php, em que chamaremos o require_once do arquivo global, e acrescentaremos o Try/Catch. Precisamos resgatar os valores obtidos por meio do formulário, instanciando uma classe Produto em branco, e populando os atributos desta classe.

<?php
    require_once 'global.php';

    try {
        $nome = $_POST['nome'];
        $quantidade = $_POST['quantidade'];
        $preco = $_POST['preco'];
        $categoria_id = $_POST['categoria_id'];

        $produto = new Produto();

        $produto->nome = $nome;
        $produto->quantidade = $quantidade;
        $produto->preco = $preco;
        $produto->categoria_id = $categoria_id;
        $produto->inserir();

        header('Location: produtos.php');

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
Vamos testar e ver o que acontece? Voltaremos à página de cadastro de novos produtos, cujo nome é "Camiseta Azul", o preço é "40", quantidade "10" e categoria "Roupas". Clicaremos no botão "Salvar", e veremos que o produto foi cadastrado com sucesso, constando na listagem junto aos demais.

O método PDO::prepare(), assim como o PDO::query(), retorna um objeto do tipo PDOStatement, mas com a diferença que a query não é executada automaticamente.

O objeto PDOStatement possui diversos métodos que podemos usar, em diferentes situações que podem ajudar. Vamos agora dar uma listada nas possibilidade que temos com esse objeto!

PDOStatement::fetch
Retorna a próxima linha de um resultset. Podemos usar o método fetch, combinado por exemplo com um while() para buscar cada linha do resultado. Ele sempre começa na primeira linha do resultado de sua query e a cada vez que o método é chamado, ele vai para a próxima linha. Quando chega na ultima linha, o método retorna um valor false.

Veja um exemplo de um SELECT em nossa tabela de produtos com isso:

<?php

require_once 'global.php';

$conexao = Conexao::pegarConexao();
$query = "SELECT nome FROM produtos";
$stmt = $conexao->prepare($query);
$stmt->execute();
$row = $stmt->fetch();

while ($row) {
    echo 'Produto:' . $row['nome'] . '<br>';
    $row = $stmt->fetch();
}
PDOStatement::fetchObject()
O fetchObject() funciona de forma muito parecida com o método fetch(), mas com a diferença simples de que, o retorno não vai ser um array onde, cada indice representa uma coluna na entidade e sim, um objeto, onde, cada atributo representa a entidade.

Veja o mesmo exemplo com a aplicação de PDOStatement::fetchObject():

<?php

require_once 'global.php';

$conexao = Conexao::pegarConexao();
$query = "SELECT nome FROM produtos";
$stmt = $conexao->prepare($query);
$stmt->execute();
$row = $stmt->fetchObject();

while ($row) {
    echo 'Produto:' . $row->nome . '<br>';
    $row = $stmt->fetchObject();
}
PDOStatement::rowCount
Sempre que usamos uma instrução SQL do tipo INSERT, UPDATE ou DELETE, não teremos um resultset, Mas, temos um retorno do Banco de Dados com a quantidades de linhas que foram afetadas pelo nosso script. E esse método justamente retorna isso para nós. Veja o exemplo abaixo:

<?php

require_once 'global.php';

$novo_preco = 11;

$conexao = Conexao::pegarConexao();
$query = "UPDATE produtos SET preco = :preco";
$stmt = $conexao->prepare($query);
$stmt->bindValue(':preco', $novo_preco);
$stmt->execute();
echo $stmt->rowCount() . ' Linhas atualizadas!';
E temos o seguinte resultado: 13 Linhas atualizadas!.

A lista completa de métodos pode ser encontrada na documentação do php (http://php.net/manual/pt_BR/class.pdostatement.php).


########## 03. Preparando script de banco de dados no PDO ##########


Após configurarmos a parte de cadastro de novos produtos, e antes de continuarmos com a edição e exclusão dos mesmos, faremos uma reformulação em nosso código para reforçarmos sua segurança, no sentido de que, da maneira como ele se encontra, principalmente em relação às queries de bancos de dados feitos com PDO, acabamos gerando risco de vulnerabilidade no sistema.

Para demonstrar isso, vamos abrir Produto.php, com o método que acabamos de criar, inserir(). Nele, estamos concatenando os valores inseridos diretamente à query, e isto gera grande risco de segurança por não fazermos nenhum tratamento no valor que o usuário coloca no formulário, após o qual simplesmente fazemos a chamada do método de INSERT.

Existem várias maneiras de prevenirmos SQL Injections, e as mais claras e simples implicam em pegarmos o valor e tratarmos o método inserir() antes de chamá-lo, procurando por padrões que normalmente são utilizados em uma tentativa de SQL Injection - como caracteres especiais como ponto e vírgula, traço duplo (um comentário do SQL), aspas simples, or 1 = 1. Estas normalmente são as técnicas mais usadas.

O PDO, no entanto, traz uma funcionalidade para o tratamento de SQL de uma forma muito mais fácil e que, além disso, deixará as queries do nosso código mais organizadas. Até então, já tínhamos usado os métodos query() e exec(). Desta vez, faremos diferente, preparando esta execução com o método prepare(), e depois usando o execute().

No código de Produto.php, precisaremos alterar basicamente todas as concatenações na parte de values do INSERT, colocando chaves para indicar que um valor será passado de forma dinâmica. Não usaremos aspas simples, e sim dois pontos (:) antes do valor, ainda como string.

O método prepare() é bem parecido com o query(), e ele nos retornará um PHP Statement mas, diferentemente do query(), que devolve o Statement (stmt) já executado, o prepare(), como o próprio nome indica, irá nos devolvê-lo preparado, mas ainda não executado.

É preciso indicar à preparação da query os valores que queremos adicionar em nome, preco, quantidade e categoria_id, por meio do bindValue, sendo que o primeiro será a chave que usamos no formato string, e o segundo será o valor que queremos inserir efetivamente no campo. Este processo faz a validação caso haja algo de SQL Injection, além de deixar o código mais organizado.

Para executar este código, usaremos o método execute(), que não é do objeto de conexão PDO, e sim do PDO Statement da variável stmt. Tecnicamente, isso trará o mesmo resultado que tínhamos antes, porém de forma mais legível e muito mais segura.

public function inserir()
{
    $query = "INSERT INTO produtos (nome, preco, quantidade, categoria_id)
                        VALUES (:nome, :preco, :quantidade, :categoria_id)";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $this->nome);
    $stmt->bindValue(':preco', $this->preco);
    $stmt->bindValue(':quantidade', $this->quantidade);
    $stmt->bindValue(':categoria_id', $this->categoria_id);
    $stmt->execute();
}
Vamos fazer um teste inserindo um novo produto à tabela: "Bermuda", que custará "25" reais, cuja quantidade será "3" e a categoria, "Roupas". Salvaremos e seremos redirecionados à listagem, que terá a nova categoria adicionada, como esperado. Aproveitando que aprendemos a fazer isso, vamos fazer o mesmo nos métodos que já temos e que fazem consulta ao banco de dados.

Não é estritamente necessário fazê-lo com todos eles, o ideal é usar a preparação de queries quando há dados dinâmicos. Ou seja, quando passamos algum id ou valor passado pelo usuário. Sendo assim, em Produto.php não há nada em que ele possa interferir, portanto não precisaremos realizar alterações.

Na classe Categoria.php, o método listar() não precisa deste tratamento pois seu valor é fixo, e em carregar() concatenamos o valor do id na nossa query. Mas de onde ele vem?

Na página de edição de categoria no navegador, é exibido o valor do id na barra de endereço. Logo, este é um bom lugar para alterarmos. Então, o código ficará da seguinte forma:

public function carregar()
{
    $query = "SELECT id, nome FROM categorias WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
    $lista = $stmt->fetchAll();
    foreach ($lista as $linha) {
        $this->nome = $linha['nome'];
    }
}
Testaremos o código apertando a tecla "F5" no navegador, e veremos que tudo funciona corretamente. Uma dica para deixarmos o código ainda melhor é que neste caso sabemos que a query retornará apenas uma única linha, e criamos um foreach mesmo sabendo que ele passará por esse loop apenas uma vez.

Por que, mesmo assim, usamos o foreach neste caso?

Por conta do fetchAll(). E para não termos que fazer isso, em vez de lista, usaremos linha, e no lugar de fetchAll() usaremos simplesmente fetch(), que pegará a primeira linha. Daí, não precisaremos mais do foreach, e teremos:

public function carregar()
{
    $query = "SELECT id, nome FROM categorias WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
    $linha = $stmt->fetch();
    $this->nome = $linha['nome'];
}
Vamos forçar algo de SQL Injection digitando na barra de endereço 127.0.0.1:8888/categorias-editar.php?id=2or1=1. Não obteremos nenhum resultado inesperado, porém o usuário também ficaria "sem saída". É bem difícil conseguirmos simular isso, mas existem programas que o fazem automaticamente, não importa se você tentar fazer manualmente e não conseguir fazer nenhuma vulnerabilidade. É importante sempre usarmos o prepare() quando formos passar algum valor.

Portanto, da mesma forma, voltaremos ao arquivo Categoria.php para alterar o método inserir(), em que temos um valor engessado:

public function inserir()
{
    $query = "INSERT INTO categorias (nome) VALUES (:nome)";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $this->nome);
    $stmt->execute();
}
Para ver se isto funciona como gostaríamos, vamos adicionar uma nova categoria ao nosso sistema, "Brinquedos", que aparecerá na listagem com id 6. Depois, faremos o mesmo em atualizar():

public function atualizar()
{
    $query = "UPDATE categorias set nome = :nome WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $this->nome);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
}
Para testarmos, editaremos a categoria recém criada "Brinquedos", alterando-a para "Brinquedo". Salvaremos, e tudo funciona bem. Continuando, excluir() é outro método que poderemos alterar:

public function excluir()
{
    $query = "DELETE FROM categorias WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
}
Feito isso, conseguiremos excluir qualquer uma das categorias com sucesso!

Nosso código está bem mais organizado e seguro para se trabalhar com PDO. Lembrando que o uso do bindValue() para poder usar o prepare() e depois o execute() não é obrigatório.

No entanto, sempre que um parâmetro for passado, para usarmos o bindValue(), é preciso fazer a preparação da query, e isto é muito importante.

Nessa aula, utilizamos o método PDO::prepare() para preparar uma conexão.

Qual das formas abaixo, é a forma correta de se usar o PDO::prepare()?

Criar um script SQL em uma string: $query = "SELECT ....."

Efetuar a conexão: $conexao = Conexao::pegarConexao();

Preparar a query em um Statement: $stmt = $conexao->prepare($query);

Executar o script com o método execute() do Statement: $stmt->execute();
Quando usamos o método prepare() do PDO, nos é retornado uma variavel do tipo PDOStatement. Mas, esse statement ainda não foi rodado no banco de dados e podemos trabalhar na query para passar parâmetros por exemplo. Alem disso, se fomos executar mais de uma vez a mesma query (mudando ou não os parâmetros), ela acaba sendo otimizada pelo banco de dados que já sabe a estrutura do seu script.

Nessa aula, aprendemos a utilizar o PDO::prepare(), que é um dos pontos mais importantes do php-pdo. Com ele, podemos passar valores para nossos scripts SQL de forma dinâmica. Isso, alem de trazer muito mais segurança para nosso código, deixa as interações com o Banco de Dados mais eficientes.

Vamos elaborar agora, um simples script php que podemos usar, para criar registros em nossa base de dados. Esse tipo de script é bem útil, quando por exemplo, querermos criar "massa de dados" em nosso sistema, para fins de testes por exemplo.

Nosso script, vai ter como objetivo, criar registros de diversos produtos e para isso, vamos seguir os passos a seguir:

Para deixar elegante nosso script, vamos gerar nomes aleatórios de roupas, então, antes de começar, certifique de que você tenha uma categoria Roupas cadastrado no seu banco de dados, e já pegue o ID dessa categoria. No meu caso, criei uma nova categoria Roupas que recebeu o ID 7.

Na raiz do diretório de nosso projeto, vamos criar um novo arquivo em branco chamado robo.php. Ele será responsável pelo nosso script. Não se esqueça de incluir nele o require_once para nosso arquivo global.

Para gerar o nome da roupa, vamos usar o script abaixo. Basicamente, criamos nele, 3 arrays. O primeiro, com tipos de roupas, o segundo, com o sexo a qual é indicado a roupa e o terceiro com a cor da roupa. E depois, usamos a função rand() do php para randomizar um número aleatório de 0 até o total de índices de cada array, assim, cada vez que rodamos esse script, temos um resultado diferente com uma combinação aleatória de cada opção do Array.

O Script ficou assim:

<?php
$tipo_roupa = ['Blusa', 'Camisa', 'Camiseta', 'Bermuda', 'Calça', 'Jaqueta'];
$sexo_roupa = ['Masculina', 'Feminina'];
$cor_roupa  = ['Preta', 'Vermelha', 'Azul', 'Amarela', 'Verde', 'Branca', 'Marrom', 'Rosa'];

$tipo_index = rand(0, 5);
$sexo_index = rand(0, 1);
$cor_index  = rand(0, 7);

$roupa = $tipo_roupa[$tipo_index] . ' ' . $sexo_roupa[$sexo_index] . ' ' . $cor_roupa[$cor_index];
Para testar, vamos só colocar ele em nosso arquivo robo.php. no final, coloque um echo $roupa; e acesse esse arquivo pelo navegador:

Teremos o resultado como: "Bermuda Feminina Azul" ou "Jaqueta Masculina Rosa" ou "Camiseta Feminina Vermelha" e assim por diante.

Agora, vamos continuar, fazendo um laço for que vai terminar quantos registros vamos incluir cada vez que rodamos nosso arquivo robo.php.

Depois, precisamos fazer nossa string com o INSERT do produto, pegar a conexão e passar como parâmetro do bindValue() no nome da roupa, o valor que geramos aleatoriamente no código acima.

Para os outros campos da tabela Produtos, como quantidade e preço, você também pode usar a função rand(); para gerar números aleatórios ;)

A primeira coisa que precisamos fazer, é criar nosso arquivo robo.php na raiz do nosso projeto. Nele, vamos abrir um bloco de php com <?php e fazer o require_once 'global.php';

Em seguida, vamos definir todos os valores gerais de nosso robô que são:

Número de roupas que queremos criar a cada vez que o robô for executado

Colocar uma variável para guardar o valor da categoria roupas, que é a categoria que vamos inserir registros.

Colocar os 3 arrays que foi mostrado acima. Já com seus respectivos valores: $tipo_roupa, $sexo_roupa e $cor_roupa.

Vamos agora, criar um laço for() que vai ser rodado exatamente o número de vezes na qual, especificamos no segundo passo.

Vamos criar todos os valores aleatórios que precisamos:

$tipo_index = rand(0, 5);

$sexo_index = rand(0, 1);

$cor_index = rand(0, 7);

$preco = rand(1, 100);

$quantidade = rand(1, 50);

Vamos criar a variável com nome de nossa roupa: $roupa = $tipo_roupa[$tipo_index] . ' ' . $sexo_roupa[$sexo_index] . ' ' . $cor_roupa[$cor_index];.

Agora, vamos fazer a query de INSERT na tabela de produtos

Vamos criar a variável $conexao com o método Conexao::pegarConexao().

Vamos criar a variável $stmt que recebe o retorno da $conexao->prepare($query);.

Vamos passar todos os valores aleatórios que criamos com o método bindValue().

$stmt->bindValue(':nome', $roupa);

$stmt->bindValue(':preco', $preco);

$stmt->bindValue(':quantidade', $quantidade);

$stmt->bindValue(':categoria_id', $categoria_id);

Vamos executar nossa query com o método $stmt->execute();;

Por fim, vamos aproveitar apenas para imprimir o nome da roupa que acabamos de cadastrar com um echo, ainda dentro do nosso laço for(): echo $roupa . ' Cadastrada com sucesso!<br>';

Nosso código vai ficar desse jeito:

<?php

require_once 'global.php';

$numero_de_roupas = 10;
$categoria_id = 7;
$tipo_roupa = ['Blusa', 'Camisa', 'Camiseta', 'Bermuda', 'Calça', 'Jaqueta'];
$sexo_roupa = ['Mascilona', 'Feminina'];
$cor_roupa  = ['Preta', 'Vermelha', 'Azul', 'Amarela', 'Verde', 'Branca', 'Marrom', 'Rosa'];

for ($x = 1; $x <= $numero_de_roupas; $x++) {

    $tipo_index = rand(0, 5);
    $sexo_index = rand(0, 1);
    $cor_index  = rand(0, 7);
    $preco      = rand(1, 100);
    $quantidade = rand(1, 50);
    $roupa = $tipo_roupa[$tipo_index] . ' ' . $sexo_roupa[$sexo_index] . ' ' . $cor_roupa[$cor_index];

    $query = "INSERT INTO produtos (nome, preco, quantidade, categoria_id)
    VALUES (:nome, :preco, :quantidade, :categoria_id)";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $roupa);
    $stmt->bindValue(':preco', $preco);
    $stmt->bindValue(':quantidade', $quantidade);
    $stmt->bindValue(':categoria_id', $categoria_id);
    $stmt->execute();

    echo $roupa . ' Cadastrada com sucesso!<br>';
}
Quando executarmos nossa página no navegador, acessando a URL: http://127.0.0.1:8888/robo.php, teremos o seguinte resultado:

Calça Feminina Amarela Cadastrada com sucesso!

Bermuda Feminina Rosa Cadastrada com sucesso!

Camiseta Mascilona Branca Cadastrada com sucesso!

Jaqueta Mascilona Azul Cadastrada com sucesso!

Blusa Mascilona Azul Cadastrada com sucesso!

Camiseta Mascilona Branca Cadastrada com sucesso!

Camiseta Mascilona Amarela Cadastrada com sucesso!

Calça Feminina Verde Cadastrada com sucesso!

Bermuda Feminina Marrom Cadastrada com sucesso!

Jaqueta Feminina Branca Cadastrada com sucesso!

OBS - O resultado final pode variar para você pois os valores são aleatórios. O importante é que todos os valores tenham sido cadastrados com sucesso! ;)


########## 04. Editando e excluindo produtos ##########


Feita a refatoração do nosso código para usarmos o prepare() do PDO e conseguirmos ter uma segurança muito maior, além de uma organização considerável no código, continuaremos lidando com a edição de produtos.

Já trabalhamos com o link do botão "Editar", sobre o qual passamos o mouse e vemos o id correspondente sendo exibido no canto inferior esquerdo da tela. Ao clicarmos nele, somos redirecionados a produtos-editar.php.

Clicaremos em qualquer um dos produtos e, da mesma forma como em categorias, há um formulário que vem preenchido com as informações do produto selecionado. No entanto, não é exatamente isto que ocorre, pois independentemente do produto selecionado, as informações são as mesmas, pois trata-se de dados engessados no HTML.

Em Categoria.php, temos o construtor recebendo um id igual a false, isto é, se não for passado nenhum valor no construtor do objeto, o id é considerado falso. Logo em seguida, é feita uma verificação quanto ao id. Lembrando que no PHP tudo que for diferente de false ou 0 é considerado true.

Então, após o if, o atributo id será carregado com o valor passado, e chamaremos o método carregar(), que por sua vez fará um SELECT carregando o id e buscando esta informação. Faremos o mesmo procedimento em Produto.php, em que criaremos o mesmo método:

public function carregar()
{
    $query = "SELECT nome, preco, quantidade, categoria_id FROM produtos WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
    $linha = $stmt->fetch();
    $this->nome = $linha['nome'];
    $this->preco = $linha['preco'];
    $this->quantidade = $linha['quantidade'];
    $this->categoria_id = $linha['categoria_id'];
}
Feito isso, precisaremos criar o método construtor, sob a mesma regra do if, verificando se foi passado um valor quando a classe foi instanciada, ou não:

public function __construct($id = false)
{
    if ($id) {
        $this->id = $id;
        $this->carregar();
    }
}
Para conferir seu funcionamento, vamos mexer no arquivo com o formulário de edição (produtos-editar.php) fazendo a chamada da classe Produtos.php:

<?php require_once 'global.php' ?>
<?php
    $id = $_GET['id'];
    $produto = new Produto($id);

    print_r($produto);
?>
Tudo funciona corretamente ao testarmos no navegador. Se usarmos o <pre>, o print será mostrado com quebra de linhas, facilitando sua visualização. Feito isso, poderemos deletar a linha referente à impressão. Continuando, precisaremos dos valores puxados para apresentá-los no formulário. Onde se lê o value do produto, daremos um echo na variável produto, que é o que também faremos com os demais campos:

<div class="form-group">
    <label for="nome">Nome do Produto</label>
    <input type="text" value="<?php echo $produto->nome ?>" class="form-control" placeholder="Nome do Produto" required>
</div>
<div class="form-group">
    <label for="preco">Preço do Produto</label>
    <input type="number" value="<?php echo $produto->preco ?>" step="0.01" min="0" class="form-control" placeholder="Preço do Produto" required>
</div>
<div class="form-group">
    <label for="quantidade">Quantidade do Produto</label>
    <input type="number" value="<?php echo $produto->quantidade ?>" min="0" class="form-control" placeholder="Quantidade do Produto" required>
</div>
<div class="form-group">
    <label for="nome">Categoria do Produto</label>
    <select class="form-control">
        <option value="1" selected>Livros</option>
        <option value="2">Jogos</option>
    </select>
</div>
Para a parte "Categoria do Produto", precisaremos trazer a lista completa de categorias, comparar linha a linha para sabermos qual é a que está sendo usada no momento, e então forçar o SELECT a marcá-la. O começo do código de produtos-editar.php ficará assim, da mesma maneira que fizemos na tela de inserção de produtos:

<?php require_once 'global.php' ?>
<?php
    $id = $_GET['id'];
    $produto = new Produto($id);
    $listaCategoria = Categoria::listar();
?>
Com isto, deletaremos um dos options e criaremos um foreach, alterando também o valor e o nome da categoria:

<div class="form-group">
    <label for="nome">Categoria do Produto</label>
        <select class="form-control">
            <?php foreach ($listaCategoria as $linha): ?>
                <option value="<?php echo $linha['id'] ?>" selected><?php echo $linha['nome'] ?></option>
            <?php endforeach ?>
        </select>
</div>
Ao atualizarmos a página no navegador, veremos que as outras categorias aparecem como opções, como gostaríamos, mas "Batman Arkahan City" está marcado como "Roupas", ou seja, com a última opção dentre as categorias, e não como "Jogos", que é a correta. Isso acontece porque usamos selected, que deletaremos da linha, deixando assim:

<option value="<?php echo $linha['id'] ?>"><?php echo $linha['nome'] ?></option>
Só que isso faz com que a última categoria fique selecionada, em vez da primeira. Como resolveremos isso? Vamos inspecionar o elemento para analisarmos o input, em que há os valores dos options, ou cada categoria com seu respectivo id. Para nos auxiliar, vamos voltar a imprimir o valor com print_r:

<?php
    $id = $_GET['id'];
    $produto = new Produto($id);

    print_r($produto);
    $listaCategoria = Categoria::listar();
?>
É preciso compararmos linha a linha para verificar se a categoria de uma determinada linha é igual àquela a qual o produto pertence. Vamos fazer isso deletando o print_r que acabamos de colocar e criando um bloco PHP com if. E onde temos o value do option, abriremos outro bloco.

Depois, incluiremos mais um bloco com a variável selected, em branco, porque se não for a última, o valor de selected será impresso às linhas seguintes. Assim, apenas uma das linhas do laço ficará com o valor selecionado, aquela na qual esta regra é verdadeira.

<label for="nome">Categoria do Produto</label>
    <select class="form-control">
        <?php $selected = '' ?>
        <?php foreach ($listaCategoria as $linha): ?>
            <?php
                if ($linha['id'] == $produto->categoria_id) {
                    $selected = 'selected';
                }
            ?>
            <option <?php echo $selected ?> value="<?php echo $linha['id'] ?>" selected><?php echo $linha['nome'] ?></option>
            <?php $selected = '' ?>
        <?php endforeach ?>
    </select>
Testaremos com diversos produtos, que agora aparecem com a categoria correspondente. Para confirmarmos isso, clicaremos no botão "Editar" de um livro, inspecionaremos o elemento, expandiremos o select, e veremos que apenas o option de "Livros", de value 1 possui o selected impresso, que é o que queríamos:

<select class="form-control">
    <option value="3">Filmes</option>
    <option value="2">Jogos</option>
    <option selected value="1">Livros</option>
    <option value="5">Revistas</option>
    <option value="4">Roupas</option>
</select>

Ainda falta efetuarmos a edição de categorias propriamente dita. Antes de fazermos isto, vamos incluir o Try/Catch para tratamento de erro (caso aconteça algum) em produtos-editar.php, algo que esquecemos de fazer anteriormente:

<?php
    try {
        $id = $_GET['id'];
        $produto = new Produto($id);
        $listaCategoria = Categoria::listar();
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Conferiremos se tudo permanece funcionando bem na página, e em seguida implementaremos o método de atualizar o produto, em Produto.php:

public function atualizar()
{
    $query = "UPDATE produtos SET nome = :nome, preco = :preco, quantidade = :quantidade, categoria_id = :categoria_id WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $this->nome);
    $stmt->bindValue(':preco', $this->preco);
    $stmt->bindValue(':quantidade', $this->quantidade);
    $stmt->bindValue(':categoria_id', $this->categoria_id);
    $stmt->bindValue(':id', $this->id);
    $stmt->execute();
}
Com isso, poderemos fazer a página que receberá as informações do formulário, que fará a instância de uma classe de Produto, e a atualização. Em produtos-editar.php, temos <form> contendo o method="post", porém a action não possui nada, não leva a lugar algum. Então, substituiremos # por produtos-editar-post.php, que é o arquivo que iremos criar.

Como se trata da edição de um produto que já existe, precisaremos indicar o que está sendo editado, além das informações em si. Como fazemos o carregamento do objeto via id, é necessário informarmos nesta paǵina qual deles deverá ser carregado.

No começo do <form> em produtos-editar.php, acrescentaremos um input:

<form action="produtos-editar-post.php" method="post">
<input type="hidden" name="id" value="<?php echo $produto->id ?>">
    <div class="row">
        <!-- código omitido -->
    </div>
</form>
Salvaremos tudo e testaremos no navegador, clicando na página com o lado direito do mouse e em "Exibir código fonte da página". Nele, será exibido que o input está com value="4".

No arquivo recém criado, produtos-editar-post.php, pegaremos todos os valores (id, nome, preco e quantidade e categoria_id) provenientes do formulário.

Depois, faremos a instância da classe Produto passando o id que temos, e o nosso construtor será utilizado para chamar o método carregar() automaticamente. Na sequência iremos atualizar todos os valores.

E se a pessoa só quiser atualizar o preço, por exemplo? Por que todos os valores deverão ser indicados?

Tecnicamente, se a pessoa quer editar apenas o preço, este é o único campo a ser alterado no formulário, e os demais permanecerão com os mesmos valores de antes.

Por fim, redirecionamos o usuário por meio do header() para produtos.php, que é a nossa página de listagem dos mesmos.

<?php
    require_once 'global.php';

    try {
        $id = $_POST['id'];
        $nome = $_POST['nome'];
        $preco = $_POST['preco'];
        $quantidade = $_POST['quantidade'];
        $categoria_id = $_POST['categoria_id'];

        $produto = new Produto($id);
        $produto->nome = $nome;
        $produto->preco = $preco;
        $produto->quantidade = $quantidade;
        $produto->categoria_id = $categoria_id;
        $produto->atualizar();

        header('Location: produtos.php');

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
Vamos testar? Na página de editar categorias, deletaremos "- 5 Livros" de "As Cronicas de Gelo e Fogo - 5 Livros", o preço passará a ser "100", e a quantidade, "3". A categoria será mantida. Clicaremos no botão "Salvar", mas ao atualizarmos a página obteremos um erro por não termos colocado os names em cada campo de produtos-editar.php, o que faremos a seguir:

<div class="form-group">
    <label for="nome">Nome do Produto</label>
    <input type="text" name="nome" value="<?php echo $produto->nome ?>" class="form-control" placeholder="Nome do Produto" required>
</div>
<div class="form-group">
    <label for="preco">Preço da Produto</label>
    <input type="number" name="preco" value="<?php echo $produto->preco ?>" step="0.01" min="0" class="form-control" placeholder="Preço do Produto" required>
</div>
<div class="form-group">
    <label for="quantidade">Quantidade do Produto</label>
    <input type="number" name="quantidade" value="<?php echo $produto->quantidade ?>" min="0" class="form-control" placeholder="Quantidade do Produto" required>
</div>
<div class="form-group">
    <label for="nome">Categoria do Produto</label>
    <select class="form-control" name="categoria_id">
        <!-- blocos de PHP -->
    </select>
</div>
Testando a mesma alteração, tudo funciona corretamente. Poderemos testar a edição de outros produtos, e obteremos o mesmo bom funcionamento!

Conseguimos editar os produtos tranquilamente no nosso projeto! O que falta implementarmos é o botão "Excluir" que, assim como "Editar", também passa os ids direitinho para o arquivo produtos-excluir-post.php via query string. No entanto este arquivo ainda não existe, e aparece em produtos.php.

Também precisaremos criar o método excluir() na classe Produto.php:

public function excluir()
{
    $query = "DELETE FROM produtos WHERE id = :id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue('id', $this->id);
    $stmt->execute();
}
O produtos-excluir-post.php, então, ficará da seguinte maneira:

<?php
    require_once 'global.php';

    try {
        $id = $_GET['id'];
        $produto = new Produto($id);
        $produto->excluir();

        header('Location: produtos.php');

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
Vamos testar para ver se funciona? Conseguimos excluir o produto "Bermuda" com sucesso.

No exercício da aula anterior, criamos um script robo.php para gerar registros de Produtos da categoria Roupas.

Nessa aula, fizemos tudo relacionado a edição e exclusão de produtos, agora, usando o método prepare() do PDO.

Vamos agora, alterar nosso robô para deixa-lo um mais completo, permitindo Editar ou Excluir grandes volumes de dados.

Vamos criar dois robôs, um de edição em lote, e outro de exclusão, vamos seguir as seguintes regras para cada um deles:

Edição em Lote:

Arquivo robo_editar.php

Os campos que serão editados serão apenas preço e quantidade

Os nomes dos produtos vão permanecer o mesmo

Os valores alterados (preço e quantidade) devem ser alterados para um valor aleatório

Exclusão em Lote:

Arquivo robo_excluir.php

Só poderemos excluir produtos que tenham uma quantidade igual ou menor a um parâmetro informado no começo do robô

Só poderemos excluir produtos com um preço menor ou igual a um parâmetro informado no começo do robô.

Para lhe ajudar, segue abaixo, o código do robô que fizemos no exercício da aula passada:

<?php

require_once 'global.php';

$numero_de_roupas = 10;
$categoria_id = 7;
$tipo_roupa = ['Blusa', 'Camisa', 'Camiseta', 'Bermuda', 'Calça', 'Jaqueta'];
$sexo_roupa = ['Mascilona', 'Feminina'];
$cor_roupa  = ['Preta', 'Vermelha', 'Azul', 'Amarela', 'Verde', 'Branca', 'Marrom', 'Rosa'];

for ($x = 1; $x <= $numero_de_roupas; $x++) {

    $tipo_index = rand(0, 5);
    $sexo_index = rand(0, 1);
    $cor_index  = rand(0, 7);
    $preco      = rand(1, 100);
    $quantidade = rand(1, 50);
    $roupa = $tipo_roupa[$tipo_index] . ' ' . $sexo_roupa[$sexo_index] . ' ' . $cor_roupa[$cor_index];

    $query = "INSERT INTO produtos (nome, preco, quantidade, categoria_id)
    VALUES (:nome, :preco, :quantidade, :categoria_id)";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':nome', $roupa);
    $stmt->bindValue(':preco', $preco);
    $stmt->bindValue(':quantidade', $quantidade);
    $stmt->bindValue(':categoria_id', $categoria_id);
    $stmt->execute();

    echo $roupa . ' Cadastrada com sucesso!<br>';
}

Vamos começar pelo robô de edição!

Vamos criar um novo arquivo na raiz do projeto chamado robo_editar.php.

Vamos então, começar criando nosso bloco de php com <?php e já, incluir no require_once no nosso arquivo global.

Precisamos de uma lista completa de todos os produtos que temos em nosso Banco de Dados, então, para isso, vamos usar o método Produto::listar(); que já fizemos.

Agora, vamos criar a string com a query de UPDATE da seguinte forma: UPDATE produtos SET preco = :preco, quantidade = :quantidade WHERE id = :id.

E vamos criar nossa variável de conexão a partir do método Conexao::pegarConexao().

Vamos depois disso, usar o foreach() no resultado da listagem de produtos, assim, vamos trabalhar linha a linha para cada retorno.

Dentro do foreach(), vamos criar nossa variável $stmt a partir do método $conexao->prepare($query);.

Agora, vamos usar a função rand() do php para popular duas variáveis $novo_preco e $nova_quantidade respectivamente.

Agora, vamos passar todos os valores necessários em nossa query que são:

$stmt->bindValue(':preco', $novo_preco);
$stmt->bindValue(':quantidade', $nova_quantidade);
$stmt->bindValue(':id', $produto['id']);
Vamos Executar nossa query com $stmt->execute();;

E por fim, vamos imprimir na tela um resultado elegante para conseguirmos validar nosso script:

echo $produto['nome'] . ' Preço alterado de: ' . $produto['preco'] . ' para: ' . $novo_preco . ' Quantidade alterado de: ' . $produto['quantidade'] . ' para: ' . $nova_quantidade . '<br>';
Nosso código pronto vai ficar da seguinte forma:

<?php

require_once 'global.php';

$lista_produtos = Produto::listar();

$query = "UPDATE produtos SET preco = :preco, quantidade = :quantidade WHERE id = :id";
$conexao = Conexao::pegarConexao();

foreach ($lista_produtos as $produto) {
    $stmt = $conexao->prepare($query);

    $novo_preco = rand(0, 100);
    $nova_quantidade = rand(0, 50);

    $stmt->bindValue(':preco', $novo_preco);
    $stmt->bindValue(':quantidade', $nova_quantidade);
    $stmt->bindValue(':id', $produto['id']);
    $stmt->execute();
    echo $produto['nome'] . ' Preço alterado de: ' . $produto['preco'] . ' para: ' . $novo_preco . ' Quantidade alterado de: ' . $produto['quantidade'] . ' para: ' . $nova_quantidade . '<br>';
}
Quando executo ele, tenho o seguinte resultado na tela chamando a URL http://127.0.0.1:8888/robo_editar.php:

As Cronicas de Gelo e Fogo - 5 Livros Preço alterado de: 49.00 para: 88 Quantidade alterado de: 1 para: 37

Batman Arkahan City Preço alterado de: 76.00 para: 1 Quantidade alterado de: 14 para: 34

Bermuda Feminina Marrom Preço alterado de: 19.00 para: 71 Quantidade alterado de: 6 para: 3

Bermuda Feminina Rosa Preço alterado de: 20.00 para: 11 Quantidade alterado de: 44 para: 32

Blusa Mascilona Azul Preço alterado de: 88.00 para: 3 Quantidade alterado de: 43 para: 10

Calça Feminina Amarela Preço alterado de: 61.00 para: 96 Quantidade alterado de: 26 para: 3

Calça Feminina Verde Preço alterado de: 28.00 para: 24 Quantidade alterado de: 12 para: 27

Camiseta Mascilona Amarela Preço alterado de: 29.00 para: 68 Quantidade alterado de: 13 para: 3

Camiseta Mascilona Branca Preço alterado de: 72.00 para: 93 Quantidade alterado de: 29 para: 24

Camiseta Mascilona Branca Preço alterado de: 79.00 para: 36 Quantidade alterado de: 1 para: 45

Jaqueta Feminina Branca Preço alterado de: 95.00 para: 72 Quantidade alterado de: 26 para: 43

Jaqueta Mascilona Azul Preço alterado de: 18.00 para: 68 Quantidade alterado de: 49 para: 35

Jogador Nº 1 Preço alterado de: 85.00 para: 41 Quantidade alterado de: 40 para: 49

O Poderoso Chefão Preço alterado de: 67.00 para: 89 Quantidade alterado de: 47 para: 37

O Senhor dos Anéis, Trilogia Completa Preço alterado de: 4.00 para: 42 Quantidade alterado de: 39 para: 10

Agora, vamos fazer nosso robô de exclusão. Esse é relativamente mais simples que o anterior.

Vamos criar o arquivo robo_excluir.php na raiz do nosso projeto, abrir um bloco <?php nele e já fazer o require_once do nosso arquivo global.php.

Vamos criar duas variáveis $preco_base e $quantidade_base respectivamente, e nelas, determinar o valor de corte para nossa regra de exclusão.

Vamos fazer nossa string $query com o script SQL de DELETE: DELETE FROM produtos WHERE preco <= :preco AND quantidade <= :quantidade.

Agora, criamos a variável $conexao a partir do método Conexao::pegarConexao()

Passamos os valores usando bindValue():

$stmt->bindValue(':preco', $preco_base);

$stmt->bindValue(':quantidade', $quantidade_base);

Por fim, executamos nosso script com $stmt->execute().

Uma dica, você pode usar o método PDOStatement::rowCount para obter o número de linhas afetadas: echo $stmt->rowCount() . ' excluidos com sucesso!';.

Nosso código ficou da seguinte forma:

<?php

require_once 'global.php';

$preco_base = 50;
$quantidade_base = 20;

$query = "DELETE FROM produtos WHERE preco <= :preco AND quantidade <= :quantidade";
$conexao = Conexao::pegarConexao();
$stmt = $conexao->prepare($query);
$stmt->bindValue(':preco', $preco_base);
$stmt->bindValue(':quantidade', $quantidade_base);
$stmt->execute();

echo $stmt->rowCount() . ' excluidos com sucesso!';
E ao executa-lo acessando a página pela URL: http://127.0.0.1:8888/robo_excluir.php:

2 excluidos com sucesso!


########## 05. Detalhes da Categoria ##########


Aparentemente está tudo certo no nosso sistema, e conseguimos fazer tudo aquilo que se relaciona aos produtos e às categorias. Na parte de Produtos, há o botão "Criar novo produto" e, ao clicarmos nele, temos o formulário para preenchimento. Também existem os botões "Editar" e "Excluir", que funcionam perfeitamente.

Na parte de Categorias, conseguimos fazer o mesmo, por meio dos botões "Criar nova categoria", "Editar" e "Excluir". Há, porém, algo que ainda não fizemos: a tela de detalhes da categoria. Diferentemente de produtos, que não possui nenhum link em seus nomes, nesta nova tela teremos cada id e nome do produto apontando para categorias-detalhe.php.

Não passamos nenhum valor da categoria clicada via string ao link, então abriremos categorias.php e, no foreach, o link caregorias-detalhe.php aparece duas vezes. Neles, são exibidos o id e nome, então repetiremos o que foi feito com os botões, deixando o código assim:

<?php foreach ($lista as $linha): ?>
    <tr>
        <td><a href="/categorias-detalhe.php?id=<?php echo $linha['id'] ?>" class="btn btn-link"><?php echo $linha['id'] ?></a></td>
        <td><a href="/categorias-detalhe.php?id=<?php echo $linha['id'] ?>" class="btn btn-link"><?php echo $linha['nome'] ?></a></td>
        <td><a href="/categorias-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a></td>
        <td><a href="/categorias-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
    </tr>
<?php endforeach ?>
Com isso, o id é passado corretamente à nossa página. Clicando em "Filmes", carregamos a categoria que não queremos, no caso, "Livros". Vamos ajustar isto indo à categorias-detalhe.php, em que incluiremos inicialmente o require_once para o arquivo global, e depois o Try/Catch:

<?php require_once 'global.php' ?>
<?php
    try {
        $id = $_GET['id'];
        $categoria = new Categoria($id);
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
No mesmo arquivo, onde é exibida a tag <dd> com o valor do id da categoria, abriremos um PHP, fazendo o mesmo onde que temos "Livros", com o atributo nome:

<dl>
    <dt>ID</dt>
    <dd><?php echo $categoria->id ?></dd>
    <dt>Nome</dt>
    <dd><?php echo $categoria->nome ?></dd>
    <dt>Produtos</dt>
    <dd>
        <ul>
            <li><a href="/produtos-editar.php">Senhor dos Aneis</a></li>
            <li><a href="/produtos-editar.php">O Guia do Mochileiro das Galaxias</a></li>
        </ul>
    </dd>
</dl>
Salvaremos tudo e testaremos no navegador. Agora, sim, clicamos na categoria "Filmes" para acessarmos os detalhes, e a categoria exibida é a mesma, isto é, "Filmes", como gostaríamos. Em seguida, testaremos os produtos na página de detalhes da categoria.

Poderíamos fazer o método carregar() trazer as categorias, mas não queremos alterá-lo, pois além dele ser usado na listagem delas, o método aparece nas telas de inserção e edição de produtos.

Na tela em que listamos apenas os valores das categorias, não é interessante saber quais são os produtos. Na página de detalhes, porém, é interessante sim.

Criaremos, portanto, um método que irá carregar um atributo novo para a listagem dos produtos desta categoria. Para isso, acessaremos Categoria.php e incluiremos produtos abaixo de nome:

public $id;
public $nome;
public $produtos;
Feito isto, neste mesmo arquivo, criaremos uma função para carregar estas informações. No entanto, interagir com o banco de dados relacionado a produtos é uma função da classe Produto, portanto criaremos um novo método nela, o qual trará uma listagem baseada na categoria passada como parâmetro.

Esta listagem será devolvida ao método, e ele por sua vez a devolverá à nossa tela:

public function carregarProdutos()
{

}
Vamos deixar o código assim por enquanto, e abrir Produto.php para incluirmos o novo método logo abaixo de listar():

public static function listarPorCategoria($categoria_id)
{
    $query = "SELECT id, nome, preco, quantidade FROM produtos WHERE categoria_id = :categoria_id";
    $conexao = Conexao::pegarConexao();
    $stmt = $conexao->prepare($query);
    $stmt->bindValue(':categoria_id', $categoria_id);
    $stmt->execute();
    return $stmt->fetchAll();
}
Usaremos o fetchAll() por retornarmos mais de uma linha, lembrando que categoria_id, neste caso, não é um atributo da classe, e sim o valor que estamos passando via parâmetro.

Voltaremos a Categoria.php e seguiremos preenchendo o método recém criado:

public function carregarProdutos()
{
    $this->produtos = Produto::listarPorCategoria($this->id);
}
Assim, a partir do momento em que chamamos o método carregarProdutos() o atributo de produtos estará populado com a lista que temos nesta categoria específica. Voltaremos a categorias-detalhe.php, em que fazemos a instância de categoria, e acrescentaremos:

<?php require_once 'global.php' ?>
<?php
    try {
        $id = $_GET['id'];
        $categoria = new Categoria($id);
        $categoria->carregarProdutos();
        $listaProdutos = $categoria->produtos;
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Com isso, na parte em que há <ul> com a listagem de produtos na categoria, faremos o foreach para imprimirmos um nome por vez. Deletaremos uma das linhas da listagem para incluirmos o endforeach.

É preciso mostrar o nome do produto, e fazer a query string passando o id junto ao link que redirecionará o usuário à página de edição:

<dl>
    <dt>ID</dt>
    <dd><?php echo $categoria->id ?></dd>
    <dt>Nome</dt>
    <dd><?php echo $categoria->nome ?></dd>
    <dt>Produtos</dt>
    <dd>
        <ul>
            <?php foreach($listaProdutos as $linha): ?>
                <li><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>"><?php echo $linha['nome'] ?></a></li>
            <?php endforeach ?>
        </ul>
    </dd>
</dl>
Vamos dar uma olhada em outra categoria para confirmar que a listagem está aparecendo direitinho? Clicaremos em "Livros" e seremos redirecionados à página de detalhes correspondente e, ao clicarmos em qualquer um dos produtos, seremos redirecionados à página de edição da categoria.

Porém, na página de detalhes, "Revistas" não lista nenhum produto, isto porque realmente não há nenhum produto nesta categoria. Então, seria legal fazermos o count para estes casos em que não há nenhum produto em determinada categoria, e exibirmos uma mensagem ao usuário.

Então, em categorias-detalhe.php após a tag <dt> de "Produtos", abriremos um PHP com if para quando listaProdutos for maior que 0, e se este for o caso, mostraremos os detalhes:

<dt>ID</dt>
<dd><?php echo $categoria->id ?></dd>
<dt>Nome</dt>
<dd><?php echo $categoria->nome ?></dd>
<dt>Produtos</dt>
<?php if (count($listaProdutos) > 0): ?>
    <dd>
        <ul>
            <?php foreach($listaProdutos as $linha): ?>
                <li><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>"><?php echo $linha['nome'] ?></a></li>
            <?php endforeach ?>
        </ul>
    </dd>
<?php else: ?>
    <dd>Não existem produtos para esta categoria</dd>
<?php endif ?>
Ao carregarmos a página de detalhes de "Revistas", exibe-se a mensagem que acabamos de implementar, como gostaríamos, já que não há nenhum produto cadastrado naquela categoria. Nosso sistema está completo.

Chegamos ao fim da segunda parte do curso de PHP com PDO. Conseguimos concluir o sistema de estoque completamente, lidando com a parte de Produtos, sua listagem, adição, edição e exclusão. Fizemos várias melhorias na parte de categorias, e também na integração de uma entidade à outra.

Vimos a preparação de queries que, além de tornar o código mais organizado, deixa-o muito mais seguro, algo que o PDO traz de forma nativa, sendo uma de suas maiores vantagens, além da abstração da conexão, que também vimos.

Espero que tenham gostado, até a próxima!


