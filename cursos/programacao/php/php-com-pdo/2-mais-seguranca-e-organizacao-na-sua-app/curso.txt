########## 01. Listagem de produtos ##########


Olá, meu nome é Mario, sejam bem vindos à segunda parte do curso de PHP com PDO. Neste curso, falaremos sobre o que envolve os produtos de nosso sistema, além de fazermos algumas melhorias na parte de categorias, desenvolvida na primeira parte.

Então, se você ainda não fez a primeira parte do curso, sugiro fortemente que o faça, para que você tenha toda a base necessária, com dicas sobre as conexões, as formas com as quais poderemos fazer consultas nos bancos de dados, e a manipulação de informações do mesmo.

Com isso, seguiremos trabalharemos com a preparação de queries, funcionalidade muito interessante trazida pelo PDO, que implica em basicamente passarmos um parâmetro em vez de concatenar valores diretamente em uma query.

Isto traz muito mais segurança, além de deixar o código muito mais organizado.

Então, vamos começar?

No curso anterior, conseguimos fazer a inclusão, exclusão e edição de categorias, além de visualizá-las e carregá-las em uma listagem. Porém, nosso sistema também é composto de produtos, e precisamos desenvolver todo o fluxo para lidarmos com eles também, isto é, para cadastramentos, exclusões e listagem.

Vamos começar a trabalhar com isso?

Acessando o menu "Produtos" na página do navegador, veremos "O Senhor dos Anéis" cadastrado, de id 1, com preço R$ 80,55, quantidade 2 e categoria Livros. Esta tela é um pouco mais complexa que a de categorias, por trazer mais informações.

Vamos abrir produtos.php, localizado na raiz do projeto. Ele possui basicamente a mesma estrutura dos demais arquivos com que trabalhamos anteriormente, com tabelas mocadas, isto é, fixas ao HTML, não dinâmico, servindo apenas para termos uma visão do front end.

Começaremos repetindo o que fizemos com as categorias, criando uma classe para representar a entidade Produto no sistema. Ou seja, em classes, criaremos Produto.php, em que representaremos todos os campos da parte de produtos com atributos:

<?php

class Produto
{
    public $id;
    public $nome;
    public $preco;
    public $quantidade;
    public $categoria;
}
Porém, como estas informações estão representadas no banco de dados? Para conferir, vamos abrir o script de criação do banco de dados, banco_de_dados.sql. Na parte de produtos, temos o id, nome, preco, quantidade e categoria_id, pois logo em seguida criamos uma FOREIGN KEY, fk_categorias, que funciona como chave estrangeira no banco de dados, cuja categoria_id representa o id da tabela categorias.

Para trabalharmos da mesma forma como fazemos no banco de dados na nossa classe, o atributo categoria, previamente criado, será convertido para categoria_id.

Começaremos pela listagem de produtos, que será apresentada ao usuário, e trabalharemos com o método listar() que a retornará para nós. Vamos manter o padrão estabelecido na parte de categorias - sabemos que todas as classes que representam as entidades terão o método listar() para os registros da entidade.

Para a query de consulta, você poderá estar se perguntando se não teríamos o mesmo efeito se escrevessemos "*$ FROM nome da tabela". Sim, teríamos. No entanto, isto não é nem um pouco recomendado, pois não sabemos como esta estrutura ficará futuramente. É legal sermos fiéis ao que precisamos no SELECT. Neste caso, como todos estes campos serão utilizados, deixaremos isso bem explícito em nosso código.

Faremos também a requisição de conexão, lembrando que agora não precisaremos de nenhum require_once na classe para pegarmos o método de conexão que temos, pois já temos o autoloader, então, quando este ponto for alcançado, ele tentará buscar por esta classe, cairá no autoloader, o qual fará o require, e aí, sim, o método funcionará.

Executaremos a query com o método query() para obtermos retorno a partir da função fetchAll(), da classe PDOStatement.

O código ficará assim:

<?php

class Produto
{
    public $id;
    public $nome;
    public $preco;
    public $quantidade;
    public $categoria_id;

    public static function listar()
    {
        $query = "SELECT id, nome, preco, quantidade, categoria_id FROM produtos";
        $conexao = Conexao::pegarConexao();
        $resultado = $conexao->query($query);
        $lista = $resultado->fetchAll();
        return $lista;
    }
}
Vamos testar para ver se funciona, utilizando a tag <pre> e print_r no próprio arquivo produtos.php, em que serão listadas estas informações. Antes de mais nada, faremos o require_once para o arquivo global.php, acrescentando a linha <?php require_once 'global.php' ?> no topo do código.

Agora temos o arquivo global.php, que carrega todas as informações de que nossa página precisará. Tudo que chamamos de compilador, que é este bloco de código e não é uma classe, precisa estar contido em um Try/Catch.

<?php
    try {
        $lista = Produto::listar();
        echo '<pre>';
        print_r($lista);
        echo '</pre>';
        exit;

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Feito isso, testaremos novamente, e será exibida uma página com uma matriz de vários índices, sendo que cada um é um array que representa uma linha do nosso banco de dados.

Temos os livros cadastrados, jogos, e assim por diante. Vimos, portanto, que nossa lista funciona direitinho. Podemos deletar o debug no try, mantendo apenas o método listar():

<?php
    try {
        $lista = Produto::listar();
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
Agora, precisaremos ir à parte do HTML em produtos.php, em que há uma tabela e, entre as tags <tbody> e <tr> faremos o foreach para o laço que irá passar por cada linha do array e imprimir os valores de que precisamos.

Usaremos a forma alternativa de controle do PHP neste momento, pois estamos misturando-o com HTML, para fins de organização do código.

<?php foreach ($lista as $linha): ?>
<tr>
    <!-- informações referentes a um dos livros cadastrados -->
</tr>
<?php endforeach ?>
Ao abrirmos um PHP usando um comando e fechando-o logo em seguida, não é preciso utilizar o ponto e vírgula (;), pois o fechamento do PHP já é o suficiente.

Vamos testar o que foi feito até aqui! Serão impressos os mesmos valores em cinco linhas, que é o que temos no nosso banco de dados. Desta vez, queremos que apareçam os valores de cada linha.

Em relação ao preço, só estamos armazenando o valor, não o R$. Sendo assim, manteremos isto no HTML, colocando o PHP depois dele. Voltaremos a produtos.php e o deixaremos assim:

<?php foreach ($lista as $linha): ?>
<tr>
    <td><?php echo $linha['id'] ?></td>
    <td><?php echo $linha['nome'] ?></td>
    <td>R$ <?php echo $linha['preco'] ?></td>
    <td><?php echo $linha['quantidade'] ?></td>
    <td><?php echo $linha['categoria_id'] ?></td>
    <td><a href="/produtos-editar.php" class="btn btn-info">Editar</a></td>
    <td><a href="#" class="btn btn-danger">Excluir</a></td>
</tr>
<?php endforeach ?>
Testaremos novamente e veremos que temos o id de cada registro, bem como os nomes, preços e quantidades. Porém são exibidos os números das categorias, e não os nomes, e isto não é o que queremos por não ser nem um pouco prático.

Vamos trabalhar de maneira que tenhamos um carregamento completo do que precisamos desta listagem, alterando nossa query. No arquivo Produto.php, quebraremos a linha referente à query para que ela não fique muito extensa, o que não trará nenhum problema no PHP desde que se coloque o ponto e vírgula no final.

public static function listar()
{
    $query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
                        FROM produtos p
                        INNER JOIN categorias c ON p.categoria_id = c.id";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
Ao usarmos categoria_nome conseguimos diferenciar o array retornado pelo fetchAll(), que seguirá exatamente o que colocamos no SELECT. Por meio dos alias, com as, damos um apelido para o campo, que em vez de aparecer como nome, será c.nome.

Não alteraremos nada e veremos se tudo continua funcionando como antes. As categorias ainda aparecem com o número, e não o nome. Assim, no campo em que as apresentamos, usaremoscategoria_nome no foreach do HTML, em vez de imprimirmos categoria_id. Em produtos.php, portanto, teremos:

<td><?php echo $linha['categoria_nome'] ?></td>
Salvaremos e atualizaremos a página, e as categorias são apresentadas como gostaríamos, com seus nomes, e não números!

Nossa listagem de produtos está funcionando direitinho, com um pequeno porém: vocês lembram que na listagem de categorias acrescentamos um if para verificar quantos registros são retornados, e assim exibirmos uma mensagem amigável ao usuário caso não exista nada cadastrado no banco de dados?

Precisaremos fazer o mesmo nesta parte de produtos. Vamos abrir produtos.php e incluir na tabela um if com o método count():

<div class="col-md-12">
    <?php if (count($lista) > 0): ?>
    <table class="table">
        <thead>
        <tr>
            <!-- código omitido -->
        </tr>
        </thead>
    </table>
    <?php else: ?>
        <p>Nenhum produto cadastrado</p>
    <?php endif ?>
</div>
Testando no navegador, veremos que isso não afeta nossa página, isto é, tudo continua funcionando bem. Para confirmarmos, pode-se forçar a regra inversa, substituindo > por <= na linha abaixo:

<?php if (count($lista) <= 0): ?>
Assim, quando atualizamos a página, será exibida a mensagem "Nenhum produto cadastrado". Deixaremos o código da maneira como estava anteriormente.

Outro ponto feito nas categorias que ainda não implementamos são os ids dos nossos botões. Ao passarmos o mouse sobre eles, seus endereços não mostram nenhum id ou ação a ser tomada.

Em produtos.php, passaremos então o valor do id do produto via query string, simplesmente acrescentando o ponto de interrogação, e a variável igual a valor, que no caso é dinâmico.

O botão Excluir ainda não possui um link, porém poderemos estipular que ele seguirá com o mesmo padrão da página de categoria. O código ficará da seguinte maneira:

<td><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a></td>
<td><a href="/produtos-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
Feito isso, vamos salvar o arquivo e atualizar a página. Ao passarmos o mouse novamente sobre os botões, desta vez veremos nos links no canto inferior esquerdo o id correspondente aos produtos.

Parece um tanto desorganizado, porque a listagem está seguindo a ordem das categorias, e não dos nomes dos produtos. Vamos alterar isso indo à classe Produto.php, em que acrescentaremos um ORDER BY na $query:

$query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
          FROM produtos p
          INNER JOIN categorias c ON p.categoria_id = c.id
                    ORDER BY p.nome ";
Tudo certo! E você poderá organizar a listagem da maneira como achar melhor.

Nessa aula fizemos nossa classe Produto e nosso primeiro método Produto::listar(), no qual usamos um INNER JOIN na tabela de categorias para trazer o nome da categoria na listagem dos produtos. Sem isso só conseguíamos mostrar o ID da categoria, que é um campo da tabela de produtos.

Existe uma outra forma.

O que poderíamos ter feito para não usar o INNER JOIN em nosso SELECT é, dentro do foreach, da listagem de produtos, ter usado o método carrega da Classe Categoria para carregar a entidade de cada categoria e, assim, exibido o nome dela a partir da própria entidade. Isso é o que chamamos de Lasy Loading.

Embora para essa situação usar Lazy Loading não seja a melhor escolha, pois vai gerar um excesso grande de processamento, além de deixar nosso código um pouco desorganizado, vamos alterar nosso código de listagem, para ver essa técnica funcionando.

OBS: Mais pra frente em nosso curso, vamos utilizar a técnica de Lazy Loading de uma forma parecida, onde tem sua aplicabilidade muito mais válida. =)

Precisamos alterar o método listar() da classe classes/Produto.php:

public static function listar()
{
    $query = "SELECT p.id, p.nome, preco, quantidade, categoria_id, c.nome as categoria_nome
                FROM produtos p
                INNER JOIN categorias c ON p.categoria_id = c.id
                ORDER BY p.nome ";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
E o bloco do foreach() do arquivo produtos.php:

<?php foreach ($lista as $linha): ?>
<tr>
    <td><?php echo $linha['id'] ?></td>
    <td><?php echo $linha['nome'] ?></td>
    <td>R$ <?php echo $linha['preco'] ?></td>
    <td><?php echo $linha['quantidade'] ?></td>
    <td><?php echo $linha['categoria_nome'] ?></td>
    <td><a href="/produtos-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a></td>
    <td><a href="/produtos-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
</tr>
<?php endforeach ?>

Para fazer isso, vamos começar tirando todo o bloco do INNER JOIN e suas referências de nosso SELECT dessa forma:

$query = "SELECT p.id, p.nome, preco, quantidade, categoria_id
                  FROM produtos p
                  ORDER BY p.nome ";
Agora, vamos alterar, dentro do bloco do foreach() do arquivo produtos.php, para tirar a refeência ao campo do nome da categoria que vinha em nossa query antes da alteração. Alterando a linha: <td><?php echo $linha['categoria_nome'] ?></td> para <td><?php echo $linha['categoria_id'] ?></td>.

Agora, vamos criar um novo bloco de php logo abaixo da linha do foreach() e colocar o seguinte código:

<?php $categoria = new Categoria($linha['categoria_id']); ?>
E por fim, vamos usar o comando echo com o atributo nome da classe Categoria em vez de mostrar o ID da categoria na coluna. Alterando a linha <td><?php echo $linha['categoria_id'] ?></td> para <td><?php echo $categoria->nome ?></td>

Teremos o mesmo resultado de antes, mas com uma forma diferente de obter os dados!


########## 02. Inserção de produtos ##########


Neste momento, tudo o que fizemos em relação à listagem de produtos funciona bem. Em seguida, queremos conseguir incluir novos produtos no sistema. Para isso, vamos clicar no botão "Criar novo produto" na página do navegador.

Somos redirecionados a outra página com um formulário contendo nome do produto, preço, quantidade e categoria - que não está sendo listado corretamente -, além do botão "Salvar". Começaremos ajustando esta página, produtos-criar.php, para trabalharmos em cima dela depois.

De imediato pode-se notar que estão faltando os names nos inputs, para podermos recuperar as informações quando elas forem submetidas ao servidor.

Assim, em cada um destes campos incluiremos o name correspondente no código: name="nome" para "Nome do Produto", name="preco" para "Preço do Produto", name="quantidade" para "Quantidade de Produto". E no select referente à "Categoria do Produto", acrescentaremos name="categoria_id".

Agora, precisaremos fazer com que esta lista de categorias do formulário funcione, ou seja, é necessário um método para listarmos isso. Ou poderemos usar o método que já criamos na classe Categoria.php, pois listar é uma responsabilidade delas. Vamos relembrá-lo?

Em Produto.php criamos um método estático, o que não ocorre em Categoria.php. A diferença entre eles é que um método estático não se relaciona com nada além do que existe na própria classe, no objeto propriamente dito. Significa que ele não faz referência a outros métodos ou atributos do objeto.

O método estático se encaixa bem no nosso caso, então, aproveitando, vamos regularizar isso, convertendo o método, a ser utilizado na listagem de categorias:

public static function listar()
{
    $query = "SELECT id, nome FROM categorias";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
No try de categorias.php, fazemos a instância e depois chamamos o método listar(). Como ele é estático agora, não precisaremos instanciá-lo, e o código ficará assim:

<?php
    try {
        $lista = Categoria::listar();
    } catch(Exception $e) {
        Erro::trataErro($e);
    }
Vamos conferir se a página de listagem de categorias continua funcionando como esperado.

Tendo confirmado isto, voltaremos a produtos-criar.php para fazermos o require_once do arquivo global.php, e criarmos um bloco de PHP para o Try/Catch.

Salvaremos o código e retornaremos à página de inserção de novo produto no navegador. Aparentemente, tudo funciona corretamente, mas para confirmar incluiremos o debug para popularmos o valor:

<?php require_once 'global.php' ?>
<?php
    try {
        $listaCategoria = Categoria::listar();

        echo '<pre>';
        print_r($listaCategoria);
        echo '</pre>';

        exit;
    } catch (Exception $e) {
        Erro::trataErro($e);
    }
?>
A listagem de categorias aparece da maneira como esperávamos! Vamos deletar o debug que fizemos, e incluir um foreach no select para termos várias opções.

No select do arquivo produtos-criar.php há dois valores, correspondentes a "Livros" e "Revistas". Vamos manter apenas um deles, e incluir o foreach:

<div class="form-group">
    <label for="nome">Categoria do Produto</label>
    <select class="form-control" name="categoria_id">
        <?php foreach ($listaCategoria as $linha): ?>
            <option value="<?php echo $linha['id'] ?>"><?php echo $linha['nome'] ?></option>
        <?php endforeach ?>
    </select>
</div>
Com isso, temos mais opções de seleção na parte de "Categoria do Produto", quando um novo produto for inserido na tabela. Para sabermos se o value está funcionando bem, podemos inspecionar o elemento no navegador e confirmar que cada categoria possui um valor diferente:

<option value="1">Livros</option>
<option value="2">Jogos</option>
<option value="3">Filmes</option>
<option value="4">Roupas</option>
<option value="5">Revistas</option>
E já que organizamos os produtos em ordem alfabética a partir dos seus nomes, vamos fazer o mesmo em relação às categorias. Na classe Categoria.php, deixaremos o query da seguinte forma:

$query = "SELECT id, nome FROM categorias ORDER BY nome";
Agora temos a listagem das categorias da tabela de produtos! Mas e se não houver nenhuma categoria cadastrada no sistema? Imaginem a situação em que um sistema acabou de ser instalado, e não existir nada além do banco de dados, e o usuário quer cadastrar um produto. O que acontecerá?

Não poderemos inserir um novo produto sem que haja uma categoria vinculada a ele.

Portanto, precisaremos fazer uma verificação que contará o número de categorias que temos. E se não existir nenhuma, não deixaremos que um usuário cadastre um novo produto.

Sendo assim, vamos retornar a produtos-criar.php e colocar o if com count antes da exibição do formulário ao usuário, entre as <div>s do título e a abertura do <form>:

<div class="row">
    <!-- código omitido -->
</div>
<?php if (count($listaCategoria) > 0): ?>
    <form action="produtos-criar-post.php" method="post">
        <!-- código omitido -->
    </form>
<?php else: ?>
    <p>Nenhuma categoria cadastrada no sistema. Por favor, crie uma categoria antes de cadastrar um produto.</p>
<?php endif ?>
Visualmente, nada foi afetado em nossa página. Então, para testarmos, usaremos a técnica de inverter o if, desta vez acrescentando !, o operador de negação, para todo o argumento:

<?php if (!(count($listaCategoria) > 0)): ?>
A mensagem será exibida corretamente. Vamos tirar a negação para voltarmos ao estado anterior.

Nossa tela de inserção de novos produtos está praticamente finalizada, falta apenas acrescentarmos o método para o cadastro em si. Faremos isto seguindo o padrão definido na parte de categorias. Então, abriremos Produto.php, em que teremos:

public function inserir()
{
    $query = "INSERT INTO produtos (nome, preco, quantidade, categoria_id)
                        VALUES ('" . $this->nome . "', " . $this->preco . ", " . $this->quantidade . ", " . $this->categoria_id . ")";
    $conexao = Conexao::pegarConexao();
    $conexao->exec($query);
}
Para verificar se o código funciona, precisaremos criar uma página na raiz do projeto, que instanciará a classe Produto.php, irá popular os atributos que queremos inserir, e que depois chamará este método, da mesma forma que fizemos com as categorias.

Também precisamos fazer com que o formulário envie os dados para este arquivo. Portanto, vamos voltar a produtos-criar.php, em que veremos que a tag <form> já está com method="post", corretamente.

Criaremos produtos-criar-post.php, em que chamaremos o require_once do arquivo global, e acrescentaremos o Try/Catch. Precisamos resgatar os valores obtidos por meio do formulário, instanciando uma classe Produto em branco, e populando os atributos desta classe.

<?php
    require_once 'global.php';

    try {
        $nome = $_POST['nome'];
        $quantidade = $_POST['quantidade'];
        $preco = $_POST['preco'];
        $categoria_id = $_POST['categoria_id'];

        $produto = new Produto();

        $produto->nome = $nome;
        $produto->quantidade = $quantidade;
        $produto->preco = $preco;
        $produto->categoria_id = $categoria_id;
        $produto->inserir();

        header('Location: produtos.php');

    } catch (Exception $e) {
        Erro::trataErro($e);
    }
Vamos testar e ver o que acontece? Voltaremos à página de cadastro de novos produtos, cujo nome é "Camiseta Azul", o preço é "40", quantidade "10" e categoria "Roupas". Clicaremos no botão "Salvar", e veremos que o produto foi cadastrado com sucesso, constando na listagem junto aos demais.

O método PDO::prepare(), assim como o PDO::query(), retorna um objeto do tipo PDOStatement, mas com a diferença que a query não é executada automaticamente.

O objeto PDOStatement possui diversos métodos que podemos usar, em diferentes situações que podem ajudar. Vamos agora dar uma listada nas possibilidade que temos com esse objeto!

PDOStatement::fetch
Retorna a próxima linha de um resultset. Podemos usar o método fetch, combinado por exemplo com um while() para buscar cada linha do resultado. Ele sempre começa na primeira linha do resultado de sua query e a cada vez que o método é chamado, ele vai para a próxima linha. Quando chega na ultima linha, o método retorna um valor false.

Veja um exemplo de um SELECT em nossa tabela de produtos com isso:

<?php

require_once 'global.php';

$conexao = Conexao::pegarConexao();
$query = "SELECT nome FROM produtos";
$stmt = $conexao->prepare($query);
$stmt->execute();
$row = $stmt->fetch();

while ($row) {
    echo 'Produto:' . $row['nome'] . '<br>';
    $row = $stmt->fetch();
}
PDOStatement::fetchObject()
O fetchObject() funciona de forma muito parecida com o método fetch(), mas com a diferença simples de que, o retorno não vai ser um array onde, cada indice representa uma coluna na entidade e sim, um objeto, onde, cada atributo representa a entidade.

Veja o mesmo exemplo com a aplicação de PDOStatement::fetchObject():

<?php

require_once 'global.php';

$conexao = Conexao::pegarConexao();
$query = "SELECT nome FROM produtos";
$stmt = $conexao->prepare($query);
$stmt->execute();
$row = $stmt->fetchObject();

while ($row) {
    echo 'Produto:' . $row->nome . '<br>';
    $row = $stmt->fetchObject();
}
PDOStatement::rowCount
Sempre que usamos uma instrução SQL do tipo INSERT, UPDATE ou DELETE, não teremos um resultset, Mas, temos um retorno do Banco de Dados com a quantidades de linhas que foram afetadas pelo nosso script. E esse método justamente retorna isso para nós. Veja o exemplo abaixo:

<?php

require_once 'global.php';

$novo_preco = 11;

$conexao = Conexao::pegarConexao();
$query = "UPDATE produtos SET preco = :preco";
$stmt = $conexao->prepare($query);
$stmt->bindValue(':preco', $novo_preco);
$stmt->execute();
echo $stmt->rowCount() . ' Linhas atualizadas!';
E temos o seguinte resultado: 13 Linhas atualizadas!.

A lista completa de métodos pode ser encontrada na documentação do php (http://php.net/manual/pt_BR/class.pdostatement.php).


########## 03. Preparando script de banco de dados no PDO ##########



