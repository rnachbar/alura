#################### 01. Introdução ao PDO ####################


Olá pessoal, meu nome é Mario, sejam bem-vindos à primeira parte do curso de PHP com PDO! Nele, trabalharemos com o nosso sistema de controle de estoques, que envolve categorias e produtos, e lidaremos com tudo aquilo que se refere às categorias nesta primeira parte.

Basicamente, utilizaremos a classe de conexão com o banco de dados PDO, com que faremos um CRUD completo, para aprendermos como fazer a listagem, inserção, alteração e exclusão de categorias no nosso sistema.

Por que é interessante usarmos o PDO como conexão ao banco de dados no PHP?

O PDO possui a grande vantagem de realizar a abstração da conexão com o banco de dados. Significa que, após esta conexão, tudo aquilo que será feito é igual para qualquer banco de dados.

Ou seja, não teremos métodos específicos para o MySQL, o Oracle ou o SQL Server, por exemplo. Basta informarmos durante a conexão qual o sistema de banco de dados a que nos conectamos para que todo o código permaneça inalterado.

Se um dia tivermos que migrar de um banco de dados a outro, o processo é muito mais simples, pois a alteração é feita em um único local.

Após o término deste curso, é recomendado fazer a segunda parte, em que entraremos na parte de produtos e veremos algumas técnicas mais avançadas do PDO, como a preparação de query para a prevenção de SQL Injection, algo interessante que torna nossa aplicação mais robusta e segura.

Vamos começar?

Caso você não tenha feito ainda os cursos de PHP I: Orientação a objetos com sua linguagem preferida e PHP II: Avançando com Orientação a Objetos, sugiro que dê uma conferida neles, pois alguns conceitos de Orientação a Objeto utilizados neste curso introduzidos neles.

Criando nosso ambiente de Desenvolvimento
Até um tempo atrás, criar um ambiente de desenvolvimento PHP podia ser um pouco complicado e desgastante. Era necessário baixar o binário do PHP, depois um servidor web - normalmente o Apache -, e fazer toda a configuração manualmente para que eles se conversassem e funcionassem bem.

Você também pode usar uma solução como o XAMPP, que traz com ele um Apache já configurado com o PHP, além do banco de dados MySQL, tudo bonito.

Porém, desde a versão 5.3 do PHP, você não precisa mais ter todo esse trabalho para desenvolver nesta linguagem. A partir dessa versão, o PHP traz consigo um pequeno e simples servidor web embutido, bastando usar um único comando no console/terminal/bash de seu sistema operacional para ativá-lo. E uma vez feito isso, pronto, é só abrir seu navegador e sair programando.

Agora vou ensinar como fazer a instalação do binário do PHP e do MariaDB, que usaremos em nosso curso!

Windows
Acesse o link do site do PHP, na versão Current Stable PHP, selecione a opção Windows Download e, depois, baixe a versão Non Thread Safe equivalente ao tipo de arquitetura do seu Sistema Operacional, que pode ser x86 ou x64.

Ou clique diretamente nos links abaixo:

Windows x86

Windows x64

Uma vez baixado o zip, sugiro descompactar a pasta na raiz do seu drive C e renomeá-la para php, deixando-a da seguinte forma:

Assim, precisaremos também colocar esse diretório no path do Windows, processo necessário para podermos usar o comando php em qualquer diretório do Sistema.

Para isso, acesse o Painel de Controle do Windows e clique em Sistemas. Na janela que se abriu, procure no menu lateral esquerdo a opção Configurações Avançadas do Sistema. Na nova janela, clique no ultimo botão chamado Variáveis de Ambiente.

Na seção Variáveis do Sistema, procure pela path e clique em editar. Uma lista com muitas variáveis se abrirá. Clique no botão Novo e, no novo campo que vai se abrir no final da lista, coloque o caminho do diretório da sua instalação do PHP, que se for como colocado aqui, será C:\php.

Feito isso, clique em OK, OK novamente e, por fim, OK. =)

Pronto! Para ver se tudo está funcionando, você pode abrir o prompt de comando do windows e digitar php -v.

Linux (Distribuição baseada no Debian)
Para instalar o PHP no Linux (uma distribuição baseada no Debian como o Ubuntu, por exemplo), abra o terminal e digite o seguintes comandos:

sudo apt-get update
sudo apt-get install libapache2-mod-php7.0 php7.0-mysql php7.0-curl php7.0-json php-memcached php7.0-dev php7.0-mcrypt php7.0-sqlite3 php7.0-mbstring
Para ver se funcionou, após a instalação, basta digitar no terminal php -v.

Mac OS X
Para instalar o PHP no Mac OS X, abra o terminal e digite o seguinte comando:

curl -s https://php-osx.liip.ch/install.sh | bash -s 7.1
export PATH=/usr/local/php5/bin:$PATH
Instalação do MariaDB
Windows
Para instalar o MariaDB no Windows, é muito simples: basta baixar o instalador e seguir o passo a passo. Lembre-se de que é no processo de instalação que você vai definir a senha do banco de dados.

Linux (Distribuição baseada no Debian)
Para instalar o MariaDB no Linux, abra um terminal e use os seguintes comandos:

sudo apt-get update

sudo apt-get upgrade

sudo apt-get install software-properties-common
sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8

sudo add-apt-repository 'deb [arch=amd64,i386,ppc64el] http://ftp.utexas.edu/mariadb/repo/10.1/ubuntu xenial main

sudo apt-get update
sudo apt-get install mariadb-server
Mac OS X
Para instalar o MariaDB no Mac OS X, abra o terminal e digite o seguinte comando:

brew install mariadb
E, depois da instalação, você pode ativar o MariaDB com o comando:

mysql.server start
Material da aula
Aqui você pode baixar o projeto do curso inicial com todo o material do front-end.

Baixe o zip ou visualize os arquivos no Github (https://github.com/alura-cursos/PDO-Alura-Parte1/tree/8088bff7408a766cd4a726feec7e1802ea69425d).

No exercício referente a esta aula, vocês terão todos os arquivos utilizados - de criação do banco de dados, as instruções para isso, e os arquivos de front-end. Vamos começar criando uma pasta denominada "classes", em que incluiremos um novo arquivo chamado Categoria.php.

Basicamente, neste arquivo será criada uma classe para representar cada entidade, cujas necessidades estarão sob responsabilidade de cada uma delas em nosso sistema de estoque.

Começaremos com "Categoria", da seguinte maneira:

<?php

class Categoria
{

}
?>
Agora, vamos dar uma olhada em nosso front-end para entendermos o que precisaremos fazer nesta parte de categorias. Neste projeto, não usaremos Apache, IIS, ou qualquer outro servidor web. O PHP possui um servidor web embutido, que poderá ser utilizado para facilitar nosso trabalho.

Abriremos o Windows PowerShell, mas este pode ser substituído por qualquer outro terminal de sua preferência. Navegaremos até a pasta de nosso projeto, digitando os seguintes comandos intercalados com "Enter":

cd ..
cd .. 
cd PDO
ls
O último comando nos lista todos os arquivos existentes no diretório para verficiarmos se estamos no local correto, ou seja, na raiz do nosso projeto. Para que o servidor web funcione, usaremos o comando php -S 127.0.0.1:8888 passando como parâmetros o IP e a porta para o qual queremos que o servidor suba, no caso, a mesma máquina que estamos utilizando, ou o IP local.

Com "Enter", o prompt fica bloqueado para uso, sendo que poderemos parar o processamento a qualquer momento com "Ctrl + C", e será impresso o log de tudo que está acontecendo no servidor web.

Vamos ver se deu certo?

Abriremos o navegador e digitaremos 127.0.0.1:8888, e nosso sistema é carregado conforme esperávamos:

página com menu de cabeçalho com texto "Controle de Estoque", e os links "Categorias" e "Produtos" em branco numa barra preta ao fundo; abaixo, "Seja bem-vindo ao Sistema de Controle de Estoque" e, mais abaixo, "Selecione uma das opções do Menu para começar a usar o Sistema" e, abaixo, "Ⓒ 2017 Controle de Estoque"

Clicando na seção "Categorias", há um botão que serve para criarmos novas categorias, uma já existente ("Livros") sendo listada na tabela, um botão de "Editar" e outro de "Excluir". Entendemos que precisaremos fazer a lista de categorias, a ser apresentada ao usuário nesta página. Vamos voltar ao código de Categoria.php.

Precisaremos fazer uma busca no banco de dados para obtermos as categorias do nosso projeto, portanto usaremos uma variável $query, que será uma string, e nela usaremos o SELECT para a consulta no banco de dados.

Para executarmos a query, usaremos o PDO, com o qual precisaremos criar uma conexão a partir da variável $conexao, e fazendo uma nova instância da classe PDO passando o parâmetro que é a string de conexão, a única informação que variará de acordo com o banco de dados em uso.

Tecnicamente, esta é a única mudança no caso de trocarmos de banco de dados, desde que o novo siga a mesma estrutura de tabelas e não esteja utilizando nenhuma função específica.

No nosso caso, utilizaremos o MySQL, então a string de conexão será criada com base nele. Em seguida, informaremos o host onde se encontra o servidor MySQL, e o dbname do projeto.

O segundo parâmetro será o usuário de conexão, e o terceiro, a senha:

<?php

class Categoria
{
    public function listar()
    {
        $query = "SELECT id, nome FROM categorias";
        $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
    }
}
?>
Legal, desta forma fazemos a conexão com o banco de dados, e agora precisaremos justamente executar a query, e para isso usaremos o método query() do PDO, passando como parâmetro a string $query. Queremos que isso seja retornado para uma variável $resultado. O trecho do código ficará assim:

$query = "SELECT id, nome FROM categorias";
$conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
$resultado = $conexao->query($query);
O método query() retorna um objeto chamado PDOStatement, com várias informações da nossa execução, incluindo o retorno, as linhas retornadas. Para obtê-las, usaremos o método fetchAll(), que retornará um array com todas as linhas que queremos da consulta.

Colocaremos tudo isso em uma lista a ser retornada:

$query = "SELECT id, nome FROM categorias";
$conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
$resultado = $conexao->query($query);
$lista = $resultado->fetchAll();
return $lista;
Vamos conferir seu funcionamento indo à página de Categorias e instanciando a nova classe para testarmos. Abriremos o arquivo categorias.php, em que consta puro HTML, exceto pelo require_once do cabeçalho e do rodapé.

Começaremos incluindo outro require_once para chamarmos a classe Categoria. Em seguida, abriremos um bloco de PHP para a chamada para o método que acabamos de criar. E queremos que esta informação vá para uma variável chamada lista:

<?php require_once 'classes/Categoria.php' ?>
<?php
    $categoria = new Categoria();
    $lista = $categoria->listar();
?>
Para verificar se tudo funciona como esperado, voltaremos ao navegador para atualizá-la. Receberemos uma mensagem de erro, pois o PHP, por padrão, precisa que a extensão do PDO esteja ativada no servidor, o que poderemos fazer no arquivo de configuração do PHP, o php.ini.

Para abri-lo e habilitarmos sua extensão de PDO, acessaremos "C: > php > php.ini" (Windows), e abriremos o arquivo no próprio bloco de notas. Veremos que ele é cheio de configurações do PHP, e o que queremos é ativar a configuração do PDO.

Com "Ctrl + F", buscaremos "PDO", o que nos mostra diversas extensões, cada uma para um banco de dados diferente. No nosso caso, como estamos usando o MySQL, habilitaremos a extensão correspondente descomentando-a, isto é, retirando o ponto e vírgula (;) que a antecede, deixando-a assim:

extension=php_pdo_mysql.dll
Feito isso, salvaremos o arquivo e reiniciaremos o servidor que deixamos rodando no PowerShell, justamente para que se usem as configurações atualizadas.

Então, voltaremos ao PowerShell, em que usaremos "Ctrl + C" para pausar a execução. Em seguida, o executaremos novamente. Vamos ver se isto resolve nosso problema?

Sim! Agora ele está funcionando direitinho. No entanto, nossas categorias ainda não aparecem, então vamos verificar se realmente deu certo debugando a variável para ver se ela está sendo populada corretamente, por meio do método print_r() do PHP. Em categorias.php, teremos:

<?php require_once 'classes/Categoria.php' ?>
<?php
    $categoria = new Categoria();
    $lista = $categoria->listar();

    print_r($lista);
?>
O print_r() é equivalente ao toString(), e tenta imprimir na tela qualquer tipo de variável, não importa se é um array, inteiro, ou booleano. Ele dará um jeito de convertê-la para uma string e imprimir.

Vamos executar o código e ver o que acontece. No navegador, é indicado que trata-se de um array e nos passa todas as informações... Mas está meio ruim de visualizar assim, não?

Para facilitar a visualização do retorno do print_r(), utilizaremos o echo e a tag <pre> do HTML:

<?php require_once 'classes/Categoria.php' ?>
<?php
    $categoria = new Categoria();
    $lista = $categoria->listar();

    echo "<pre>";
    print_r($lista);
    echo "</pre>";
?>
Isso faz com que se acertem as quebras de linha, ajudando na compreensão de que há quatro categorias com os respectivos ids e nomes. Para cada categoria, existe uma chave com o nome do campo de dados (o id), e uma chave para o mesmo valor, porém numérica (0), possibilitando que se use a que preferir.

Se forem usar o valor numérico, atentem-se para que não haja risco de mudar a ordem dos valores depois, pois esta informação irá variar ali.

Então, poderemos deletar o debug pois já sabemos que está tudo sendo rodado como esperado. Agora, vamos jogar estas informações à nossa lista com o foreach, navegando pelo array linha a linha e capturando as informações para mostrá-las na tela.

Antes da tag <tr> e após <tbody> em categorias.php, digitaremos:

<?php foreach ($lista as $linha): ?>
    <tr>
    <!-- ... -->
    </tr>
<?php endforeach ?>
Para melhorar a organização e legibilidade do nosso código quando misturamos o PHP com um arquivo HTML, costuma-se usar o padrão de escrita do PHP em uma mesma linha, usando dois pontos (:), como mostrado acima.

E uma vez que abrimos esta tag com dois pontos, ela será fechada com endforeach. Com isso, simplesmente imprimiremos os valores do id e nome da categoria:

<?php foreach ($lista as $linha): ?>
    <tr>
        <td><a href="/categorias-detalhe.php" class="btn btn-link"><?php echo $linha['id'] ?></a><td>
        <td><a href="/categorias-detalhe.php" class="btn btn-link"><?php echo $linha['nome'] ?></a><td>
        <td><a href="/categorias-editar.php" class="btn btn-info">Editar</a><td>
        <td><a href="#" class="btn btn-danger">Excluir</a><td>
    </tr>
<?php endforeach ?>
Vamos rodar o código e verificar o que acontece.

Tudo está funcionando corretamente! Agora, temos o foreach com os nossos dados, ou seja, as categorias "Livros", "Jogos", "Filmes" e "Revistas".

Até agora, criamos a classe Categoria.php, com uma $query para fazermos o SELECT. Implementamos a primeira $conexao com o PDO, em que executamos a query, cujo resultado foi retornado para outra página.

Em categorias.php fizemos a instância da Categoria, a chamada no método listar(), a qual verificamos com o debug para nos averiguar sobre seu funcionamento, e fizemos um loop na tabela para imprimir todos os valores na tela!

Vimos nesta aula, que para você pode usar a classe PDO do PHP para fazer uma conexão com diversos bancos de dados diferentes, apenas mudando a sua string de conexão. Qual das formas a seguir, é a forma correta para se conectar ao banco de dados MySQL/MariaDB utilizando a classe PDO?

$conexao = new PDO('[drive]:host=[host];dbname=[database]', '[usuario]', '[senha]');
Passamos a string de conexão com o banco de dados, onde nela, informamos o drive de conexão [drive], o hostname ou IP do servidor no qual o banco de dados encontra-se [host] e o database no qual, queremos efetuar a conexão [database]. Além de passar como parâmetros adicionais, o usuário que será usado para efetuar a conexão e como parâmetro opcional, a senha deste usuário.

Nós aprendemos que existem várias formas de trabalhar com o php no meio de um arquivo HTML.

Agora, considerando os seguintes trechos de códigos:

Classe Categoria

public function listar()
{
    $query = "SELECT id, nome FROM categorias";
    $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}
Arquivo categorias.php onde as categorias serão listadas:

<?php
    $categoria = new Categoria();
    $lista = $categoria->listar();
Como podemos listar as categorias que estão na variável $lista em nossa página categorias.php?

<?php foreach ($lista as $linha) { ?>
<tr>
  <td><a href="categorias-detalhe.php?id=<?php echo $linha['id'] ?>" class="btn btn-link"><?php echo $categoria->id ?></a></td>
  <td><a href="categorias-detalhe.php?id=<?php echo $linha['nome'] ?>" class="btn btn-link"><?php echo $categoria->nome ?></a></td>
  <td><a href="/categorias-editar.php?id=#" class="btn btn-info">Editar</a></td>
  <td><a href="/categorias-deletar.php?id=#" class="btn btn-danger">Excluir</a></td>
</tr>
<?php } ?>

Estamos fazendo um loop com o foreach na matriz lista. Onde, cada linha, tem o valor de uma linha retornada pelo banco de dados. Estamos também, usando o echo para imprimir cada casa da nossa matriz.

<?php foreach ($lista as $linha): ?>
<tr>
  <td><a href="categorias-detalhe.php?id=<?php echo $linha['id'] ?>" class="btn btn-link"><?php echo $categoria->id ?></a></td>
  <td><a href="categorias-detalhe.php?id=<?php echo $linha['nome'] ?>" class="btn btn-link"><?php echo $categoria->nome ?></a></td>
  <td><a href="/categorias-editar.php?id=#" class="btn btn-info">Editar</a></td>
  <td><a href="/categorias-deletar.php?id=#" class="btn btn-danger">Excluir</a></td>
</tr>
<?php endforeach; ?>

Estamos usando a Sintaxe Alternativa no foreach para efetuar um loop na matriz lista. Onde, cada linha, tem o valor de uma linha retornada pelo banco de dados. Estamos também, usando o echo para imprimir cada casa da nossa matriz.

Nesta aula, aprendemos algumas coisas importantes para começar a trabalhar com o PDO do php. Agora, usando esses conhecimentos, vamos fazer uma simples página que vai:

Estabelecer uma conexão com o Banco de Dados;
Efetuar um SELECT no banco de dados na tabela Categorias;
Exibir o resultado desse SELECT usando a função print_r().

Precisamos fazer com os passos abaixo para isso:

Primeiro, criamos uma string $query onde vamos colocar o SELECT para buscar todas as categorias do banco de dados.

Depois, vamos abrir uma conexão com o MariaDB via php-PDO com o comando new PDO() passando todas as informações para isso (drive, hostname, database, usuário e senha).

Depois, vamos executar a query com o método ->query() da conexão PDO.

Em seguida, vamos recuperar o resultado de nossa query, usando o método ->fetchAll()

Por fim, apenas precisamos imprimir o resultado na tela usando a função print_r() em volta da tag <pre> do HTML para facilitar a visualização do resultado.

Código:

<?php

$query = "SELECT id, nome FROM categorias";
$conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
$resultado = $conexao->query($query);
$lista = $resultado->fetchAll();

echo '<pre>';
print_r($lista);
echo '</pre>';
Resultado:

Array
(
    [0] => Array
        (
            [id] => 1
            [0] => 1
            [nome] => Livros
            [1] => Livros
        )

    [1] => Array
        (
            [id] => 2
            [0] => 2
            [nome] => Jogos
            [1] => Jogos
        )

    [2] => Array
        (
            [id] => 3
            [0] => 3
            [nome] => Filmes
            [1] => Filmes
        )

    [3] => Array
        (
            [id] => 4
            [0] => 4
            [nome] => Revistas
            [1] => Revistas
        )
)


#################### 02. Inserindo categorias com o PDO ####################


Continuando nosso projeto, que já tem a listagem funcionando bem, agora precisaremos conseguir inserir categorias novas ao sistema. Na página aberta no navegador, vamos clicar no botão "Criar Nova Categoria" e ver como ele se comporta.

É um formulário bem simples contendo uma caixa de texto a ser preenchida com o nome da categoria que queremos adicionar ao sistema, e um botão de "Salvar".

Vamos criar um método em nossa classe Categoria.php para esta nova inserção:

public function listar()
{
    $query = "SELECT id, nome FROM categorias";
    $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}

public function inserir($nome)
{
    $query = "INSERT INTO categorias(nome) VALUES('". $nome ."')";
}
Em seguida, precisaremos criar a conexão com o MySQL usando o PDO novamente, após o qual faremos a execução da query, só que desta vez não usaremos o método query(), e sim exec(), para usarmos em INSERT, no caso.

public function inserir($nome)
{
    $query = "INSERT INTO categorias(nome) VALUES('". $nome ."')";
    $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
    $conexao->exec($query);
}
Por enquanto, não precisaremos pegar seu retorno. Vamos testar para ver se funciona?

Abriremos categorias-criar.php, em que se encontra o formulário. A única coisa que teremos que fazer nele é indicar o name do input, a nossa caixa de texto. E precisaremos passar a action do formulário, indicando para qual página essas informações serão enviadas.

O código ficará da seguinte maneira:

<form action="categorias-criar-post.php" method="post">
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            <div class="form-group">
                <label for="nome">Nome da Categoria</lab.
.el>
                <input name="nome" type="text" class="form-control" placeholder="Nome da Categoria">
            </div>
            <input type="submit" class="btn btn-success btn-block" value="Salvar">
        </div>
    </div>
</form>
Agora, criaremos o categorias-criar-post.php no projeto, abrindo o bloco PHP que não será fechado, isto é, não terá ?>, por conter apenas esta linguagem.

Precisaremos passar o nome da categoria, e para isso criaremos $nome, que pegará nome, lembrando que a chave da variável $_POST equivale ao name do input no formulário HTML.

Após a inserção, redirecionaremos o usuário à tela de lista, por meio da função header().

<?php
    require_once 'classes/Categoria.php';

    $categoria = new Categoria();
    $nome = $_POST['nome'];
    $categoria->inserir($nome);

    header('Location: categorias.php');
Vamos testar para ver se funciona! No navegador, na página de criação de nova categoria, digitaremos "Eletrônicos" e clicaremos em "Salvar". Ela aparecerá na nossa lista corretamente. Da mesma forma, testaremos incluindo "Eletrodoméstico", o que funcionará bem também.

Então, criamos Categoria.php e o método inserir() passando a variável nome, criamos seu INSERT, fizemos a conexão com o banco de dados e o executamos.

Mas... Pensando que estamos tentando trabalhar com Orientação a Objetos, será que esta é a melhor forma de fazermos tudo isso? Por que não criar atributos para a nossa Categoria, justamente para deixar tudo mais claro e organizado?

Temos duas colunas em nossa tabela: uma para id e outra para nome, então poderemos criar dois atributos, um para cada coluna. E em vez de passarmos como parâmetro $nome em INSERT, usaremos o atributo recém criado.

Em Categoria.php, portanto, teremos:

class Categoria
{
    public $id;
    public $nome;

    public function listar()
    {
        //...
    }

    public function inserir()
    {
        $query = "INSERT INTO categorias (nome) VALUES ('" . $this->nome . "')";
        $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
        $conexao->exec($query);
    }
}
A diferença é que, agora, antes de instanciarmos a classe Categoria e fazermos o INSERT, vamos popular o atributo com o valor de nome, que vem do POST. Sendo assim, categorias-criar-post.php ficará da seguinte forma:

$categoria = new Categoria();
$nome = $_POST['nome'];
$categoria->nome = $nome;
$categoria->inserir();
Para testarmos, criaremos a categoria "Quadrinhos", e veremos que ele foi adicionado à lista corretamente, e nosso código está bem mais organizado.

Agora que conseguimos inserir novas categorias, vamos dar uma olhada no código. Os métodos listar() e inserir() se diferenciam ao abrirmos a conexão com o PDO. Em listar(), usamos o método query() para a execução da query, e em inserir(), usamos exec().

Qual a diferença entre estes dois métodos?

Como falado anteriormente, basicamente, o método query() retorna um PHP Statement, que possui várias informações acerca do retorno da query, como o número de linhas, por exemplo, dados que podem acabar sendo úteis para nosso trabalho.

O método exec(), por sua vez, é mais puro e simples, e apenas executa, não trazendo resultados. Simplesmente sabemos se a execução foi bem sucedida ou não. E ele é usado em casos em que há inserts (inserções), updates (atualizações) ou deletes (exclusões).

Podemos reparar também que nestes dois métodos há uma informação duplicada, com a conexão sendo feita exatamente da mesma forma em ambos. Se continuarmos assim, teremos quatro, cinco, seis métodos contendo as mesmas informações.

Imaginando uma situação de troca de computador ou de termos que subir tudo isso para outro ambiente, cujas informações e dados são outros, cada método destes precisaria ser alterado, e isso não é legal.

Poderíamos, então, centralizar estas informações em um único lugar. Da mesma forma que criamos Categoria, responsável por tudo aquilo que se refere a categorias, é possível criar uma classe para as conexões, responsável pelo gerenciamento das mesmas.

Dentro da pasta "classes", então, criaremos um novo arquivo chamado Conexao.php, com a classe Conexao, que irá estabelecer a conexão e retorná-la para quem precisar. Por isso, implementaremos um método estático para este retorno:

<?php

class Conexao
{
    public static function pegarConexao()
    {
        $conexao = new PDO('mysql:host=127.0.0.1;dbname=estoque', 'root', 'alura');
        return $conexao;
    }
}
Em seguida, voltaremos à classe Categoria.php e substituiremos o new PDO() tanto no método listar() quanto no inserir(), pelo método recém criado, usando dois pontos duplos (::), já que é um método estático:

public function listar()
{
    $query = "SELECT id, nome FROM categorias";
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    return $lista;
}

public function inserir()
{
    $query = "INSERT INTO categorias (nome) VALUES ('" . $this->nome . "')";
    $conexao = Conexao::pegarConexao();
    $conexao->exec($query);
}
Para verificarmos seu funcionamento, atualizaremos a lista no navegador novamente... Obtivemos um erro por esquecermos de chamar o arquivo da classe Conexao.php em Categoria.php.

Vamos corrigir digitando:

<?php

require_once 'classes/Conexao.php';

class Categoria
{
    //...
}
Dessa vez, ao atualizarmos a página no navegador, veremos a lista funcionando direitinho.

Neste vídeo, criamos a classe Conexao.php para centralizar as informações da nossa conexão e, agora, se por acaso alguma delas for alterada, teremos que mexer apenas neste arquivo, o que facilita muito o trabalho.

Os próximos passos consistem em trabalharmos com a edição das categorias existentes!

Nessa aula, vimos uma forma diferente de executar scripts no banco de dados. O PDO::exec(). Por que não devemos usar o PDO::exec() para consultar no banco de dados com SELECT?

Porque ele não vai retornar o resultado da consulta.
O PDO::exec() retorna apenas um valor inteiro com o número de linhas afetadas pelo script que foi executado. No caso de um SELECT, não existe manipulação de dados no Banco e sim, um retorno de uma consulta. O método PDO::exec() não vai dar erro, mas não vai nos trazer o resultado.

Vimos nessa aula uma forma diferente para executar scripts no banco de dados com o PDO.

Qual dos métodos abaixo é a MELHOR opção para executar um script que vai alterar uma informação dentro do Banco de dados usando o PDO?

$conexao->exec($query);
O método ->exec($query) apenas retorna um valor inteiro com o número de linhas afetados pelo script. Como em um INSERT, UPDATE ou DELETE não trazem um resultado, usar o ->exec() aqui é o ideal

No nosso projeto, estamos usando constantemente, um comando para importar nossas classes para dentro de nossas páginas. Qual das formas abaixo podemos usar para referenciar um arquivo externo em nosso script php?

require 'caminho/do/arquivo.php';
O require_once gera um erro fatal no php, caso o arquivo indicado não exista.

require_once 'caminho/do/arquivo.php';
O require_once gera um fatal error no php, caso o arquivo indicado não exista. O _once significa que caso mais de um arquivo referencie um mesmo arquivo, ele será ignorado, sendo referenciado uma única vez.

include_once 'caminho/do/arquivo.php';
O include_once gera apenas um warning caso o arquivo indicado não exista, dessa forma, o restande da página continua sendo processada. O _once significa que caso mais de um arquivo referencie um mesmo arquivo, ele será ignorado, sendo referenciado uma única vez.

include 'caminho/do/arquivo.php';
O include_once gera apenas um warning caso o arquivo indicado não exista, dessa forma, o restande da página continua sendo processada.

A partir de agora faremos a configuração da edição das nossas categorias implementando uma ação para quando o usuário clicar no botão "Editar": carregar um formulário preenchido cujas informações poderão ser modificadas e salvas posteriormente no banco de dados.

Para começar, entraremos na classe Categoria e criaremos um novo método para a atualização. O arquivo já possui os métodos listar() e inserir(), e incluiremos atualizar(), com estrutura similar ao que fizemos com os outros.

Criaremos uma query, que terá a instrução SQL que executaremos para a atualização, pegaremos a conexão e executaremos a query com o método exec(), como fizemos em inserir(). As únicas colunas que temos nas categorias são id e nome, sendo que o primeiro é um valor chave que nunca é alterado. Assim, o único dado que o usuário poderá editar é o nome.

Também criaremos a variável conexao que, como o nome indica, receberá a conexão da nossa classe, após o qual executaremos a query.

public function atualizar();
{
    $query = "UPDATE categorias set nome = '" . this->nome . "' WHERE id = " . $this->id;
    $conexao = Conexao::pegarConexao();
    $conexao->exec($query);
}
A partir disso, precisaremos do formulário para a edição das informações. Vamos acessar categorias.php na raiz do nosso projeto, em que se encontra a lista, que já foi criada. Quando formos chamar o formulário de edição, diferentemente do formulário de inserção, que faz o acréscimo de um valor até então inexistente, estaremos mexendo com algo que já existe.

Então, precisaremos indicar a esta página o que será editado, e a melhor forma de fazê-lo é passando o id da categoria a ser editada.

Lembra-se do foreach, com que fizemos a lista contendo as colunas com id e nome, bem como o botão com "Editar" e outro com "Excluir"?

Poderemos aproveitar o id desta lista para passá-lo como parâmetro na url da página de edição, via query string. Em categorias.php já temos o arquivo que estamos chamando na linha do botão "Editar", isto é, categorias-editar.php. Então basta acrescentarmos um ponto de interrogação e o nome da variável, igual seu nome.

Como o valor é dinâmico e definido pelo PHP, colocaremos a tag correspondente, com echo, e imprimiremos linha com o id, fechando o PHP em seguida:

<?php foreach ($lista as $linha): ?>
    <tr>
        <td><a href="/categorias-detalhe.php" class="btn btn-link"><?php echo $linha['id'] ?></a><td>
        <td><a href="/categorias-detalhe.php" class="btn btn-link"><?php echo $linha['nome'] ?></a><td>
        <td><a href="/categorias-editar.php?id=<?php echo $linha['id'] ?>" class="btn btn-info">Editar</a><td>
        <td><a href="#" class="btn btn-danger">Excluir</a><td>
    </tr>
<?php endforeach ?>
Vamos ver se isso funciona?

Atualizaremos a tela de listagem no navegador e passaremos o mouse sobre "Editar", e do lado inferior esquerdo é mostrado o link para o qual o botão aponta e, neste caso, o id apontado é 1, o que corresponde ao fato deste ser o primeiro botão.

Se fizermos o mesmo na linha seguinte, o id será 2, como esperado, e assim por diante. Ou seja, cada botão está passando como parâmetro o id de sua categoria.

Vamos testar clicando no botão referente à categoria "Livros". Aparentemente, tudo funcionando bem. Abriremos o arquivo categorias-editar.php para ver como está o código. No campo input do nome da categoria, o value está preenchido com Livros, isto é, este valor está "engessado" e não é real, tanto que se voltarmos à ferramenta e formos editar "Jogos", o placeholder continua como "Livros".

Então, precisaremos fazer com que este valor fique dinâmico, para que se apresente ao usuário o valor do nome real da categoria que foi clicada para alteração. Para isto, carregaremos nesta página o objeto categoria, que representa o id, mais uma vez.

Criaremos mais um método para a classe Categoria, o carregar(), similar ao método da listagem. No entanto, em vez de carregar uma lista com vários registros, carregaremos apenas um, com id específico.

A diferença, portanto, é que no SELECT teremos uma cláusula WHERE, e passaremos um id como parâmetro. Voltando então à Categoria.php, vamos criar um novo método logo abaixo de listar(), cuja query será bem similar, porém, agora adicionaremos WHERE para que se filtre pelo id, e usaremos o método query() para executar o script.

Não usaremos exec() pois ele não nos retorna o PHP Statement, como faz o query().

Ao fazermos uma execução de query(), o PDO não sabe quantas linhas serão retornadas, mesmo que nós saibamos. Sendo assim, ele criará um array com várias linhas, mesmo que saibamos que queremos apenas a primeira delas.

Então, neste caso criaremos a variável lista que receberá o resultado de fetchAll(), assim como em listar() mas, em vez de fazê-lo diretamente, ele será tratada no próprio método para que somente a primeira linha seja devolvida.

public function carregar()
{
    $query = "SELECT id, nome FROM categorias WHERE id = " . $this->id;
    $conexao = Conexao::pegarConexao();
    $resultado = $conexao->query($query);
    $lista = $resultado->fetchAll();
    foreach ($lista as $linha) {
        return $linha;
    }
}
Para verificarmos se está tudo certo, testaremos carregando uma categoria na página. Voltaremos ao arquivo categorias-editar.php e instanciaremos a classe Categoria e criaremos um bloco de PHP para instanciarmos a mesma classe.

Lembra que no método carregar() pegamos o valor de id? Precisaremos recuperá-lo neste momento! Acabamos de digitar a página de listagem passando o id como parâmetro de query string, e precisaremos dele para popularmos o atributo id.

Então, invocaremos o método carregar() colocando seu resultado em uma variável resultado:

<?php require_once 'classes/Categoria.php' ?>
<?php
    $categoria = new Categoria();
    $id = $_GET['id'];
    $categoria->id = $id;
    $resultado = $categoria->carregar();
?>
Tecnicamente, esta variável receberá aquele array com a primeira linha do retorno da query. Então, pegaremos o valor de resultado e utilizaremos o echo com a chave do nome do campo, que se chama nome. Isto significa que, no value do input, onde está Livros, abriremos a tag <php>:

<form action="#" method="post">
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            <div class="form-group">
                <label for="nome">Nome da Categoria</label>
                <input type="text" value="<?php echo $resultado['nome'] ?>" class="form-control" placeholder="Nome da Categoria">
            </div>
            <input type="submit" class="btn btn-success btn-block" value="Salvar">
        </div>
    </div>
</form>
Vamos ver se funciona? Atualizaremos a página no navegador e veremos que a categoria que queremos editar aparece como o value, como gostaríamos!

Legal, nossa edição está funcionando corretamente, pois o texto no botão em que clicamos e a categoria a ser editada são os mesmos. Mas será que não conseguimos deixar nosso código um pouco mais organizado?

Organizado no que diz respeito à economia de linhas de código, do processo que fizemos para carregar o valor do nome da categoria. Vamos dar uma olhada no código: em categorias-editar.php primeiro fazemos a instância da nossa Categoria, depois pegamos o valor do id da query string, do GET, e então passamos este valor do id ao atributo id da categoria, e chamamos o método carregar(), que nos retorna um resultado, um array com o nome da categoria.

Se estamos utilizando Orientação a Objetos, já temos atributos da categoria, o id, sendo utilizado, assim como o nome. Então, por que não o usamos para ser o nome da categoria, em vez de retornar no método carregar() um array com este nome?

Poderemos simplesmente chamar o método carregar(), o que de fato carregará o atributo nome da nossa categoria. Então, vamos abrir Categoria.php para mexermos no método carregar(), com o foreach, que por sua vez contém return $linha;.

A variável linha já possui o array com o valor que queremos, o nome da categoria, então, em vez de o retornarmos, passaremos este valor como atributo nome, e deletaremos a linha com return. O código ficará assim:

public function carregar()
{
    //...
    foreach ($lista as $linha) {
        $this->nome = $linha['nome'];
    }
}
Agora, o importante é que não teremos mais um retorno, pois o método carregar() não retorna mais nada, já que o resultado é colocado no atributo categoria do objeto instanciado. Se não temos mais nenhum retorno, é preciso ajustarmos isto em categorias-editar.php, pois quando chamamos o método carregar(), estamos esperando o retorno, a ser colocado na variável resultado (agora inexistente).

O arquivo categorias-editar.php, portanto, ficará sem a variável resultado, e simplesmente chamando o método carregar(), da seguinte forma:

<?php require_once 'classes/Categoria.php' ?>
<?php
    $categoria = new Categoria();
    $id = $_GET['id'];
    $categoria->id = $id;
    $categoria->carregar();
?>
E quando ele for chamado, o atributo nome estará populado!

No echo, apagaremos onde antes imprimíamos o valor resultado com a chave nome, imprimindo-se o valor de categoria com a chave nome:

<form action="#" method="post">
    <div class="row">
        <div class="col-md-6 col-md-offset-3">
            <div class="form-group">
                <label for="nome">Nome da Categoria</label>
                <input type="text" value="<?php echo $categoria->nome ?>" class="form-control" placeholder="Nome da Categoria">
            </div>
            <input type="submit" class="btn btn-success btn-block" value="Salvar">
        </div>
    </div>
</form>
Vamos ver se isto funciona?

Tudo parece funcionar bem quando clicamos no botão "Editar". O que mais poderá ser otimizado na classe Categoria, em relação ao carregamento de informações?

Novamente estamos instanciando a categoria, buscando o id e atribuindo-o à classe Categoria, fazendo o carregamento. Poderemos deixar este processo todo um pouco mais inteligente e, no momento em que instanciarmos a Categoria, já poderemos passar o id diretamente.

Assim, quando ela for instanciada com um valor, já entendemos que este objeto será carregado com o valor do id que está sendo passado. Ou seja, o método carregar() será chamado automaticamente, de forma que vamos conseguir economizar mais linhas de código.

Para isto, criaremos um construtor na classe Categoria, um método que é invocado sempre que a classe é instanciada. No PHP, todo construtor possui um padrão para ser instanciado.

Como dito anteriormente, queremos usar o construtor quando passamos algum valor a ele, porém seu método será chamado sempre que o objeto é instanciado, não importa se estamos ou não passando um valor a ele. E no caso, o valor que podemos ou não passar é o id.

Então, passaremos id na assinatura do construtor e daremos um valor default a ele, que será false. Isso porque caso nada seja passado, este será o valor assumido, e a validação poderá ser efetuada para sabermos se foi passado um valor, e então chamar o método carregar(), ou não.

Portanto, no método construct() teremos um if testando o valor id: se for true, ou seja, se houver algo positivo nele, ele entrará neste if. E uma vez que o id for populado, poderemos chamar carregar().

class Categoria
{

    public $id;
    public $nome;

    public function __construct($id = false)
    {
        if ($id) {
            $this->id = $id;
            $this->carregar();
        }
    }
Com isso, poderemos ajustar o que foi feito em categorias-editar.php para substituir aquilo que já consta no construtor que acabamos de criar. Vamos apagar as seguintes linhas deste arquivo:

$categoria->id = $id;
$categoria->carregar();
Porém, para que isso funcione, agora precisaremos passar o id no momento em que instanciamos a classe Categoria, e não depois, como estava acontecendo até então. Basta invertermos a ordem, deixando:

<?php
    $id = $_GET['id'];
    $categoria = new Categoria($id);
?>
Feito isso, testaremos no navegador e veremos que tudo funciona como gostaríamos!

Nessa aula, usamos pela primeira vez no nosso projeto, o método construtor do php. Sabendo que o método construtor de uma classe php sempre é chamado quando a classe é instanciada, como podemos fazer para diferenciar se uma entidade será ou não carregada nesse momento?

Passamos um parâmetro no método construtor com um valor predefinido, assim, podemos testar com um if se algum valor foi informado no momento que a classe foi instanciada e assim, chamar ou não, o método de carregamento.
Exatamente, Quando definimos por exemplo, um valor false para um parâmetro de um método. Quando esse método for chamado (no caso, o método __construct é sempre chamado no momento que é feito a instancia da classe), caso nenhum valor seja passado, automaticamente, o valor do parâmetro será = false, caso contrário, ele assumirá o valor passado. Assim, podemos com facilidade, testar essa variável com um if ($variavel)

Nossa tela de edição carrega a categoria direitinho, no entanto, estamos trabalhando com a edição de categorias, que é basicamente a possibilidade de alterarmos seu nome. É para isto que serve a tela de "Editar Categoria".

Vamos testar modificando "Livros" para chamá-la de "Quadrinhos". Clicando no botão "Salvar", nada acontece, isso porque não estruturamos o comportamento desta página para que a edição seja feita. Então, em categorias-editar.php, há o formulário com o input passando o valor da categoria em seu value.

Como já temos uma categoria criada e, além do nome, o seu id (inclusive estamos instanciando a classe com ele), criaremos um campo novo no formulário, um input``hidden, um campo invisível que o usuário não vê, mas que consta em nosso HTML.

A informação que estiver em seu value também será processada. Portanto, teremos:

<div class="form-group">
    <label for="nome">Nome da Categoria</label>
    <input type="hidden" name="id" value="<?php echo $categoria->id ?>">
    <input type="text" value="<?php echo $categoria->nome ?>" class="form-control" placeholder="Nome da Categoria">
</div>
Vamos ver se isso funciona?

No navegador clicaremos com o lado direito do mouse em "Exibir código fonte da página", e será exibido o código HTML processado da página. O input type="text" consta com valor Livros, enquanto input type="hidden" aparece com value 1, o que corresponde ao valor da nossa categoria. Isto indica que o formulário funciona corretamente!

Agora, precisaremos submeter estas informações ao servidor. Faremos isto da mesma maneira com que fizemos a inserção de categorias, passando um parâmetro usando o action do nosso form. No mesmo arquivo, substituiremos # por categorias-editar-post.php, deixando a linha assim:

<form action="categorias-editar-post.php" method="post">
Porém, este arquivo ainda não existe, então o criaremos na raiz do projeto. Para testarmos o fluxo de submissão do formulário, simplesmente deixaremos o arquivo com:

entrou
Em seguida, atualizaremos a página no navegador e vamos clicar no botão "Salvar". Seremos redirecionados a uma página em branco com o texto "entrou", o que indica que tudo funciona como esperado. Voltaremos ao arquivo categorias-editar-post.php, abriremos o bloco PHP e faremos o require_once da classe Categoria.

Em categorias-editar.php, estamos passando as informações do formulário via method="post", criamos o input hidden com id e já temos o input com o nome da categoria, porém este não possui o atributo nome, sendo preciso criá-lo:

<input type="text" name="nome" value="<?php echo $categoria->nome ?>" class="form-control" placeholder="Nome da Categoria">
Como estamos submetendo o formulário via POST, resgataremos estas informações da mesma forma. Em categorias-editar-post.php, teremos:

<?php require_once 'classes/Categoria.php' ?>

<?php
    $id = $_POST['id'];
    $nome = $_POST['nome'];

    echo $id;
    echo '<br>';
    echo $nome;
Testaremos voltando ao navegador, editando a categoria "Filmes" para "Séries" e clicando em "Salvar". Na nova página, veremos:

3
Séries
Em que 3 é o id.

Então, apagaremos os echo que colocamos apenas para validação do código, e instanciaremos a classe Categoria, passando o id; toda aquela estrutura foi criada para que quando passarmos um valor de id no construtor da classe, esta automaticamente carregue o valor que queremos.

A partir deste momento, a categoria virá previamente com o nome original populado. No entanto, queremos mudá-lo para um novo, então chamaremos o método atualizar(), que criamos em Categoria.php.

E como a página não apresentará nada ao usuário, ele será redirecionado à lista novamente. Assim, ele terá um feedback visual de que a categoria editada foi de fato alterada.

O código de categorias-editar-post.php, portanto, ficará da seguinte maneira:

<?php require_once 'classes/Categoria.php' ?>

<?php
    $id = $_POST['id'];
    $nome = $_POST['nome'];

    $categoria = new Categoria($id);
    $categoria->nome = $nome;

    $categoria->atualizar();

    header('Location: categorias.php');
Testando no navegador, voltaremos à página com todas as categorias, dentre as quais editaremos "Revistas", que alteraremos para "Quadrinhos", e clicaremos em "Salvar". Como esperávamos, somos redirecionados à lista de novo, com o nome da categoria alterado, mesmo tendo o mesmo id de antes!

Estamos conseguindo editar nossas categorias! A partir de agora, vamos focar no outro botão que por ora não faz nada ainda ("Excluir"), para quando o usuário quiser deletar categorias.

Para criarmos o método de exclusão, editaremos novamente a lista de categorias, com o foreach. Da mesma forma que quando passamos o mouse sobre o botão "Editar" é mostrado o id da categoria, faremos o mesmo para "Excluir".

Passaremos ao botão o id da categoria que queremos excluir. No entanto, não teremos uma segunda tela de interação com o usuário, pois trata-se de um processo mais simples, em comparação com "Editar".

Vamos abrir o arquivo categorias.php, que contém o foreach, com cada linha das nossas categorias: uma com id, outra com id, com o botão de editar, e a última com o botão para exclusão, em que substituiremos # por /categorias-excluir-post.php, deixando o código assim:

<td><a href="/categorias-excluir-post.php?id=<?php echo $linha['id'] ?>" class="btn btn-danger">Excluir</a></td>
Feito isso, vamos atualizar o navegador! Desta vez, ao passarmos o mouse sobre o botão "Excluir", teremos o mesmo efeito visto em "Editar". Então, criaremos categorias-excluir-post.php, em que inicialmente faremos o require_once da classe com que iremos trabalhar para podermos instanciá-la, assim como fizemos nos demais arquivos.

Neste caso, estamos recebendo o valor do id da categoria via query string, portanto usaremos a variável GET para pegá-lo. Por fim, utilizaremos o echo para verificar seu funcionamento:

<?php require_once "classes/Categoria.php" ?>

<?php

    $id = $_GET['id'];
    echo $id;
Feito isso, vamos testar excluindo a categoria "Jogos" da listagem no navegador. Isto fará com que sejamos redirecionados à página contendo 2, que é a impressão do id da categoria excluída.

Agora, voltaremos à classe Categoria para criarmos o método referente a esta ação. Assim como fizemos anteriormente com os outros métodos, criaremos uma string com a instrução SQL para o delete, instanciando a conexão e executando a query.

Então, adicionaremos ao arquivo:

public function excluir()
{
    $query = "DELETE FROM categorias WHERE id = " . $this->id;
    $conexao = Conexao::pegarConexao();
    $conexao->exec($query);
}
Para testarmos, voltaremos ao arquivo que acabamos de criar (categorias-excluir-post.php), que deixaremos assim:

<?php require_once "classes/Categoria.php" ?>

<?php

    $id = $_GET['id'];
    $categoria = new Categoria($id);

    $categoria->excluir();

    header('Location: categorias.php');
Vamos ver se funciona voltando ao navegador e excluindo a categoria "Quadrinhos" e depois "Eletrodomésticos", o que conseguiremos fazer com sucesso!

Nesta aula aprendemos como carregar uma entidade ao instanciar a classe Categoria e, dessa forma, editá-la ou excluí-la. Faremos agora um script para editar todos os nomes de Categorias que temos cadastradas no banco de dados, acrescentando a palavra "Categoria" seguida de um espaço antes do nome dela, ficando da seguinte forma, por exemplo:

Categoria Livro
Categoria Jogos

Para fazer isso, vamos criar um arquivo na raiz do nosso projeto chamado editar-categoria-lote.php.

Nesse arquivo, a primeira coisa que vamos fazer é importar a classe Categoria com um require_once.

Em, seguida, vamos utilizar o método ->listar() da classe Categoria para obter uma lista com todas as categorias que temos no banco.

Depois, vamos fazer um foreach() com o resultado para poder atuar linha a linha na alterção do nome da Categoria.

Agora, vamos instanciar um novo objeto de Categoria dentro do foreach() passando como parâmetro o id daquela linha.

Por fim, com o objeto carregado, vamos alterar o atributo nome, passando o valor "Categoria " concatenado com o valor atual dela e em seguida, chamamos o método ->atualizar() para salvar as informações no banco de dados.

OBS: Podemos depois, chamar o método listar de novo para verificar se os dados foram salvos corretamente, usando a função print_r()

Código:

<?php

require_once 'classes/Categoria.php';

$categoria = new Categoria();
$lista_de_categoria = $categoria->listar();
foreach ($lista_de_categoria as $linha) {
    $categoria_edit = new Categoria($linha['id']);
    $categoria_edit->nome = 'Categoria ' . $categoria_edit->nome;
    $categoria_edit->atualizar();
}
$nova_lista_de_categoria = $categoria->listar();
echo '<pre>';
print_r($nova_lista_de_categoria);
echo '</pre>';
Resultado:

Array
(
    [0] => Array
        (
            [id] => 1
            [0] => 1
            [nome] => Categoria Livros
            [1] => Categoria Livros
        )

    [1] => Array
        (
            [id] => 2
            [0] => 2
            [nome] => Categoria Jogos
            [1] => Categoria Jogos
        )

    [2] => Array
        (
            [id] => 3
            [0] => 3
            [nome] => Categoria Filmes
            [1] => Categoria Filmes
        )

    [3] => Array
        (
            [id] => 4
            [0] => 4
            [nome] => Categoria Revistas
            [1] => Categoria Revistas
        )
)
