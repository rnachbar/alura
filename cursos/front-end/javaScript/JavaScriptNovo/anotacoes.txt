* Qualquer navegador da suporte ao JavaScript (dinamismo, página interativa)

############### 1. Introdução ###############

Seja bem vindo ao curso JavaScript: Programando na linguagem da web, e eu sou o Douglas Quintanilha e serei seu instrutor neste curso que te dará uma introdução a essa linguagem tão importante atualmente.

Você talvez possa estar se perguntando: por que o JavaScript hoje em dia é tão falado? Por que essa linguagem ganhou tanta popularidade ultimamente e por que eu, como desenvolvedor, tenho que aprendê-la?

O JavaScript é a linguagem de programação nativa da Web, melhorando a usabilidade e a interatividade do usuário com a página, por si só já bastaria como um excelente motivador para despertar seu interesse por essa fascinante linguagem, mas além de ser dominante nos cenários dos navegadores, o JavaScript recentemente também se expandiu para o lado do servidor com o lançamento do Node.js, um ambiente que permite criar um servidor Web completo utilizando o JavaScript, a linguagem ganhou grande popularidade e caiu ainda mais no gosto dos desenvolvedores, se tornando parte do coletivo imaginário de qualquer programador moderno.

E não é só no servidor que o Javascript ganhou terreno nos últimos anos, hoje em dia é possível programar um Arduino com a biblioteca Johnny-Five, criar um aplicativo para Desktop utilizando o framework Electron e até mesmo encontramos o banco de dados, como o MongoDB, que utiliza a sintaxe do JavaScript em suas queries. Hoje, o JavaScript está presente em diversas áreas do desenvolvimento.

Saber JavaScript lhe permite esticar suas habilidades de desenvolvedor para os mais diversos ramos da tecnologia, e é claro, a controlar e manipular qualquer página Web!

A partir de agora, estudaremos a sintaxe, como funciona essa linguagem, quais são suas nuances, através de um pequeno projeto, para explorar o JavaScript em sua principal área de atuação, no front-end, na manipulação de páginas Web.

O Javascript é uma das linguagens mais importantes de nosso tempo porque: é uma linguagem que, além de ser a padrão nos navegadores atuais, vem expandindo para outras áreas como servidores, banco de dados e até plataformas de Internet of Things.

O Javascript cresceu bastante e hoje em dia pode ser encontrado nas mais diversas plataformas de desenvolvimento. Dominá-la é essencial se você deseja desenvolver sites para a Web, já que ela é a linguagem que funciona em todos os navegadores e responsável por dar iteratividade e dinamismo as páginas web.

Ao longo deste treinamento, nós vamos aprimorar o site da Aparecida Nutrição. Aparecida é uma nutricionista que resolveu melhorar os seus processos organizacionais e migrar os dados de seus clientes para um site, ao invés de ficar consultando tudo em antigas fichas de papel.
Ela deseja conseguir adicionar novos clientes na tabela, calcular os seus IMCs e obter o estado de saúde sem ter que ficar fazendo cálculos manuais. Nós, como desenvolvedores contratados por ela, vamos melhorar o site atual dela para que ela possa ter disponíveis estas novas funcionalidades.

Baixando o projeto
O primeiro passo é baixar o projeto inicial deste treinamento, clicando aqui. Descompacte-o e acesse a pasta introducao-javascript em seu computador e abra-a em um editor de textos.

Durante o treinamento, o instrutor utiliza o editor de textos Atom, mas existem diversos outros, como o Sublime Text 3 e o Visual Studio Code, então use o de sua preferência.

Exibindo um alerta com JavaScript
Para começar a adicionar funcionalidade e dinamismo na página de pacientes, precisamos primeiro aprender como utilizamos o JavaScript corretamente em nossas páginas. Uma primeira tentativa é utilizar as funções do JavaScript dentro do corpo de nossa página.

No início do index.html, logo após a tag <body>, vamos exibir um alerta com JavaScript, através da função alert:

<body>
    alert("Olá mundo");

    <!-- Restante do index.html -->
</body>
Ao abrir a página index.html no navegador, vemos o seguinte resultado:

Navegador imprimindo alert como texto

O script está sendo exibido como texto, isto é, o navegador não fez nenhum tratamento especial para interpretar aquele código como um script.

Interpretando o JavaScript
Precisamos dar uma pista para que o navegador deixe de olhar aquele trecho de código como HTML e comece a vê-lo como um script que deve ser interpretado. Para isso, usamos a tag <script>:

<body>
    <script>
        alert("Olá mundo");
    </script>

    <!-- Restante do index.html -->
</body>
Agora sim! Quando recarregamos a página no navegador, nosso trecho de script é interpretado como um código, e não como um conteúdo qualquer da página, e o alerta é exibido.

A função alert é uma das funções como podemos utilizar para exibir mensagens com JavaScript, mas podemos utilizar também o console.log, que pode ser considerado mais agradável para exibir uma mensagem, já que ela não é exibida em uma pop-up, e sim no console do navegador.

Vamos testar:

<body>
    <script>
        console.log("Olá mundo");
    </script>

    <!-- Restante do index.html -->
</body>
No Linux ou Windows, para ver o console do navegador basta apertar F12, no OSX basta pressionar COMMAND + ALT + J. Ao abrir o console, vemos a mensagem:

Imprimindo uma mensagem no console do navegador

Além disso, o console do navegador também aceita funções JavaScript! Podemos escrever mais um console.log:

console.log("Aqui tem um recado para você");
Ou até mesmo um alerta:

alert("Olá");
Com o alert e o console.log, damos os primeiros passos com o JavaScript, entendendo que para o JavaScript funcionar, o seu código deve estar entre a tag <script>.

A tag <script> é responsável por nos ajudar a resolver este problema. Tudo que declaramos dentro da tag <script> é interpretado como Javascript quando o navegador passar por ali.
No caso abaixo:

<script>
alert("Olá mundo");
</script>
Quando o navegador passar pela tag abaixo ele vai interprar o texto "alert("Olá mundo");" e irá executar a função alert(), que é responsável por exibir uma pop up com a mensagem Olá mundo.

Ao abrir o HTML abaixo em um navegador, o que irá acontecer ?
<html>
    <head>
    </head>
    <body>
        <h1>Minha página com Javascript</h1>
        <script>
            Olá mundo!
        </script>
    </body>
</html>

No entanto, quando ler a tag <script>, o navegador entende que todo texto que está dentro da tag <script> deve ser lido como um Javascript, logo ele vai tentar interpretar a frase "Olá Mundo" como se fosse uma função Javascript válido. O que sabemos que não é, e então ele exibirá um erro de Unexpected Identifier, que nada mais é o que ele dizendo através do console de desenvolvedor que ele não entende "Olá mundo" como uma de suas funções.
Saber identificar e interpretar os erros do console é uma habilidade de todo bom desenvolvedor Javascript, então é bom começarmos a praticá-la desde já.

Se desejamos que uma mensagem seja exibida no console, devemos sempre chamar a função console.log(), que é a função que recebe como parâmetro o conteúdo da mensagem que queremos exibir no console.

Agora que você já viu que para o navegador interpretar o script, ele precisa estar envolvido pela tag <script>, está na hora de focarmos no nosso objetivo, que é manipular os dados da página HTML, para ela deixar de ser uma página estática, simples, e ter um pouco mais de interatividade com o usuário. Por exemplo, para que o IMC seja calculado automaticamente, que um paciente possa ser adicionado através da própria página, sem alterar o seu código HTML na mão.
Conhecendo o DOM
Para começar a manipular a página, no código JavaScript precisamos acessar o conteúdo do HTML da página. Afinal, tudo o que está dentro da tag <script> é interpretado como JavaScript, e o que está fora é interpretado como HTML.

No mundo JavaScript, para ter acesso ao HTML, precisamos primeiro conhecer o DOM (Document Object Model). O DOM é a representação do HTML para o nosso JavaScript, e para acessá-lo, podemos usar uma palavrinha do JavaScript chamada document.

No console do navegador, ao digitar document e pressionar ENTER, vemos que tudo o que está na página HTML é representado pelo document. E é ele que será a ponte entre o JavaScript e o HTML. Como ele representa o HTML, tudo o que alterarmos nele, alteraremos na página.

Manipulando o DOM
Mas se não quisermos manipular o DOM inteiro, mas sim só um pedaço seu, por exemplo o seguinte <h1>:

<h1>Aparecida Nutrição</h1>
Como faríamos para trocar o conteúdo para Aparecida Nutricionista, que é um pedaço do document? Temos que dar um jeito de pesquisar nele somente o que estamos interessados.

Para isso, existe o método querySelector, de document. Para ela, passamos como parâmetro, e entre aspas, quem queremos buscar. Por exemplo, no console do navegador podemos fazer:

document.querySelector("h1");
Assim, será selecionado o primeiro h1 da página, justamente o que queremos modificar. Então podemos passar esse código para o navegador e imprimir esse h1 no console do navegador para verificarmos se ele realmente foi selecionado:

<body>
    <script>
        console.log(document.querySelector("h1"));
    </script>

    <!-- Restante do index.html -->
</body>
Mas ao atualizar a página, o valor null é impresso! Por quê?

Onde declarar a tag <script>?
O browser, quando carrega a nossa página HTML, vai lendo linha por linha, começando de cima para baixo. Quando ele chega na tag <script>, ele tenta buscar um h1 na página, só que ele não está carregado na sua memória! Como o <h1> está abaixo do nosso código JavaScript, ele ainda não foi interpretado pelo navegador, logo não pode ser selecionado.

Até agora estamos escrevendo HTML e JavaScript no mesmo arquivo, o que pode se tornar confuso rapidamente conforme nosso código for crescendo. Para evitarmos isso, podemos escrevê-los em arquivos separados!

Diferentemente acontece quando executamos o código no console do navegador, já que a página já está toda carregada, logo o document está completo.

Por conta de situações como essa, é uma boa prática colocar a tag <script> no final do HTML, mais precisamente como último elemento da tag <body>, e não no começo da página:

<body>
    <!-- Restante do index.html -->
    <script>
        console.log(document.querySelector("h1"));
    </script>
</body>
Agora, ao recarregar a página, o h1 é impresso no console do navegador, logo ele foi selecionado corretamente.

Acessando e alterando o conteúdo de um elemento
Agora que conseguimos selecionar o h1, como alteramos o seu conteúdo de texto? A primeira coisa que podemos fazer é, ao invés de imprimi-lo, salvar o h1 em uma variável:

<script>
    var titulo = document.querySelector("h1");
</script>
Algumas tags, como h1, h2, p e span, possuem um conteúdo de texto. Nesses casos, o JavaScript possui uma propriedade que nos permite ter acesso a esse conteúdo de texto, que é a propriedade textContent. Vamos fazer um teste e imprimir o conteúdo de texto da variável titulo, que representa o h1:

<script>
    var titulo = document.querySelector("h1");
    console.log(titulo.textContent);
</script>
Somente o texto Aparecida Nutrição é impresso! Então assim conseguimos acessar e exibir o conteúdo de texto da tag. Mas como alterá-lo?

Para alterá-lo, basta passar um novo valor a ele, igualando a um novo texto:

<script>
    var titulo = document.querySelector("h1");
    titulo.textContent = "Aparecida Nutricionista";
</script>
Agora o texto da tag foi modificado na página, somente alterando a sua propriedade textContent.

Por último, sempre vale a pena a reflexão, quando estamos programando JavaScript, é sempre capaz estarmos programando com mais pessoas. Então o que acontece se outro desenvolvedor não resolver mais utilizar o h1 e sim um h2:
<h2>Aparecida Nutrição</h2>
Ao abrirmos a página no navegador, podemos verificar a seguinte mensagem no console:

Uncaught TypeError: Cannot set property 'textContent' of null
A mensagem disse que a propriedade textContent é nula. Isso aconteceu pois não há mais h1 na página para selecionarmos. O problema de buscar no DOM por uma tag é que o código JavaScript fica muito atrelado ao código HTML. É uma boa prática não buscar pela tag HTML em si, mas sim por outras opções que o querySelector nos disponibiliza.

Buscando um elemento através da sua classe
Além da tag HTML, o querySelector aceita que busquemos um elemento HTML através da sua classe ou do seu id, utilizando seletores CSS. Então, vamos colocar uma classe no que queremos buscar:

<h2 class="titulo">Aparecida Nutrição</h2>
E no nosso código JavaScript, vamos selecionar o elemento através da sua classe. O seletor CSS para classe é o ponto (.):

<script>
    var titulo = document.querySelector(".titulo");
    titulo.textContent = "Aparecida Nutricionista";
</script>
Agora o Aparecida Nutricionista aparece novamente na página. Se um outro desenvolvedor for no código HTML e modificar para o h1:

<h1 class="titulo">Aparecida Nutrição</h1>
O nosso código JavaScript continua funcionando! Pois desacoplamos o código JavaScript do código HTML, selecionando agora o elemento da sua classe, não da tag HTML, que pode mudar a qualquer hora.

Script como arquivo externo
Já que falamos em desacoplar, separar o código JavaScript do código HTML, podemos ver que estamos escrevendo todo o nosso código JavaScript no index.html, dentro da tag <script>. É uma boa prática separarmos os códigos, código JavaScript fica em arquivo JavaScript, código HTML fica em arquivo HTML e código CSS fica em arquivo CSS.

Assim como temos um arquivo para o HTML, e um para o CSS, vamos criar um arquivo que conterá o nosso código JavaScript, para não ficar misturando códigos na mesma página HTML.

Vamos então criar o arquivo principal.js, dentro na pasta /js, que conterá todo o nosso código JavaScript. Logo, moveremos o nosso código de dentro da tag <script> para dentro desse arquivo:

// principal.js

var titulo = document.querySelector(".titulo");
titulo.textContent = "Aparecida Nutricionista";
A nossa tag <script> continuará na página index.html. Porém, agora não terá nenhum conteúdo, mas em vez disso apontará para o arquivo JavaScript externo que criamos, através do atributo src. Como o arquivo principal.js está dentro da pasta js, especificamos seu caminho completo no atributo:

<script src="js/principal.js"></script>
O resultado da página deve continuar o mesmo.

Então é bem importante manter essa separação entre código HTML e código JavaScript.

Marque as alternativas abaixo que contêm características ou funcionalidades do console de desenvolvedor do navegador:

O console do desenvolvedor é uma ferramenta muito poderosa e versátil para o desenvolvedor Javascript. Com ele conseguimos rapidamente ser notificados de possíveis erros em nosso código, podemos executar funções, observar a saída de algumas funções e executar pequenos testes das funcionalidades do Javascript de modo rápido.

É uma boa prática sempre que estivermos testando nosso site ficar com o console aberto, para ficar monitorando possíveis erros em nosso código.

Como utilizar o console é algo bastante corriqueiro, podemos nos aproveitar dos atalhos CTRL + SHIFT + J ( Win/Linux) ou CMD + ALT + J (Mac) para ter acesso ao console de modo rápido.

Qual código abaixo importa corretamente um arquivo .js chamado contador.js que se encontra na mesma pasta de nosso arquivo HTML?

Sabemos que é importante fazer a separação de mundos HTML e Javascript, por isso criamos arquivos externos para guardar nosso código. Só que ao separar o Javascript em um arquivo externo, precisamos lembrar de importa-lo no HTML e para isso precisamos utilizar a tag <script> assim:
<script src="contador.js"></script>

Qual opção abaixo substitui o hasheado (XXXX) por um código que exibe uma pop up com a mensagem bem vindo ?
XXXX mensagem = "Seja bem vindo ao meu site!"

XXXX(mensagem);

Queremos declarar a variável mensagem, por isso devemos utilizar a palavra var para criar esta entidade:
var mensagem = "Seja bem vindo ao meu site!"
e logo em seguida desejamos exibir uma pop-up, logo é necessário utilizar a função alert que é responsável por isso:

alert(mensagem);

O que contêm a variável document do Javacript ?

O document é uma variável muito importante do Javascript. Ela contêm o DOM ou Document Object Model, que é como o navegador enxerga o HTML utilizado por ele para renderizar a página.
O navegador, ao ler o seu arquivo HTML, cria uma cópia em memória daquele HTML e a partir dessa cópia ele vai desenhando a sua página, colocando as tags e aplicando os estilos. Esta cópia é o que chamamos de DOM uma representação em memória do HTML do seu arquivo, que o navegador usa para desenhar a página, e a variável document é quem contêm o DOM.

Por isso, quando dizemos que com o Javascript nos estamos manipulando o DOM, estamos manipulando o que o navegador renderizou. Então ao trocar algum texto do DOM, o navegador imediatamente desenha novamente aquele texto, pois o DOM é o que o navegador usa para desenhar o seu site.

Outra caracteristica interessante, é que como manipulamos o DOM , quando trocamos um texto de um <h1> ou um estilo de um elemento, na verdade estamos alterando a representação em memória , o que faz com que o arquivo fonte que contêm seu HTML fique intacto!

Sabemos que o document contêm a representação de todo o HTML da nossa página, porém na maioria dos casos estamos interessados em apenas uma parte do HTML e não em ele todo.
Qual função podemos utilizar na variável document para especificar que queremos trazer apenas uma parte do HTML ?

Quando desejamos pegar apenas parte do HTML, devemos utilizar a função querySelector(). A função querySelector faz a busca através de seletores CSS para trazer o HTML que você está interessado. Por exemplo, no caso abaixo:
<h1 class="titulo"> Meu primeiro site</h1>
Podemos buscar este <h1> passando o seletor CSS correto para a função querySelector. Utilizando o setor de tag, podemos buscar assim:

document.querySelector("h1");
E utilizando um seletor CSS de classe, ficaria assim:

document.querySelector(".titulo");
Neste caso, ambas as funções retornaria o h1. Ter domínio dos seletores CSS é importante se você deseja trabalhar bem com o Javascript!

O primeiro arquivo .js
Para dar início ao nosso projeto, vamos começar criando nosso primeiro arquivo Javascript, o principal.js, que vai conter o código inicial que faremos neste primeiro capítulo. Para manter uma boa organização de código crie o arquivo principal.js dentro da pasta /js. Sua estrutra de pastas deve ficar assim:

introducao-javascript
├── css
│   ├── index.css
│   └── reset.css
├── js
│   └── principal.js
├── img
├── favicon.ico
└── index.html

Importando o arquivo
Claro que após criar um novo arquivo Javascript, não pode esquecer de importá-lo ao final da tag <body> em nosso HTML, utilizando a tag <script>:

// Restante do código HTML
            </section>
        </main>
        <!-- Importação dos Javascripts AQUI -->
        <script src="js/principal.js"></script>
    </body>
</html>
Repare que colocamos no atributo src o caminho relativo para nosso arquivo principal.js, ou seja a partir da pasta atual, vamos descer para a pasta js/ e em seguida linkar com arquivo.

Trocando o título da página
Para dar início aos nossos conhecimentos com o Javascript, vamos trocar o título da nossa página de Aparecida Nutrição para Aparecida Nutricionista, para praticar. Em nosso principal.js vamos:

1- O primeiro passo é selecionar o elemento da página que queremos alterar, neste caso o :

<h1>Aparecida Nutrição</h1>
Sabemos que é possível selecionar um elemento através de sua tag, e como só temos este h1 na página poderiamos fácilmente utilizá-lo, porém também vimos que não é uma boa prática utilizar um seletor de tag quando estamos selecionando um elemento do HTML, pois este h1 poderia facilmente ser trocado por um h2 e nosso código quebraria.

Vamos adicionar uma classe no h1 para que a seleção do elemento sempre seja feita atráves desta classe:

<h1 class="titulo">Aparecida Nutrição</h1>
2- Agora que o h1 já tem uma classe, podemos utilizar a função seletora do Javascript que é responsável de trazer um elemento do mundo do HTML para o mundo do Javascript que é a querySelector(). Sabemos que queremos buscar na nossa página pelo h1, então vamos chamar a querySelector() na variável que representa a nossa página para o Javascript , o document:

document.querySelector(".titulo");
Como queremos manipular este elemento selecionado, vamos colocá-lo em uma variável de nome semântico para poder ter acesso a ele depois:

var titulo = document.querySelector(".titulo");
3- Por último, como queremos trocar o texto do h1, vamos acessar a propriedade textContent do elemento selecionado, que é a propriedade que tem o contéudo de texto daquela tag. Como queremos alterar o contéudo de texto daquela tag, vamos trocar o valor da propriedade textContent para um novo texto, que é o nosso novo título Aparecida Nutricionista:

titulo.textContent = "Aparecida Nutricionista"
Ao recarregar a página você deve ver que assim que a página é carregada o novo título já aparece no topo!

############### 2. Variáveis e Operadores ###############

Já conseguimos selecionar um elemento da página, obter o seu texto e reescrevê-lo na página. Se já conseguimos isso, podemos iniciar a implementação do cálculo automático do IMC dos pacientes, facilitando a vida da Aparecida.
Cálculo do IMC
Para calcular o IMC, basta selecionar os valores do peso e da altura de um paciente da tabela, pois o cálculo é feito desta forma:

IMC = peso / altura x altura;
Então, precisamos trazer os dados do peso e altura para o mundo do JavaScript, calcular o IMC e escrevê-lo na sua devida coluna. Assim damos uma grande ajuda para a Aparecida.

É justamente isso que faremos nesse capítulo, vamos começar?

Extraindo o peso e a altura do paciente
Primeiramente, vamos focar no primeiro paciente, o Paulo. No index.html, se observamos o HTML que contêm os seus dados, vemos:

<tr class="paciente">
    <td class="info-nome">Paulo</td>
    <td class="info-peso">100</td>
    <td class="info-altura">2.00</td>
    <td class="info-gordura">10</td>
    <td class="info-imc">0</td>
</tr>
Vemos que cada paciente está dentro de uma linha da tabela (<tr>) e em cada coluna (<td>) há um dado. Já sabemos como selecionar um paciente, utilizando o querySelector:

// principal.js

var paciente = document.querySelector(".paciente");
Mas todos os pacientes possuem a classe paciente. Se queremos buscar o Paulo, devemos atribuir algo mais específico a ele, então vamos colocar um id nele:

<tr class="paciente" id="primeiro-paciente">
    <td class="info-nome">Paulo</td>
    <td class="info-peso">100</td>
    <td class="info-altura">2.00</td>
    <td class="info-gordura">10</td>
    <td class="info-imc">0</td>
</tr>
Voltando ao JavaScript, no querySelector, podemos utilizar o seletor de id, que é a tralha (#):

// principal.js

var paciente = document.querySelector("#primeiro-paciente");
Mas na verdade o que queremos é ter acesso aos dados de peso e altura do Paulo, então podemos fazer uma segunda busca, só que dessa vez vamos buscar no paciente, ao invés de em todo o documento:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

paciente.querySelector(".info-peso");
Aqui estamos buscando dentro do paciente, por um elemento que tenha a classe info-peso. Isso vai nos retornar a **<td>** que contêm este dado do paciente. De praxe, vamos salvar este dado uma variável:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
Se exibirmos no console o resultado , veremos:

console.log(tdPeso);

// Resultado:
// <td class="info-peso">100</td>
Conseguimos obter a tag que contêm o peso do nosso paciente, e para ter acesso ao seu conteúdo de texto, ao peso em si, já sabemos como fazer:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;
Só que para calcular o IMC, não precisamos só do peso, precisamos da altura também. Então vamos acessá-la utilizando a mesma lógica:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;
Com os dados extraídos para variáveis, podemos começar a calcular o IMC.

Calculando o IMC
Como vimos, o IMC é calculado através da seguinte fórmula:

IMC = peso / altura x altura
No caso do paciente Paulo, o resultado do IMC deveria ser:

IMC = 100 / 2.00 x 2.00
IMC = 100 / 4.00
IMC = 25
Então vamos replicar exatamente este cálculo no nosso JavaScript, salvando o resultado na variável imc:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

var imc = peso / altura * altura;
Quando imprimirmos o resultado da variável imc, esperamos encontrar 25, porém, na prática, ao exibir o resultado, encontramos o seguinte valor:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

var imc = peso / altura * altura;

console.log(imc);

// Resultado:
// 100
O console exibe 100 como resultado! Mas como é possível? Será que o JavaScript não sabe fazer esta multiplicação tão básica? Na verdade, a multiplicação está sendo feita, só que nós precisamos entender um pouco melhor como funcionam os operadores em JavaScript.

Entenderemos isso no próximo vídeo :)

Temos o seguinte fragmento HTML:
<table>
    <thead>
        <tr>
            <th>Nome</th>
            <th>Peso(kg)</th>
            <th>Altura(m)</th>
            <th>Gordura Corporal(%)</th>
            <th>IMC</th>
        </tr>
    </thead>
    <tbody id="tabela-pacientes">
        <tr class="paciente" id="primeiro-paciente">
            <td class="info-nome">Paulo</td>
            <td class="info-peso">100</td>
            <td class="info-altura">2.00</td>
            <td class="info-gordura">10</td>
            <td class="info-imc">0</td>
        </tr>
    </tbody>
</table>
Em seguida, temos o código que busca a tr que guarda os dados de um paciente. Usaremos um seletor de ID para a função document.querySelector:

var trPaciente = document.querySelector('#primeiro-paciente');
No entanto, queremos extrair o peso e a altura que representados pelos elementos do tipo td dentro da tr que acessamos no mundo JavaScript através da variável trPaciente.

Qual das opções abaixo acessa corretamente a partir de trPaciente o peso e a altura?
var tdPeso = trPaciente.querySelector('.info-peso');
var tdAltura = trPaciente.querySelector('.info-altura');
Com JavaScript podemos obter um elemento pai, no caso trPaciente e dele realizar novas consultas para obter elementos filhos, como foi o caso das TD's de peso e altura.

Mariana é dona de um restaurante que troca os pratos semanalmente. Os pratos são exibidos para seus clientes em seu site como uma tabela, como a abaixo:
<table>
<thead>
    <tr>            
        <th>Salada</th>
        <th>Prato Principal</th>
        <th>Acompanhamento</th>
    </tr>
<thead>
<tbody>
    <tr class="prato-do-dia" id="segunda">
        <td class='salada'>Alface e Tomate</td>
        <td class='principal'>Frango Grelhado</td>
        <td class='acompanhamento'>Arroz e Feijão preto</td>        
    </tr>
    ...Outros dias da semana
    <tr class="prato-do-dia" id="sexta">
        <td class='salada'>Salada de Batata</td>
        <td class='principal'>Macarrão com molho branco</td>
        <td class='acompanhamento'>Milho, ervilha e brócolis</td>        
    </tr>
</tbody>
Se Mariana deseja exibir o prato de cada dia em uma outra área de sua página, da forma abaixo:

Prato do dia!
Alface e Tomate
Frango Grelhado
Arroz e Feijão Preto
Qual código abaixo extrai as informações de um dia da tabela, por exemplo a sexta-feira, e imprime no console no formato que Mariana deseja?

var pratoDoDia = document.querySelector("#sexta");
var salada = pratoDoDia.querySelector(".salada").textContent;
var principal = pratoDoDia.querySelector(".principal").textContent;
var acompanhamento = pratoDoDia.querySelector(".acompanhamento").textContent;

console.log("Prato do dia!");
console.log(salada);
console.log(principal);
console.log(acompanhamento);
 
A melhor estratégia neste caso, como queremos buscar os pratos de um dia específico é primeiro buscar a <tr> que contêm os pratos deste dia, fazendo o uso da função document.querySelector:
var pratoDoDia = document.querySelector("#sexta");

Em seguida, vamos buscar dentro desta <tr> por os pratos específicos, então vamos utilizar a função querySelector na própria <tr> , afinal a função querySelector() é especialista em buscar, seja na página inteira quando utilizamos-a buscando no document (document.querySelector) ou quando queremos fazer uma busca em elemento específico que foi pré selecionado , como é o caso agora:
var salada = pratoDoDia.querySelector(".salada").textContent;
var principal = pratoDoDia.querySelector(".principal").textContent;
var acompanhamento = pratoDoDia.querySelector(".acompanhamento").textContent;
Já aproveitamos e imendamos na função seletora a propriedade textContent , afinal estamos interessados é no nome do prato que está escrito dentro da tag html, e não na tag em si!

Em seguida, basta apenas imprimirmos como foi solicitado:

console.log("Prato do dia!");
console.log(salada);
console.log(principal);
console.log(acompanhamento);

O JavaScript sabe fazer a multiplicação, ele só não entendeu um pouco a mensagem que tentamos passar para ele.
Fazendo contas em JavaScript, os operadores aritméticos
Em JavaScript, possuímos os operadores aritméticos normais de todas as linguagens de programação: +, -, *, / e % , mas também temos outros caracteres para nos ajudar a representar mais fielmente uma conta matemática, que são os parênteses: ().

Em nosso cálculo do IMC, representamos a conta deste modo:

var imc = peso / altura * altura;
Como não indicamos qual pedaço da conta deve ser feito primeiro, o JavaScript assumiu que não há prioridade e começou a conta da esquerda para a direita, ou seja , ele primeiro fez peso/altura, que dá 100 / 2.0 = 50 e depois pegou esse resultado e fez 50 * altura, que é 50 * 2 = 100, daí que surgiu este resultado maluco!

Para corrigir isto, precisamos colocar os parênteses na conta, para indicar em qual ordem deve ser executado as operações:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var tdAltura = paciente.querySelector(".info-altura");

var peso = tdPeso.textContent;
var altura = tdAltura.textContent;

var imc = peso / (altura * altura);
Agora sim, ao imprimir o IMC, obteremos o resultado esperado, que é 25!

Exibindo o IMC na tabela
Falta agora atualizarmos a tabela, após o cálculo do IMC. Então devemos selecionar a sua <td> do paciente:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

// selecionando a coluna do IMC
var tdImc = paciente.querySelector(".info-imc");

var imc = peso / (altura * altura);
Agora basta atribuir o conteúdo de texto da tdImc ao IMC calculado:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

// selecionando a coluna do IMC
var tdImc = paciente.querySelector(".info-imc");

var imc = peso / (altura * altura);

tdImc.textContent = imc;
Agora o IMC do Paulo é exibido na sua coluna!

Aprendemos que o cálculo do índice de massa corporal (IMC) é feito dividindo o nosso peso pela altura vezes a altura, o que pode ser representado pela seguinte fórmula na linguagem JavaScript:
alert(78 / (1.71 * 1.71));
No entanto, para melhoramos a legibilidade e manutenção deste código, podemos utilizar variáveis.

Quais opções abaixo possuem o mesmo resultado da instrução anterior com o auxílio de variáveis?

var peso = 78;
var altura = 1.71;
var imc = peso / (altura * altura);
alert(imc);


Conseguimos calcular o IMC do paciente Paulo, mas o que acontece se alguém, na hora de digitar o código HTML, sem querer colocar um número negativo no peso? Ou até mesmo um número absurdo, como 10 mil quilos?
IMC = 10000 / 2.00 x 2.00
IMC = 10000 / 4.00
IMC = 2500
É muito difícil algo assim existir. E às vezes uma pessoa, na pressa de digitar, pode acabar colocando um número a mais, ou um sinal de menos, e como há diversos pacientes, acaba não reparando nesses erros no HTML. Só acaba reparando quando a página é visualizada.

Validando os dados
O que podemos fazer, já que possuímos os dados relativos ao peso e à altura, é validar esses dados. E só calcularemos o IMC se o peso e a altura forem válidos, assim sempre teremos um IMC que reflete um peso a uma altura reais. Se o peso for muito alto, ou a altura muito baixo, por exemplo, colocamos uma mensagem de aviso dizendo que o paciente é inválido e deve ser verificado.

Atualmente o principal.js está assim:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

var tdImc = paciente.querySelector(".info-imc");

var imc = peso / (altura * altura);
tdImc.textContent = imc;
Antes de calcular o IMC, podemos começar a validar os dados, começando pelo peso. Com um if, podemos verificar se o peso é menor ou igual a 0, ou seja, negativo. Se o peso for negativo, imprimimos uma mensagem de alerta no console. Iremos adicioná-lo logo abaixo da variável tdImc:

var tdImc = paciente.querySelector(".info-imc");
if (peso <= 0) {
    console.log("Peso inválido!");
}
Se colocarmos um valor inválido para o peso no index.html...

<tbody id="tabela-pacientes">
    <tr class="paciente" id="primeiro-paciente">
        <td class="info-nome">Paulo</td>
        <td class="info-peso">-100</td>
        <td class="info-altura">2.00</td>
        <td class="info-gordura">10</td>
        <td class="infor-imc">0</td>
    </tr>
Será exibida a mensagem Peso inválido! no Console.

peso invalido

Além disso, 1000 quilos também é um valor muito alto para o peso de um ser humano. Então, vamos verificar isso também, adicionando outro if:


var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

var tdImc = paciente.querySelector(".info-imc");

if (peso <= 0) {
    console.log("Peso inválido!");
}

if (peso > 1000) {
    console.log("Peso inválido!");
}

var imc = peso / (altura * altura);
tdImc.textContent = imc;
No entanto, imagine o que aconteceria se para cada validação de peso, adicionássemos mais um if? O código acabaria ficando imenso! Porém, é possível juntar os dois tipos de verificações dentro de um único if, já que cada um deles retornará true ou false para as verificações, ou seja, teremos um resultado booleano:

if (peso < 0 OU peso > 1000) {
    console.log("Peso inválido!");
}
Só que a palavra OU não existe no JavaScript, mas existe um operador lógico nas linguagens de programação que poderá ser utilizado: ||.

Operador lógico OU
O operador lógico OU será representado por duas barras verticais (||), que recebem o nome de pipes:

if (peso < 0 || peso > 1000) {
    console.log("Peso inválido!");
}
Se a primeira condição (peso < 0) for verdadeira OU a segunda condição (peso > 1000) for verdadeira, o código dentro do if será executado. Ao testar, vemos que o funcionamento é o mesmo, mas nos poupando de fazer um if para cada caso.

Seria interessante também fazermos uma verificação parecida para a altura, considerando inválida aquela que for menor a 0, ou maior a 3:

if (altura < 0 || altura > 3.00) {
    console.log("Altura inválida!");
}
Se testarmos rodar o código com uma altura inválida, a mensagem Altura inválida! será exibida no console. Mas o cálculo do IMC ainda está sendo realizado, mesmo nós casos em que trabalhamos com alturas e/ou pesos inválidos, mas não é o que queremos. Nós gostaríamos que o IMC não fosse calculado nestes casos.

IMC somente com peso e altura válidos
Para não calcular o IMC quando o peso e a altura forem inválidos, podemos criar duas variáveis, uma para representar se o peso é válido, e outra para representar se a altura é válida, e vamos inicializá-las com true:

var pesoEhValido = true;
var alturaEhValida = true;

if (peso < 0 || peso > 1000) {
    console.log("Peso inválido!");
}

if (altura < 0 || altura > 3.00) {
    console.log("Altura inválida!");
}
Ou seja, estamos presumindo que ambos serão válidos. Mas caso não sejam, seus valores mudam para false dentro dos ifs:

if (peso < 0 || peso > 1000){
    console.log("Peso inválido!");
    pesoEhValido = false;
}

if (altura < 0 || altura > 3.00){
    console.log("Altura inválida!");
    alturaEhValida = false;
}
O valores das variáveis começam como verdadeiras, mas se der algo errado, elas serão settadas como false. Com as alterações, o código ficará assim:

// principal.js

var paciente = document.querySelector("#primeiro-paciente");

var tdPeso = paciente.querySelector(".info-peso");
var peso = tdPeso.textContent;

var tdAltura = paciente.querySelector(".info-altura");
var altura = tdAltura.textContent;

var tdImc = paciente.querySelector(".info-imc");

var pesoEhValido = true;
var alturaEhValida = true;

if (peso < 0 || peso > 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
}

if (altura < 0 || altura > 3.00) {
    console.log("Altura inválida!");
    alturaEhValida = false;
}

var imc = peso / (altura * altura);
tdImc.textContent = imc;
Agora, antes de calcular o IMC, faremos um pequena verificação das duas variáveis. Se a primeira (alturaEhValida) for verdadeira E a segunda (pesoEhValido) também for, nós vamos calculamos o IMC.

Operador lógico E
Para atender a condição de que uma coisa E outra devem ser verdadeiras, podemos utilizar o operador lógico E, representado por dois & (&&):

//...

var pesoEhValido = true;
var alturaEhValida = true;

if (peso < 0 || peso > 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
}

if (altura < 0 || altura > 3.00) {
    console.log("Altura inválida!");
    alturaEhValida = false;
}

if (alturaEhValida && pesoEhValido) {
    var imc = peso / (altura * altura);
    tdImc.textContent = imc;
}
Ao testarmos, veremos que se o peso ou a altura forem inválidos, o IMC não será calculado, imprimindo na coluna da tabela o valor igual a 0.

Imc igual a 0

Aviso para os usuários
Mas os usuários geralmente não ficam com o console do navegador aberto, então vamos deixar uma mensagem mais visual para eles. Na hora de verificar o peso e a altura, se algum deles for inválido, deixaremos uma mensagem mais significativa no campo do IMC, alterando o textContent:

//...

if (peso < 0 || peso > 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido!";
}

if (altura < 0 || altura > 3.00){
    console.log("Altura inválida!");
    alturaEhValida = false;
    tdImc.textContent = "Altura inválida!";
}

if (alturaEhValida && pesoEhValido){
    var imc = peso / (altura * altura);
    tdImc.textContent = imc;
}
Observe que alteramos o textContent para "Peso inválido" e "Altura inválida". Se colocarmos um peso ou uma altura inválidos no HTML e testar novamente a nossa página. A mensagem aparecerá conforme o esperado!

mensagem de imc invalido

Podemos fazer o mesmo teste alterando o valor da altura no index.html:

<tbody id="tabela-pacientes">
    <tr class="paciente" id="primeiro-paciente">
        <td class="info-nome">Paulo</td>
        <td class="info-peso">-100</td>
        <td class="info-altura">4.00</td>
        <td class="info-gordura">10</td>
        <td class="infor-imc">0</td>
    </tr>
Quando colocamos uma altura de 4.00, na tabela será exibida a mensagem de Altura Inválida!.

mensagem de altura invalida

Tem uma pequena falha nas nossas condições, se o peso for igual a 1000, o IMC continuará sendo calculado. Faremos um pequeno ajuste no if para que isso ocorra, agora a condição será de >=:

//...

if (peso <= 0 || peso >= 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido!";
}

if (altura <= 0 || altura >= 3.00){
    console.log("Altura inválida!");
    alturaEhValida = false;
    tdImc.textContent = "Altura inválida!";
}

if (alturaEhValida && pesoEhValido){
    var imc = peso / (altura * altura);
    tdImc.textContent = imc;
}
Tomamos o mesmo cuidado com os valores de peso. Como também não queremos que seja válido o valor 0 para altura e peso, alteramos a condição para <=. Detectamos mais um erro que poderia ocorrer no código.

Com esta última validação, chegamos ao fim da aula. Vimos vários assuntos como as lógicas de if e calcular o IMC adicionando os parênteses. Mostramos o uso adequado dos operadores de matemática e o operador lógico de OU (||), utilizado na condição para entrar no if. Vimos também o &&, usado com o significado de E na condição.

Buscando os dados do primeiro paciente
Neste capítulo vamos calcular o IMC do primeiro paciente , buscando os seus dados de altura e peso, fazendo as validações necessárias e em seguida vamos preencher o IMC na tabela.

Em seu arquivo principal.js, vá executando o passo a passo abaixo:

1- Vamos primeiro selecionar o primeiro paciente, que é uma <tr> com a nossa conhecida função document.querySelector() e salvar na variável paciente. Vamos usar o seletor de #id. Se você ainda não colocou, adicione o id primeiro-paciente no primeiro <tr> de nossa tabela:

<!-- restante do HTML -->
<tr class="paciente" id="primeiro-paciente">
    <td class="info-nome">Paulo</td>
    <td class="info-peso">100</td>
    <td class="info-altura">2.00</td>
    <td class="info-gordura">10</td>
    <td class="info-imc">0</td>
</tr>
Em seguida no seu principal.js, selecione o paciente:

var paciente = document.querySelector("#primeiro-paciente");
2- Agora com o paciente em mãos, podemos buscar dentro dele as informações que precisamos que são a altura e o peso da paciente. Vamos utilizar a função querySelector() desta vez para buscar dentro da váriavel paciente, pelo <td> que contêm a altura e o peso:

var tdPeso = paciente.querySelector(".info-peso");
var tdAltura = paciente.querySelector(".info-altura");
3- Mas sabemos que não estamos interessados nos <td> e sim no conteudo de texto de cada um deles, então vamos extraí-los:

var tdPeso = paciente.querySelector(".info-peso");
var tdAltura = paciente.querySelector(".info-altura");

var peso = tdPeso.textContent;
var altura = tdAltura.textContent;
4- Com os valores de peso e altura em mãos, podemos calcular o IMC. Não vamos nos esquecer dos parênteses também para que nossa conta seja feita como esperamos:

var imc = peso / (altura * altura);
5- Por último, com o IMC calculado devemos preencher a coluna de IMC do paciente selecionado com novo valor calculado. Vamos primeiro pegar o <td> que irá guardar o IMC:

var tdImc = paciente.querySelector(".info-imc");
6- Agora vamos colocar o valor calculado dentro do tdImc:

tdImc.textContent = imc;
Seu código deve estar assim:

var tdPeso = paciente.querySelector(".info-peso");
var tdAltura = paciente.querySelector(".info-altura");

var peso = tdPeso.textContent;
var altura = tdAltura.textContent;

var imc = peso / (altura * altura);
var tdImc = paciente.querySelector(".info-imc");
tdImc.textContent = imc;
Agora, ao recarregar a página, você verá que o IMC do primeiro paciente.

Já estamos conseguindo calcular o IMC, porém falta validar os dados que vem da tabela. Vamos lá:
1- O primeiro passo é fazer uma verificação do peso, vamos estabelecer que um peso é inválido se ele for menor ou igual a 0 quilos OU maior que 1000 quilos. Para isto, vamos utilizar um if para checar o peso, e a condição lógica de OU (||):

if(peso <= 0 || peso > 1000){
    console.log("Peso inválido");
}
2- Não basta apenas exibir no console a validação. Vamos escrever na coluna do IMC também o erro de peso inválido:

if(peso <= 0 || peso > 1000){
    console.log("Peso inválido");
    tdImc.textContent = "Peso inválido!";
}
3- Vamos repetir a mesma lógica para a altura, só que considerando inválido uma altura menor ou igual a 0 metros ou maior ou igual a 3 metros.

if(altura <= 0 || altura >= 3){
    console.log("Altura inválida");
    tdImc.textContent = "Altura inválida!";
}
4- Agora não basta verificar se a altura ou o peso estão errados, só devemos calcular o IMC se ambos passarem na validação. Para isto, vamos criar duas variáveis, pesoEhValido e alturaEhValida, iniciar seus valores como true. Caso as validações falhem , trocaremos este valor para false:

var alturaEhValida = true;
var pesoEhValido = true;

if(peso <= 0 || peso > 1000){
    console.log("Peso inválido");
    tdImc.textContent = "Peso inválido!";
    pesoEhValido = false;
}

if(altura <= 0 || altura >= 3){
    console.log("Altura inválida");

    tdImc.textContent = "Altura inválida!";
    alturaEhValida = false;
}
5- Agora vamos fazer uma lógica para apenas calcular o IMC se o peso E a altura forem válidos. Vamos utilizar o operador lógico de E (&&):

var alturaEhValida = true;
var pesoEhValido = true;

if(peso <= 0 || peso > 1000){
    console.log("Peso inválido");
    tdImc.textContent = "Peso inválido!";
    pesoEhValido = false;
}

if(altura <= 0 || altura >= 3){
    console.log("Altura inválida");
    tdImc.textContent = "Altura inválida!";
    alturaEhValida = false;
}

if(pesoEhValido && alturaEhValida){
    var imc = peso / ( altura * altura);    
    tdImc.textContent = imc;
}
O seu código final deve estar assim:

var tdPeso = paciente.querySelector(".info-peso");
var tdAltura = paciente.querySelector(".info-altura");

var tdImc = paciente.querySelector(".info-imc");

var peso = tdPeso.textContent;
var altura = tdAltura.textContent;

var alturaEhValida = true;
var pesoEhValido = true;

if(peso <= 0 || peso > 1000){
    console.log("Peso inválido");
    tdImc.textContent = "Peso inválido!";
    pesoEhValido = false;
}

if(altura <= 0 || altura >= 3){
    console.log("Altura inválida");
    tdImc.textContent = "Altura inválida!";
    alturaEhValida = false;
}

if(pesoEhValido && alturaEhValida){
    var imc = peso / ( altura * altura);    
    tdImc.textContent = imc;
}
Agora estamos validando antes de realizar o cálculo do IMC!


############### 3. Arrays, Loop e Estilos ###############

Já conseguimos realizar a validação do primeiro paciente, calculando o IMC e verificando se a altura e peso são válidos, chegou a hora de replicarmos esse código de validação e cálculo do IMC para os restantes dos pacientes.
Praticamente todo o código do arquivo principal.js é o responsável por calcular o IMC do paciente, com as validações. Então bastaria copiarmos esse código, modificar a classe referente ao paciente e os nomes das variáveis, que já validamos outro paciente, certo?

Repetição de código nunca é uma boa prática de programação, o ideal é sempre reaproveitá-lo. No nosso caso, poderíamos fazer um loop, já conhecido da lógica e programação, para podermos iterar por cada linha da tabela de pacientes, ou seja, por cada paciente. Para cada paciente, queremos selecionar os seus dados e calcular o IMC.

Selecionando todos os elementos que possuem a mesma classe
Então, se queremos iterar por todos os pacientes, primeiramente devemos selecioná-los, e não mais selecionar somente um paciente, que é o que estamos fazendo atualmente. Se formos conferir a tabela no index.html, podemos ver que todos os pacientes possuem a classe paciente:

<tbody id="tabela-pacientes">
    <tr class="paciente" id="primeiro-paciente">
        <!--Paciente Paulo-->
    </tr>
    <tr class="paciente" >
        <!--Paciente João-->
    </tr>
    <tr class="paciente" >
        <!--Paciente Erica-->
    </tr>
    <tr class="paciente">
        <!--Paciente Douglas-->
    </tr>
    <tr class="paciente" >
        <!--Paciente Tatiana-->
    </tr>
</tbody>
Logo, em vez de buscar pelo id primeiro-paciente, vamos buscar pela classe paciente. Vamos testar isso:

var pacientes = document.querySelector(".paciente");
console.log(pacientes);
Mas apesar de termos selecionado por classe, só nos foi retornado o primeiro paciente, a primeira linha com a classe paciente. Isso porque a função querySelector nos retorna apenas um elemento, independentemente do seletor que passarmos para a mesma. Se estamos interessados em buscar vários elementos que possuem a mesma classe, devemos utilizar a função querySelectorAll:

var pacientes = document.querySelectorAll(".paciente");
console.log(pacientes);
Essa função nos retorna um array com todos os elementos que possuem a classe paciente!

Iterando sobre os pacientes
Agora que temos todos os pacientes que estavam na tabela, devemos iterar por eles, e para cada paciente executamos o código responsável por calcular o IMC e validar o peso e altura.

Há várias formas de fazermos isso, mas uma forma bastante conhecida de todo mundo que já viu alguma coisa de lógica de programação é o loop for. Esse loop recebe três argumentos: a declaração da variável inicial, até onde queremos que essa variável cresça, e o que queremos fazer ao final de cada iteração. Por exemplo:

var pacientes = document.querySelectorAll(".paciente");

for (var i = 0; i < 5; i++) {

}
Mas não queremos percorrer um número fixo, queremos percorrer a lista de pacientes, então vamos percorrer até o tamanho da lista de pacientes, usando a propriedade length:

var pacientes = document.querySelectorAll(".paciente");

for (var i = 0; i < pacientes.length; i++) {

}
Cada elemento do array tem um índice, que começa da posição 0, que representará o primeiro paciente, o 1 será o segundo paciente e assim por diante. Para acessar o paciente do array, basta passarmos o índice entre colchetes para o mesmo. Esse índice será a variável i, que percorrerá do valor 0 até a última posição do array de pacientes menos 1:

var pacientes = document.querySelectorAll(".paciente");

for (var i = 0; i < pacientes.length; i++) {
    console.log(pacientes[i]);
}
Agora que temos acesso ao paciente, basta movermos todo o código que calcula o IMC e faz a validação, para dentro do loop for. Além disso, para não termos que alterar o código, criaremos a variável paciente, que será apenas um atalho para pacientes[i]:

var pacientes = document.querySelectorAll(".paciente");

for (var i = 0; i < pacientes.length; i++) {

    var paciente = pacientes[i];

    var tdPeso = paciente.querySelector(".info-peso");
    var peso = tdPeso.textContent;

    var tdAltura = paciente.querySelector(".info-altura");
    var altura = tdAltura.textContent;

    var tdImc = paciente.querySelector(".info-imc");

    var pesoEhValido = true;
    var alturaEhValida = true;

    if (peso <= 0 || peso >= 1000) {
        console.log("Peso inválido!");
        pesoEhValido = false;
        tdImc.textContent = "Peso inválido";
    }

    if (altura <= 0 || altura >= 3.00) {
        console.log("Altura inválida!");
        alturaEhValida = false;
        tdImc.textContent = "Altura inválida";
    }

  if (alturaEhValida && pesoEhValido) {
        var imc = peso / (altura * altura);
        tdImc.textContent = imc;
    }
}
Agora o IMC de todos os pacientes está sendo calculado!

imcs calculados

Limitando as casas decimais de um número
Alguns dos IMCs possuem diversas casas decimais, tornando o número imenso. Podemos melhorar isso utilizando uma função do JavaScript que limita a quantidade de casas decimais de um número. Essa função é a toFixed(), que recebe como parâmetro a quantidade de casas decimais que queremos exibir do número.

Vamos utilizá-la no momento em que o IMC é impresso na sua célula:

if (alturaEhValida && pesoEhValido) {
    var imc = peso / (altura * altura);
    tdImc.textContent = imc.toFixed(2);
}
imc com toFixed

Agora a visualização dos IMCs ficou um pouco melhor, sem tantos números nas casas decimais. Estamos conseguindo validar o IMC e fazer os cálculos para todos os pacientes.

Por enquanto temos somente 5 pacientes, e para identificar um paciente que tenha um peso ou uma altura inválida exibimos uma mensagem. Mas e se houver 50, 100 pacientes? A Aparecida Nutricionista deverá ficar scrollando a página e procurar pelas mensagens.

Por isso queremos deixar uma marcação mais visual para a nutricionista, para indicar as linhas com problema, com erros. Vamos deixar a linha que tenha um peso ou uma altura inválida com o fundo vermelho.

Então, vamos ao arquivo principal.js para ver como poderíamos fazer isso. Se queremos pintar o fundo da linha de vermelho quando há algum erro de validação, o que nos interessa é o código abaixo, justamente o código que faz a validação do peso e da altura do paciente:

if (peso <= 0 || peso >= 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido";
}

if (altura <= 0 || altura >= 3.00) {
    console.log("Altura inválida!");
    alturaEhValida = false;
    tdImc.textContent = "Altura inválida";
}
Para isso, para manipular a linha, devemos primeiramente selecioná-la, o que já fizemos, já que ela é representada pela variável paciente. Como queremos modificar o estilo do elemento, utilizamos a propriedade style, que contém os estilos aplicados que podem ser aplicados ao HTML. Para modificar a cor de fundo do elemento, utilizamos a propriedade background-color, que no JavaScript é identificado como backgroundColor:

if (peso <= 0 || peso >= 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido";
    paciente.style.backgroundColor = "lightcoral";
}

if (altura <= 0 || altura >= 3.00) {
    console.log("Altura inválida!");
    alturaEhValida = false;
    paciente.style.backgroundColor = "lightcoral";
}
Agora toda vez que há um erro, isso fica bem visível na tabela, assim sabe-se onde tem que alterar.

Alterando estilo no JavaScript?
Mas e se o designer decide que a cor de fundo não será mais vermelha, e sim laranja? Devemos nos lembrar de modificá-la nas duas verificações! Tanto na verificação do peso quanto da altura.

O grande problema é que temos vários pontos do nosso código manipulando o CSS do elemento, e já vimos que quando queremos estilizar a página, devemos fazê-lo no CSS, mas estamos fazendo no JavaScript.

É importante manter essa separação dos "mundos", o HTML é utilizado para marcar os elementos, o JavaScript para adicionar dinamismo, manipular a página, e o CSS para estilizar. Logo, o ideal não é modificar o estilo da linha no código JavaScript, então qual é o meio termo entre não modificar o estilo diretamente, mas conseguir alterá-lo, no JavaScript?

É uma boa prática, ao invés de adicionar um estilo, adicionar uma classe ao elemento. E no CSS, nós estilizamos o elemento através do seletor de classe. Então, no index.css, nós estilizamos o elemento com a classe:

.paciente-invalido {
    background-color: lightcoral;
}
E no JavaScript, assim como temos o style para acessar os estilos, o textContent para acessar o conteúdo de texto de um elemento, temos a classList para acessar as classes. E através do método add, conseguimos adicionar a classe que quisermos. Vamos adicionar então a classe paciente-invalido:

if (peso <= 0 || peso >= 1000) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido";
    paciente.classList.add("paciente-invalido");
}

if (altura <= 0 || altura >= 3.00) {
    console.log("Altura inválida!");
    alturaEhValida = false;
    tdImc.textContent = "Altura inválida";
    paciente.classList.add("paciente-invalido");
}
Agora, se o designer quiser modificar a cor de fundo, basta modificá-la no CSS, e não mais no JavaScript.


############### 4. Eventos, Formulários e Criando Elementos ###############

Agora que já temos na tabela o cálculo do IMC de todos pacientes, com as suas validações, inclusive com uma marcação visual indicando as linhas com problema de validação, vamos agora facilitar a vida da Aparecida em relação à adição de pacientes.
Formulário para adição de pacientes
Atualmente, se a Aparecida quiser adicionar um novo paciente, ela deve ir até o HTML, no arquivo index.html, e incluir uma nova <tr> na tabela, juntamente com as suas tags <td>, o que não é nada prático. Seria muito mais fácil que, em vez de adicionar o paciente na mão diretamente no HTML, ela tivesse um formulário na página, em que ela o preenchesse com os dados do paciente, e ao clicar em um botão de adicionar, o paciente fosse para a tabela. E é exatamente isso que iremos implementar.

Como esse é um curso focado em JavaScript, já temos o formulário pronto, basta adicioná-lo abaixo do fechamento da tag <main>, ou seja, da tag </main>, antes da tag <script>:

<section class="container">
    <h2 id="titulo-form">Adicionar novo paciente</h2>
    <form>
        <div class="">
            <label for="nome">Nome:</label>
            <input id="nome" name="nome" type="text" placeholder="digite o nome do seu paciente" class="campo">
        </div>
        <div class="grupo">
            <label for="peso">Peso:</label>
            <input id="peso" name="peso" type="text" placeholder="digite o peso do seu paciente" class="campo campo-medio">
        </div>
        <div class="grupo">
            <label for="altura">Altura:</label>
            <input id="altura" name="altura" type="text" placeholder="digite a altura do seu paciente" class="campo campo-medio">
        </div>
        <div class="grupo">
            <label for="gordura">% de Gordura:</label>
            <input id="gordura" type="text" placeholder="digite a porcentagem de gordura do seu paciente" class="campo campo-medio">
        </div>

        <button id="adicionar-paciente" class="botao bto-principal">Adicionar</button>
    </form>
</section>
Esse formulário possui os campos para preencher o nome, peso, altura e porcentual de gordura do paciente:

Formulário de adição de paciente

Ou seja, ao preencher esses campos e clicar no botão Adicionar, uma nova linha na tabela deve ser criada, com os dados dos pacientes que foram digitados no formulário. Mas para fazer isso, primeiramente devemos entender algumas funcionalidades do JavaScript.

Detectando o clique de um botão
No exato momento em que o usuário clicar no botão, queremos adicionar o paciente na tabela com os dados preenchidos no campo, certo? Mas como que detectamos, percebemos o momento em que o usuário clica no botão?

A ação de "perceber o que o usuário está fazendo na página", é o que chamamos de eventos do browser, eventos que podemos escutar com o JavaScript. Clicar, duplo clique em algo, scrollar, passar o mouse em cima, são exemplos de ações que o usuário pode fazer para interagir com a nossa página, e essas ações nós conseguimos escutar no JavaScript através dos chamados eventos.

Para escutar um evento de clique, primeiro devemos especificar em que elemento queremos escutar esse evento. Se queremos escutar o evento clique do botão, vamos selecioná-lo, através do seu id:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
Com a variável em mãos, podemos colocar um "escutador de eventos" para escutar as interações do usuário com o elemento. Para colocar um "escutador", devemos chamar a função addEventListener. Essa função faz exatamente o que o seu nome diz, ela fica escutando algum evento específico, evento esse que deve ser passado por parâmetro para a função. No nosso caso, escutaremos o evento de click:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click");
E enquanto estivermos escutando o evento de clique, queremos fazer algo quando o usuário clicar no botão. Dizemos o que queremos fazer através de uma função, passada como segundo parâmetro para função addEventListener:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", funcaoQueFazAlgo);

function funcaoQueFazAlgo() {

}
Se não quisermos criar uma função à parte, podemos passar uma função anônima. Ao invés de chamar a função no parâmetro, nós criamos-a diretamente:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function() {

});
O segundo parâmetro continua sendo uma função, só que ela não possui nome, e dentro dela podemos implementar o código que será executado no momento em que o usuário fizer a ação que está sendo escutada, no caso o clique no botão. Por enquanto vamos somente exibir uma mensagem, dizendo que clicamos no botão:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function() {
    console.log("Oi, cliquei no botão.");
});
Podemos clicar no botão, mas nada acontece! Porque?

Comportamento padrão do botão de um formulário
O que está acontecendo é que toda vez que clicamos em um botão que está dentro de um formulário (tag <form>), o seu comportamento padrão é que esse formulário, os seus dados sejam enviados para outra página. Como não especificamos nenhuma página dentro da tag <form> para os dados serem enviados, o que está acontecendo é que a nossa página está sendo recarregada, e o formulário sendo limpo. E o fato da página ser recarregada faz o console ser limpo, por isso não vemos a mensagem. Logo, o evento de clique está sendo escutado corretamente, só que como a página é recarregada rapidamente, não conseguimos ver a mensagem exibida.

Veremos como alterar esse comportamento padrão no próximo vídeo :)

Vimos no vídeo passado que o comportamento padrão de um botão que se encontra dentro de um formulário é limpar o formulário, recarregar a página e enviar os dados, e nós queremos evitar esse comportamento padrão.
Prevenindo o comportamento padrão de um evento
Para isso, devemos chamar uma função característica dos eventos, que faz com que o evento não faça seu comportamento padrão. Ele não irá fazer o seu comportamento padrão, e irá fazer o comportamento que pedirmos ao evento, no nosso caso somente exibir a mensagem.

Essa função característica dos eventos do JavaScript é a event.preventDefault():

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function() {
    event.preventDefault();
    console.log("Oi, cliquei no botão.");
});
Essa função é exatamente o que o nome dela diz, algo como prevenir o comportamento padrão do evento. Mas para utilizá-la, precisamos receber por parâmetro na função anônima o event:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();
    console.log("Oi, cliquei no botão.");
});
Podemos testar novamente a página, preencher o formulário e clicar no botão. Podemos reparar em duas coisas, a página não é recarregada e o formulário não foi limpo. Além disso, conseguimos ver a mensagem no console, claro!

Agora que já conseguimos detectar o evento de clique no botão, podemos adicionar os dados do paciente na tabela. Veremos como fazer isso com JavaScript no próximo vídeo!

Para conseguir adicionar o paciente na tabela, primeiro devemos capturar os dados do formulário, para podermos utilizá-los na tabela. Para pegar os dados do formulário, sabemos que devemos trazê-lo do mundo HTML para o mundo JavaScript, selecionando-o.

Para isso, vamos adicionar um id ao formulário:

<form id="form-adiciona">
    <!-- restante do formulário omitido -->
</form>
Agora conseguimos selecioná-lo no mundo JavaScript:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");
});
Através do formulário, temos acesso aos seus inputs, acessando através da sua propriedade name. Podemos ver no HTML que todos os inputs possuem uma propriedade name, bastando utilizá-lo para ter acesso ao input:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome;

});
Mas não estamos interessados no campo em si, no input, e sim no seu valor. Para acessar o valor de um campo em JavaScript, utilizamos a propriedade value:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;

});
Sabendo disso, podemos capturar o valor do restante dos campos:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

});
Com isso, conseguimos trazer os dados do formulário do HTML para o JavaScript, para poder adicionar o paciente na tabela.

Criando um elemento HTML com JavaScript
Com os dados em mãos, como vamos fazer para criar um paciente? Até agora vimos como trazer algo do mundo HTML para o mundo JavaScript, mas agora é o contrário, temos os dados no mundo JavaScript e queremos criar uma nova linha na tabela com eles, que é no mundo HTML. Ou seja, queremos criar um elemento HTML utilizando JavaScript.

Para isso, vamos utilizar a função createElement, que como o próprio nome diz, cria um elemento HTML. Podemos olhar o HTML da tabela e ver que se queremos criar um novo paciente, devemos criar uma nova tr, que por sua vez possui várias tds, cada uma com o seu dado.

Logo, se queremos criar um paciente, vamos criar uma nova tr. Para criar um elemento, precisamos dizer onde queremos criar, vamos criá-lo em document, :

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

});
Agora que sabemos criar um elemento, podemos criar as tds:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

});
Só que criamos seis elementos distintos, seria como se tivéssemos criado um HTML assim:

<tr></tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
Sabemos que temos que colocar os dados dentro das tds, e depois pegá-las e colocá-las dentro da tr. Vamos por passos, primeiro colocando os dados dentro das tds, que já sabemos como é feito.

Lembra quando alteramos o conteúdo de texto do título? Utilizamos a propriedade textContent, passando para ela o novo dado. Pois aqui é a mesma coisa, vamos alterar o conteúdo de texto das tds, passando os seus respectivos valores, que capturamos do formulário:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = nome;
    pesoTd.textContent = peso;
    alturaTd.textContent = altura;
    gorduraTd.textContent = gordura;

});
Utilizando o JavaScript para adicionar um elemento dentro de outro
Agora devemos adicionar cada td dentro da tr. No JavaScript existe uma função chamada appendChild. Essa função adiciona como filho o elemento passado a ela como parâmetro. Logo, vamos chamar essa função na tr, passando a td como parâmetro, uma por uma:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = nome;
    pesoTd.textContent = peso;
    alturaTd.textContent = altura;
    gorduraTd.textContent = gordura;

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);

});
Agora já temos algo mais próximo do que é um paciente, faltando colocá-lo dentro da tabela. Para colocar o paciente na tabela, vamos fazer a mesma coisa, selecionar a tabela, o tbody, do HTML através do seu id e utilizar a função appendChild para adicionar a tr como sua filha:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = nome;
    pesoTd.textContent = peso;
    alturaTd.textContent = altura;
    gorduraTd.textContent = gordura;

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

});
Agora, no momento que preenchemos os dados do formulário e clicamos em Adicionar, o paciente é adicionado na tabela!

Ainda não estamos calculando o IMC, mas faremos isso no próximo capítulo, vendo como construir um código bem organizado.


############### 5. Boas Práticas com Javascript ###############

O nosso código JavaScript está crescendo bastante, e atualmente ele possui duas funcionalidades: calcular o IMC, juntamente com as validações, e adicionar um paciente do formulário na tabela de pacientes.
À medida que formos adicionando mais funcionalidades, o arquivo vai crescendo, ficando um pouco difícil de mantê-lo. Buscar uma função ou um fragmento de código poderá custar um pouco de tempo.

Apesar de funcional, nosso código não está muito bem organizado, muito bem separado. Uma boa prática é dividir o código, e uma das maneiras de dividir isso é separar o código em arquivos JavaScript diferentes, de acordo com as suas funcionalidades.

Então vamos criar um novo arquivo JavaScript, chamado form.js, dentro da pasta js. Nesse arquivo ficará tudo o que for relacionado ao formulário de adição de pacientes. Então vamos mover o código:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;

    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = nome;
    pesoTd.textContent = peso;
    alturaTd.textContent = altura;
    gorduraTd.textContent = gordura;

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

});
Agora sabemos que se quisermos implementar uma nova funcionalidade relacionado ao formulário, é no arquivo form.js que devemos trabalhar, assim ficamos com arquivos menores, mais fáceis de manter.

Para deixar os arquivos mais semânticos, e mais ainda organizados, vamos renomear o arquivo principal.js para calcula-imc.js:

// calcula-imc.js

var titulo = document.querySelector(".titulo");
titulo.textContent = "Aparecida Nutricionista";

var pacientes = document.querySelectorAll(".paciente");

for (var i = 0; i < pacientes.length; i++) {

    var paciente = pacientes[i];

    var tdPeso = paciente.querySelector(".info-peso");
    var peso = tdPeso.textContent;

    var tdAltura = paciente.querySelector(".info-altura");
    var altura = tdAltura.textContent;

    var tdImc = paciente.querySelector(".info-imc");

    var pesoEhValido = true;
    var alturaEhValida = true;

    if (peso <= 0 || peso >= 1000) {
        console.log("Peso inválido!");
        pesoEhValido = false;
        tdImc.textContent = "Peso inválido";
        paciente.classList.add("paciente-invalido");
    }

    if (altura <= 0 || altura >= 3.00) {
        console.log("Altura inválida!");
        alturaEhValida = false;
        tdImc.textContent = "Altura inválida";
        paciente.classList.add("paciente-invalido");
    }

    if (pesoEhValido && alturaEhValida) {
        var imc = peso / (altura * altura);
        tdImc.textContent = imc.toFixed(2);
    }
}
Por fim, no index.html, não podemos nos esquecer de importar os dois novos scripts, e apagar a importação do antigo:

<script src="js/calcula-imc.js" ></script>
<script src="js/form.js" ></script>
Agora já temos uma separação de arquivos, cada um com sua funcionalidade, o que já é um começo para melhor organização do nosso código.

Uma outra boa prática que podemos implementar no nosso código é separar os blocos de código em blocos menores, em funções. Porque?
Temos dois bons exemplos para demonstrar como o nosso código está fazendo muita coisa dentro de um único bloco de código. No arquivo calcula-imc.js, dentro do for, pegamos os dados dos pacientes, fazemos as validações do peso e da altura, e após essas validações calculamos o IMC e o escrevemos na tabela. Ou seja, temos umas três funcionalidades dentro do mesmo bloco.

E essas funcionalidades, como o cálculo do IMC, é uma funcionalidade que precisamos em outro lugar do nosso código, lá no form.js. Afinal, quando estamos adicionando um paciente na tabela através do formulário, ele atualmente não tem o seu IMC calculado e muito menos impresso na tabela.

Ou seja, estamos precisando calcular o IMC também no form.js, não só no código que atualmente está preso no calcula-imc.js. Logo, precisamos reaproveitar esse código. Reaproveitar o código seria podermos chamar dentro de form.js uma função que calcule o IMC, que recebe o peso e a altura por parâmetro:

// form.js

imcTd.textContent = calculaImc(peso, altura);
E essa função também poderá ser chamada em calcula-imc.js, reaproveitando assim a lógica de cálculo do IMC. Então vamos criá-la, e ela já retornará o IMC com duas casas decimais:

// calcula-imc.js

function calculaImc(peso, altura) {
    var imc = 0;
    imc = peso / (altura * altura);

    return imc.toFixed(2);
}
E por fim, vamos chamá-la também em calcula-imc.js:

// calcula-imc.js

if (pesoEhValido && alturaEhValida) {
    var imc = calculaImc(peso, altura);
    tdImc.textContent = imc;
}
No form.js, já temos um peso e uma altura, então já conseguimos calcular o IMC, faltando apenas colocá-lo dentro da tr:

// form.js

pacienteTr.appendChild(nomeTd);
pacienteTr.appendChild(pesoTd);
pacienteTr.appendChild(alturaTd);
pacienteTr.appendChild(gorduraTd);
pacienteTr.appendChild(imcTd);
Agora, assim que adicionamos um paciente na tabela através do formulário, ele já vem com o seu IMC calculado e preenchido na tabela!

Então, conseguimos extrair a responsabilidade de calcular o IMC, que estava presa no calcula-imc.js, conseguindo assim fazer o reuso desse código. Logo, é uma boa prática extrairmos um código que queremos reusar em outros locais para funções externas.

Continuando com as melhorias e refatorações do nosso código, aplicando boas práticas, seria interessante quebrarmos o código do form.js em funções menores, já que temos uma função com várias responsabilidades, como capturar os valores do formulário, criar a tr e as tds do paciente, colocar os valores dentro das tds e por último colocar as tds dentro da tr e a tr dentro da tabela. Ou seja, há quatro funcionalidades em uma mesma função, o que dificulta um pouco a manutenção do código.
Então, quebrar o código em várias funções, além de deixá-lo mais organizado, também faz com que as responsabilidades sejam separadas, cada função com uma responsabilidade diferente.

Função para capturar os dados do formulário
A primeira coisa que podemos fazer é extrair a responsabilidade de capturar os dados do paciente do formulário para uma nova função. Ela receberá o formulário por parâmetro e extrairá os dados dele:

// form.js

function obtemPacienteDoFormulario(form) {
    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;
}
Esse código está pegando todos os valores e extraindo para variáveis. O nome, peso, altura e gordura, são características do paciente, certo? Se tudo isso é característica do paciente, logo eles pertencem a um mesmo paciente. Se tudo pertence a um mesmo paciente, ele poderia ser representado pela mesma coisa.

Objeto para representar um paciente
Quando falamos em representar um paciente, representado pela mesma coisa, estamos falando de objetos. Nas linguagens de programação, objetos representam coisas do mundo real, ou mesmo da programação, que têm características em comum.

Ao criar um paciente, sabemos que ele deve ter um nome, peso, altura e gordura. Então, para juntar todas as características em uma mesma variável, criamos um objeto em JavaScript. Para criar um objeto em JavaScript, utilizamos chaves ({}):

// form.js

function obtemPacienteDoFormulario(form) {

    var paciente = {

    }

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;
}
Dentro das chaves, passamos as suas propriedades, que nada mais são que as suas características. Para criar uma propriedade, passamos o seu nome e o seu valor, mas não com um igual e sim com dois pontos. Por exemplo, a propriedade nome:

function obtemPacienteDoFormulario(form) {

    var paciente = {
        nome: form.nome.value
    }

    var nome = form.nome.value;
    var peso = form.peso.value;
    var altura = form.altura.value;
    var gordura = form.gordura.value;
}
Assim, atribuímos à propriedade nome o valor extraído do formulário. Podemos fazer isso para as outras características do paciente, basta separar as propriedades por vírgula:

function obtemPacienteDoFormulario(form) {

    var paciente = {
        nome: form.nome.value,
        peso: form.peso.value,
        altura: form.altura.value,
        gordura: form.gordura.value
    }
}
Como IMC também é uma característica do paciente, vamos criar uma propriedade para tal. Seu valor será a função criada no vídeo anterior, passando o peso e a gordura do formulário por parâmetro:

function obtemPacienteDoFormulario(form) {

    var paciente = {
        nome: form.nome.value,
        peso: form.peso.value,
        altura: form.altura.value,
        gordura: form.gordura.value,
        imc: calculaImc(form.peso.value, form.altura.value)
    }
}
Por fim, a função retornará o objeto que contém todos os dados do paciente:

function obtemPacienteDoFormulario(form) {

    var paciente = {
        nome: form.nome.value,
        peso: form.peso.value,
        altura: form.altura.value,
        gordura: form.gordura.value,
        imc: calculaImc(form.peso.value, form.altura.value)
    }

    return paciente;
}
Se formos perceber, já estávamos utilizando o conceito de objeto antes. Por exemplo, quando selecionamos algo com o querySelector, que retorna um objeto baseado no que queremos. Esse objeto, ao invés de ter as propriedades nome, peso, etc, tem as propriedades textContent, ou value.

Assim, conseguimos representar o paciente através de um objeto e deixamos esse objeto disponível na função que escuta o evento de clique do botão:

var paciente = obtemPacienteDoFormulario(form);
Logo, já enxugamos um pouco a responsabilidade dessa função. Vamos continuar com esse processo no próximo vídeo.

Outra responsabilidade a ser extraída é a criação da tr e das tds do paciente. Então vamos criar uma função que receba um paciente por parâmetro, e a partir dos dados desse paciente ela monta a tr:
// form.js

function montaTr(paciente) {
    var pacienteTr = document.createElement("tr");

    return pacienteTr;
}
Assim que criamos a tr, devemos preenchê-la com as tds do paciente, então vamos mover o código que já fizemos para dentro da função, alterando somente os dados das tds, que agora virão do objeto paciente:

// form.js

function montaTr(paciente) {
    var pacienteTr = document.createElement("tr");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = paciente.nome;
    pesoTd.textContent = paciente.peso;
    alturaTd.textContent = paciente.altura;
    gorduraTd.textContent = paciente.gordura;
    imcTd.textContent = paciente.imc;

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);
    pacienteTr.appendChild(imcTd);

    return pacienteTr;
}
Por fim, chamamos essa função quando o botão for clicado:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

});
Agora temos um código muito mais legível.

Adicionando classes aos elementos
Ao inspecionar o HTML da nossa tabela, podemos ver que os pacientes que adicionamos através do formulário não possuem algumas características dos pacientes nativos. A tr do paciente nativo possui a classe paciente, assim como as tds, cada uma possui uma classe dizendo qual é a informação contida na td. Já os pacientes que adicionamos com o formulário não possuem classe nenhuma, tanto na tr quanto nas tds. Logo não estamos criando um paciente exatamente igual ao paciente nativo.

Então vamos alterar o código da função montaTr para criar um paciente com as suas devidas classes. Já sabemos como adicionar uma classe a um elemento, então vamos adicionar a classe paciente na tr:

// form.js

function montaTr(paciente) {
    var pacienteTr = document.createElement("tr");
    pacienteTr.classList.add("paciente");

    var nomeTd = document.createElement("td");
    var pesoTd = document.createElement("td");
    var alturaTd = document.createElement("td");
    var gorduraTd = document.createElement("td");
    var imcTd = document.createElement("td");

    nomeTd.textContent = paciente.nome;
    pesoTd.textContent = paciente.peso;
    alturaTd.textContent = paciente.altura;
    gorduraTd.textContent = paciente.gordura;
    imcTd.textContent = paciente.imc;

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);
    pacienteTr.appendChild(imcTd);

    return pacienteTr;
}
Falta agora adicionarmos as classes das tds, por exemplo:

var nomeTd = document.createElement("td");
nomeTd.classList.add("info-nome");
nomeTd.textContent = paciente.nome;
Temos que fazer esse código para todas as tds, criar o elemento, colocar a classe e colocar o valor.

Função para criar e montar uma td
Quando repetimos código, significa que podemos exportá-lo para uma função. Essa função criará a td, e adicionará a classe e o seu dado. Como a classe e o dado variam de acordo com a td, vamos recebê-los por parâmetro na função:

function montaTd(dado, classe) {
    var td = document.createElement("td");
    td.classList.add(classe);
    td.textContent = dado;

    return td;
}
Agora basta chamar essa função dentro de montaTr:

// form.js

function montaTr(paciente) {
    var pacienteTr = document.createElement("tr");
    pacienteTr.classList.add("paciente");

    var nomeTd = montaTd(paciente.nome, "info-nome");
    var pesoTd = montaTd(paciente.peso, "info-peso");
    var alturaTd = montaTd(paciente.altura, "info-altura");
    var gorduraTd = montaTd(paciente.gordura, "info-gordura");
    var imcTd = montaTd(paciente.imc, "info-imc");

    pacienteTr.appendChild(nomeTd);
    pacienteTr.appendChild(pesoTd);
    pacienteTr.appendChild(alturaTd);
    pacienteTr.appendChild(gorduraTd);
    pacienteTr.appendChild(imcTd);

    return pacienteTr;
}
Para simplificar, podemos chamar a função montaTd diretamente na função appendChild:

function montaTr(paciente) {
    var pacienteTr = document.createElement("tr");
    pacienteTr.classList.add("paciente");

    pacienteTr.appendChild(montaTd(paciente.nome, "info-nome"));
    pacienteTr.appendChild(montaTd(paciente.peso, "info-peso"));
    pacienteTr.appendChild(montaTd(paciente.altura, "info-altura"));
    pacienteTr.appendChild(montaTd(paciente.gordura, "info-gordura"));
    pacienteTr.appendChild(montaTd(paciente.imc, "info-imc"));

    return pacienteTr;
}
Podemos adicionar o paciente através do formulário, e inspecionar o seu HTML. Agora a sua estrutura, inclusive as classes, está igual à estrutura de um paciente nativo.

Limpando o formulário após adicionar o paciente
Uma vez que adicionamos um paciente na tabela, os seus dados continuam no formulário. Podemos limpar esses dados, para não correr o risco de adicionarmos pacientes iguais.

Fazemos isso após adicionar o paciente na tabela. Limpamos os campos do formulário chamando a função reset do formulário:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();
});
Assim, quando um paciente é adicionado, os seus dados no formulário são apagados.


############### 6. Validação de Formulários ###############

O último capítulo foi dedicado à organização do nosso código, principalmente do código referente ao formulário.
Mas se formos no formulário, conseguimos adicionar pacientes com valores inválidos! Por exemplo um peso negativo, ou altura de 10 metros. Nós atualmente só estamos validando os pacientes nativos, aqueles que já estão no HTML. O ideal é reaproveitar o código de validação, para também validar os dados do formulário antes de adicionar o paciente na tabela. E se os dados forem inválidos, exibimos uma mensagem dizendo qual dado está inválido.

Funções para validar o peso e a altura do paciente
Como é uma validação dos dados formulário, devemos fazê-la no form.js. Nós queremos fazer a validação do paciente antes de adicioná-lo na tabela, então vamos criar uma função chamada validaPaciente, que recebe um paciente por parâmetro, com essa responsabilidade, e chamá-la antes de adicionar o paciente no formulário:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    validaPaciente(paciente);

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();

});
O paciente já chegará para a função com todos os seus dados preenchidos, pois a função obtemPacienteDoFormulario já irá criar um paciente com os dados que obtiver do formulário. Então, dentro da função vamos validar a altura e o peso, mas já fizemos isso em outra parte do código, certo? Dentro do calcula-imc.js já fizemos uma validação semelhante! Então vamos reaproveitar essa lógica, até porque se caso precisemos mudá-la, mudamos em apenas um local.

Então, em calcula-imc.js, vamos criar a função validaPeso, que receberá um peso por parâmetro e retornará true se o peso estiver entre 0 e 1000, se não estiver o retorno será false:

// calcula-imc.js

function validaPeso(peso) {

    if (peso >= 0 && peso <= 1000) {
        return true;
    } else {
        return false;
    }
}
Do mesmo jeito vamos criar a função validaAltura:

// calcula-imc.js

function validaAltura(altura) {

    if (altura >= 0 && altura <= 3.00) {
        return true;
    } else {
        return false;
    }
}
Agora, ao invés de inicializarmos as variáveis pesoEhValido e alturaEhValida com true, vamos chamar as suas respectivas funções, que retornarão se os dados são ou não válidos:

// calcula-imc.js

var pesoEhValido = validaPeso(peso);
var alturaEhValida = validaAltura(altura);
E na hora de testar, vamos utilizar as variáveis também. Só que estamos testando se o peso ou a altura não são válidos. Então vamos utilizar o operador de negação (representado por um ponto de exclamação) à frente da variável:

// calcula-imc.js

if (!pesoEhValido) {
    console.log("Peso inválido!");
    pesoEhValido = false;
    tdImc.textContent = "Peso inválido";
    paciente.classList.add("paciente-invalido");
}

if (!alturaEhValida) {
    console.log("Altura inválida!");
    alturaEhValida = false;
    tdImc.textContent = "Altura inválida";
    paciente.classList.add("paciente-invalido");
}
Agora, com essas duas funções criadas, podemos chamá-las na função validaPaciente, em form.js.

Implementando a função de validação do paciente
Em form.js, na função validaPaciente, podemos testar se o peso e a altura são válidos, utilizando as funções que acabamos de criar. Por enquanto vamos fazer somente com o peso, para garantir que a lógica está funcionando:

// form.js

function validaPaciente(paciente) {
    if (validaPeso(paciente.peso)) {
        return true;
    } else {
        return false;
    }
}
E na hora de chamar a função, vamos fazer uma condição, já que se o paciente for inválido vamos imprimir uma mensagem de aviso no console, por enquanto:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    if (!validaPaciente(paciente)) {
        console.log("Paciente inválido");
    }

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();

});
Só que além disso, caso o paciente for inválido, queremos que o mesmo não seja adicionado na tabela. Então devemos sair da função se a condição do if for válida. O que podemos fazer é que se o código entrar no if, além de mostrar a mensagem, podemos retornar a função:

// form.js

if (!validaPaciente(paciente)) {
    console.log("Paciente inválido");
    return;
}
Um return vazio faz com que saiamos imediatamente da função, sem executar nenhum código que esteja abaixo dele, justamente o código que adiciona o paciente na tabela.

Agora podemos tentar cadastrar um paciente com um peso inválido. Ao clicar em Adicionar, o mesmo não é adicionado na tabela! Ao abrir o console, podemos ver a mensagem dizendo que o paciente é inválido.

Então resolvemos o problema do peso, só que mais interessante do que mostrar uma mensagem no console, seria mostrar uma mensagem no HTML dizendo qual problema está ocorrendo, para deixar bem claro para o usuário. E é isso que faremos no próximo vídeo, além de também validar a altura do paciente :)


Além de não adicionar um paciente inválido na tabela, vamos mostrar uma mensagem para o usuário falando qual foi o problema que deu na hora de adicionar o paciente.

Então, no código da função validaPaciente, ao invés de retornarmos verdadeiro ou falso, podemos retornar uma mensagem de erro se a validação for negativa:

// form.js

function validaPaciente(paciente) {

    if (validaPeso(paciente.peso)) {
        return "";
    } else {
        return "Peso é inválido";
    }
}
E na hora de chamar a função, de validar o paciente, extraímos a chamada da função para uma variável. E se houver algum erro, haverá uma string dentro dessa variável, ou seja, seu tamanho será maior que 0. E é isso que iremos testar na hora de exibir a mensagem no console:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    var erro = validaPaciente(paciente);

    if (erro.length > 0) {
        console.log("Paciente inválido");
        return;
    }

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();

});
Só que ao invés de exibirmos uma mensagem no console, vamos exibi-la no HTML. Então vamos criar um <span> na página index.html, antes do formulário:

<section class="container">
    <h2 id="titulo-form">Adicionar novo paciente</h2>
    <span id="mensagem-erro"></span>
    <form id="form-adiciona">
        <!-- formulário omitido -->
    </form>
</section>
Agora, no JavaScript, selecionamos o span e adicionamos uma mensagem nele:

if (erro.length > 0) {
    var mensagemErro = document.querySelector("#mensagem-erro");
    mensagemErro.textContent = erro;
    return;
}
Para ficar bem claro que é uma mensagem de erro, vamos deixar a frase na cor vermelha. Então, no index.css, adicionamos:

#mensagem-erro {
    color: red;
}
Agora podemos testar e ver que a mensagem está sendo exibida corretamente.

Validando a altura
Por enquanto só estamos validando o peso, então vamos validar a altura também:

// form.js

function validaPaciente(paciente) {

    if (validaPeso(paciente.peso)) {
        return "";
    } else {
        return "Peso é inválido";
    }

    if (validaAltura(paciente.altura)) {
        return "";
    } else {
        return "Altura é inválida";
    }

}
Só que a função só irá retornar uma coisa, e não duas strings concatenadas. Ou ela retorna que o peso é inválido, ou que a altura é inválida. Então o que podemos fazer, ao invés de retornar uma única string, é retornar um array de strings.

Retornando mais de uma mensagem de erro
Na hora em que estivermos fazendo as validações, em vez de retornar uma única string, podemos adicioná-la em um array, previamente criado:

// form.js

function validaPaciente(paciente) {

    var erros = [];

    // restante do código

}
E se o peso não for válido, ou seja, utilizaremos novamente o operador de negação, adicionamos a mensagem de erro no array utilizando a função push. Faremos a mesma coisa para a altura. Ao final da função, retornamos o array:

function validaPaciente(paciente) {

    var erros = [];

    if (!validaPeso(paciente.peso)) {
        erros.push("Peso é inválido");
    }

    if (!validaAltura(paciente.altura)) {
        erros.push("Altura é inválida");
    }

    return erros;
}
Falta agora exibir todas essas mensagens para o usuário. Como podemos fazer isso? A cada mensagem de erro, criamos um novo <span>? O que seria mais interessante é termos uma lista no HTML, e para cada erro nós adicionamos um item nessa lista. Então, no index.html, vamos trocar o <span> por uma <ul>, e vamos alterar o seu id também:

<section class="container">
    <h2 id="titulo-form">Adicionar novo paciente</h2>
    <ul id="mensagens-erro"></ul>
    <form id="form-adiciona">
        <!-- formulário omitido -->
    </form>
</section>
Agora, no próximo vídeo, veremos exibir todas essas mensagens para o usuário :)

Para cada erro no array, devemos criar uma <li>, alterar o seu conteúdo para a string de erro, e adicioná-la na <ul>. Como é uma responsabilidade diferente, vamos extrair essa lógica de exibição das mensagens de erro para uma função, então ela irá receber o array por parâmetro:

// form.js

function exibeMensagensDeErro(erros) {

}
A primeira coisa que devemos fazer é selecionar a ul e guardá-la em uma variável:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");
}
Agora precisamos percorrer o array, e para cada item, criamos uma li. Já vimos como fazer isso utilizando o for, mas há um outro jeito de se fazer isso, com o forEach:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");

    erros.forEach();
}
Ele funciona da seguinte maneira, para cada item do array, nós fazemos alguma coisa. "Fazer alguma coisa", como já sabemos, geralmente é uma função:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");

    erros.forEach(function() {

    });
}
Para cada item, queremos primeiramente criar uma li, então:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");

    erros.forEach(function() {
        var li = document.createElement("li");
    });
}
E dentro dessa li, no conteúdo dela, colocamos o item do array, mas como temos acesso a ele? Recebemos ele por parâmetro na função:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");

    erros.forEach(function(erro) {
        var li = document.createElement("li");
    });
}
Poderia ser qualquer nome, o importante é saber que ele representa o item de iteração do array.

Agora podemos adicionar esse erro no conteúdo da li, e adicionar a li como filha da ul:

// form.js

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");

    erros.forEach(function(erro) {
        var li = document.createElement("li");
        li.textContent = erro;
        ul.appendChild(li);
    });
}
Por fim, vamos chamar essa função:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    var erros = validaPaciente(paciente);

    if (erros.length > 0) {
        exibeMensagensDeErro(erros);
        return;
    }

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();

});
E alterar o CSS no index.css, já que agora o id da ul é mensagens-erro e não mais mensagem-erro:

#mensagens-erro {
    color: red;
}
Agora, ao adicionar um paciente com um peso inválido, ou uma altura, as mensagens são exibidas para o usuário!

Validando os campos em branco
Por enquanto só estamos validando o peso e a altura. Então, nada nos impede de adicionar um paciente sem nome, ou sem gordura. O ideal é, na hora de validar o paciente, verificar se há algum campo em branco.

Para verificar se um campo está em branco, podemos verificar o seu tamanho, se ele for 0, significa que o campo não foi preenchido. Por exemplo, o nome do paciente:

function validaPaciente(paciente) {

    var erros = [];

    if (paciente.nome.length == 0) {
        erros.push("O nome não pode ser em branco");
    }

    if (!validaPeso(paciente.peso)) {
        erros.push("Peso é inválido");
    }

    if (!validaAltura(paciente.altura)) {
        erros.push("Altura é inválida");
    }

    return erros;
}
Com isso, podemos validar o restante dos campos:

function validaPaciente(paciente) {

    var erros = [];

    if (paciente.nome.length == 0) {
        erros.push("O nome não pode ser em branco");
    }

    if (paciente.gordura.length == 0) {
        erros.push("A gordura não pode ser em branco");
    }

    if (paciente.peso.length == 0) {
        erros.push("O peso não pode ser em branco");
    }

    if (paciente.altura.length == 0) {
        erros.push("A altura não pode ser em branco");
    }

    if (!validaPeso(paciente.peso)) {
        erros.push("Peso é inválido");
    }

    if (!validaAltura(paciente.altura)) {
        erros.push("Altura é inválida");
    }

    return erros;
}
Agora não conseguimos mais adicionar pacientes com algum dado em branco.

Limpando as mensagens de erro
Ao tentar adicionar um paciente com algum dado inválido, a mensagem é impressa. Mas se o dado é corrigido, e tentamos adicionar o paciente novamente na tabela, apesar de estar tudo correto, a mensagem continua na página, elas ficam se acumulando!

Então, o ideal é limpar a lista de mensagens, a ul, antes de exibir as mensagens de erro. Para esvaziar a ul, temos que remover todo o seu conteúdo HTML. Para isso, utilizamos a propriedade innerHTML, que nos permite controlar o HTML interno de um elemento. Vamos passar uma string vazia para a propriedade:

function exibeMensagensDeErro(erros) {
    var ul = document.querySelector("#mensagens-erro");
    ul.innerHTML = "";

    erros.forEach(function(erro) {
        var li = document.createElement("li");
        li.textContent = erro;
        ul.appendChild(li);
    });
}
Ou seja, toda vez que formos exibir as mensagens de erro, as anteriores são apagadas.

Vamos fazer a mesma coisa quando adicionamos um paciente na tabela. Após a adição, vamos limpar as mensagens:

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {
    event.preventDefault();

    var form = document.querySelector("#form-adiciona");

    var paciente = obtemPacienteDoFormulario(form);

    var pacienteTr = montaTr(paciente);

    var erros = validaPaciente(paciente);

    if (erros.length > 0) {
        exibeMensagensDeErro(erros);
        return;
    }

    var tabela = document.querySelector("#tabela-pacientes");

    tabela.appendChild(pacienteTr);

    form.reset();

    var mensagensErro = document.querySelector("#mensagens-erro");
    mensagensErro.innerHTML = "";

});
Agora as mensagens são limpas também quando adicionamos um paciente com sucesso.


############### 7. Remoção, Delegação e Animação ###############

Agora que já estamos validando totalmente os nossos pacientes, podemos nos concentrar em adicionar novas funcionalidades ao site da Aparecida.
Mas ela pode sem querer adicionar um paciente com algum dado errado, faltando alguma letra no nome, ou algum número no peso, por exemplo. O paciente passará pela validação, mas com os dados incorretos. E ela não consegue editar o paciente e nem removê-lo, para adicioná-lo novamente.

Então vamos implementar a opção de remoção de pacientes para a Aparecida. Ela pode ser feita através de um ícone, ou para ser mais simples, através de um duplo clique! Ao clicar duas vezes em um paciente, o mesmo é removido.

Escutando o evento de duplo clique nas linhas
Se queremos colocar um evento de duplo clique nas linhas, devemos escutar esse evento para cada linha da tabela, então vamos fazer isso no JavaScript.

Como estamos criando uma funcionalidade nova, sem nada relacionado com o formulário ou com o cálculo de IMC, vamos então criar um novo arquivo dentro da pasta js, o remover-paciente.js. É nesse arquivo que ficará toda a lógica de remoção.

Antes de mais nada, vamos logo importar esse arquivo no index.html:

<script src="js/calcula-imc.js" ></script>
<script src="js/form.js" ></script>
<script src="js/remover-paciente.js" ></script>
Primeiramente, devemos selecionar as linhas. Todas elas possuem a classe paciente, então vamos selecioná-las:

var pacientes = document.querySelectorAll(".paciente");
Agora, para cada linha, para cada paciente, fazemos algo:

var pacientes = document.querySelectorAll(".paciente");

pacientes.forEach(function(paciente) {

});
E para cada paciente, adicionamos um escutador de eventos, para escutar o evento de duplo clique, o dblclick:

var pacientes = document.querySelectorAll(".paciente");

pacientes.forEach(function(paciente) {
    paciente.addEventListener("dblclick", function() {

    });
});
Agora falta sabermos como removemos um elemento do DOM, com JavaScript.

Removendo um elemento do HTML com JavaScript
A função do JavaScript responsável por remover um elemento do HTML é a função remove(). Então temos que chamar essa função no paciente que foi clicado.

Quem será clicado? O dono do evento, certo? O dono do evento é que sofrerá a ação de duplo clique e executará a função. Para acessar o dono do evento, a quem o evento está atrelado, utilizamos uma palavra reservada do JavaScript chamada this:

var pacientes = document.querySelectorAll(".paciente");

pacientes.forEach(function(paciente) {
    paciente.addEventListener("dblclick", function() {
        this.remove();
    });
});
O this é uma palavra de contexto ligada com quem acionou o evento, a quem o evento está atrelado. Como o evento está atrelado ao paciente, o this fará referência a ele.

Ao testar na página, e dar um duplo clique em um paciente nativo, o mesmo é removido! Então conseguimos implementar a remoção de um paciente de um jeito bem fácil.

Mas nem tudo é perfeito, e essa implementação tem um pequeno defeito. Ao adicionar um paciente pelo formulário, nós não conseguimos removê-lo. Isso porque o novo paciente não estava na página no momento em que o remover-paciente.js foi carregado (lembrando que o navegador abre a página e vai lendo o seu HTML, carregando os nossos scripts logo após).

Então, o script seleciona somente os pacientes que já estão na página. Ao adicionar um ou mais pacientes, eles não estão escutando o evento! No momento em que um paciente for adicionado, deveríamos colocá-lo para ouvir o evento e executar o mesmo código, mas aí estaríamos duplicando código, que já sabemos não ser uma boa prática.

Veremos no próximo vídeo um outro jeito de fazer a remoção do paciente, para remover os pacientes nativos e os que forem sendo adicionados depois da página ser carregada.

Para resolver o problema da remoção de pacientes, vamos nos aproveitar de uma característica do JavaScript, chamada Event Bubbling, ou "bolheamento" de eventos. Quando escutamos um evento no JavaScript, esse evento na verdade não acontece só no dono do evento (no nosso caso, na linha do paciente), ele acontece também no pai do paciente, no pai do pai do paciente, e vai subindo até o último pai.

Na nossa estrutura, ao dar um duplo clique na tr do paciente, o seu pai (tbody) também escuta o evento, e o pai do tbody (table) também, assim como os próximos pais, até chegar no body.

Podemos fazer uma analogia com um copo de refrigerante, já que quando colocamos o refrigerante em um copo, suas bolhas vão do fundo do copo até estourar na boca do copo. O evento seria como se fosse essa bolha.

Então vamos apagar o código antigo e fazer um teste. Primeiro selecionando o tbody:

var tabela = document.querySelector("#tabela-pacientes");
E vamos colocá-lo para escutar um evento de clique, imprimindo uma mensagem no console ao ser clicado:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("click", function() {
    console.log("Fui clicado");
});
Ao voltar para a página, veremos que independente de onde clicarmos no corpo da tabela, o evento será disparado, logo a mensagem será exibida no console! Ou seja, tanto faz se colocarmos o escutador de eventos em cada paciente ou no tbody, ele só precisa saber que teve um evento que aconteceu ali dentro.

Descobrindo o elemento clicado
Para não termos que ficar escutando o evento para cada linha da tabela, e para as linhas adicionadas através do formulário, vamos delegar essa responsabilidade de ficar escutando os eventos para o pai deles todos, o tbody:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function() {

});
Dentro da função, perguntamos ao pai qual filho foi clicado, porque é ele que será removido. Dessa vez não podemos utilizar o this, porque o dono do evento é a tabela, logo ela acabará sendo removida.

Para descobrir qual filho foi clicado, podemos utilizar novamente o event, então vamos recebê-lo como parâmetro na função:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {

});
O event pode responder essa nossa pergunta. Ele diz quem foi clicado, quem foi o alvo, através da propriedade target. E com o alvo em mãos, podemos deletá-lo:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    event.target.remove();
});
Mas se testarmos, podemos ver que isso "quase" funciona. Já que ao clicar em algum campo da tabela, a td que é removida, afinal ela que foi clicada. Mas queremos remover a linha toda, a tr, que é pai da td.

Acessando o pai de um elemento
Para selecionar o pai de um elemento, existe a propriedade parentNode. Então selecionaremos quem foi clicado, e removeremos o seu pai, que será uma tr:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    event.target.parentNode.remove();
});
Podemos até separar em variáveis para deixar mais claro:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    var alvoEvento = event.target;
    var paiDoAlvo = alvoEvento.parentNode;

    paiDoAlvo.remove();
});
Agora, mesmo que adicionemos mais pacientes através do formulário, no momento em que ele receber um duplo clique, o evento irá subir até chegar na tabela, que o estará escutando. Consequentemente, o paciente será removido.

Quando removemos um paciente, a linha some instantaneamente, abruptamente. Para melhorar a experiência do usuário, seria interessante que a linha vá sumindo aos poucos, gradualmente, que ela vá esmaecendo aos poucos, até seu total desaparecimento.
Então vamos realizar essa implementação, animando a remoção do paciente.

Transição com CSS
Já sabemos que, se queremos colocar um efeito visual, devemos mexer com o CSS. Então, no index.css, vamos adicionar uma classe chamada fadeOut:

.fadeOut {

}
E essa classe irá colocar a opacidade do elemento com 0, fazendo-o sumir:

.fadeOut {
    opacity: 0;
}
Só que ela fará isso de maneira gradual, com uma transição de meio segundo:

.fadeOut {
    opacity: 0;
    transition: 0.5s;
}
Agora, falta adicionarmos essa classe no paciente, utilizando o JavaScript.

Adicionando a classe e removendo a linha da tabela
No remover-paciente.js, comentamos a linha que remove o elemento com a função remove, e adicionamos a classe fadeOut ao elemento:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    event.target.parentNode.classList.add("fadeOut");
    //event.target.parentNode.remove();
});
Podemos agora testar, dar um duplo clique no elemento e ver ele sumindo aos poucos... Mas a linha continua na tabela! Isso porque só estamos mexendo no visual do elemento, o HTML continua lá. Então vamos descomentar a linha, removendo o elemento logo em seguida à adição da classe:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    event.target.parentNode.classList.add("fadeOut");
    event.target.parentNode.remove();
});
Mais uma vez testamos, damos um duplo clique e... Mais uma vez a linha some instantaneamente, como no início do vídeo. Porque?

Como o computador é muito rápido, o browser processa as linhas do script JavaScript instantaneamente. A classe é adicionada e logo em seguida o elemento é removido, por isso não conseguimos ver a transição acontecendo.

Logo, só devemos remover a linha da tabela após a transição ser terminada. Devemos pedir para o JavaScript aguardar meio segundo (tempo que colocamos para a transição ocorrer) e só após isso removemos a linha.

Aguardando a execução de uma função por um tempo determinado
A função do JavaScript que utilizamos quando queremos aguardar um tempo é a setTimeOut. Para ela, passamos por parâmetro o que deve ser executado (uma função) e quanto tempo deve ser aguardado:

var tabela = document.querySelector("#tabela-pacientes");

tabela.addEventListener("dblclick", function(event) {
    event.target.parentNode.classList.add("fadeOut");

    setTimeout(function() {
        event.target.parentNode.remove();
    }, 500);

});
Logo, a função setTimeOut acima irá segurar a execução da função passada por parâmetro para ela, pelo tempo de 500 milissegundos, equivalente a meio segundo.

Fazendo o teste novamente, mais uma vez damos um duplo clique em uma linha, a transição ocorre e após meio segundo a linha é removida!

Agora que a Aparecida consegue adicionar pacientes, e também removê-los, seria interessante que disponibilizássemos para ela um campo de busca por nome, para filtrar os pacientes listados. Já que a tendência é a lista de pacientes aumentar cada vez mais, tornando assim a localização de um ou mais pacientes em específico bem difícil. Então vamos ver como implementar uma busca em uma tabela, utilizando JavaScript.
Adicionando o campo de busca
A primeira coisa que devemos fazer é adicionar uma label e um input no index.html, que será onde o nome do paciente a ser buscado será digitado. Adicionamos acima da tabela:

<section class="container">
    <h2>Meus pacientes</h2>
    <label for="filtrar-tabela">Filtre:</label>
    <input type="text" name="filtro" id="filtrar-tabela" placeholder="Digite o nome do paciente">
    <table>
        <!-- conteúdo da tabela omitido -->    
    </table>
</section>
E para melhorar o seu estilo, adicionamos o seguinte código no index.css:

#filtrar-tabela {
    width: 200px;
    height: 35px;
    margin-bottom: 10px;
}
Agora, conforme o nome for digitado no campo, a ideia é que os pacientes que correspondam com o nome sejam mostrados. Por exemplo, ao digitar Doug, o paciente Douglas deverá ser exibido.

Acessando o conteúdo digitado no campo de filtragem
Resta agora implementarmos o código JavaScript que realizará essa filtragem. Vamos então criar o arquivo filtra.js, dentro da pasta js. Como é um novo arquivo, vamos importá-lo em index.html:

<script src="js/calcula-imc.js" ></script>
<script src="js/form.js" ></script>
<script src="js/remover-paciente.js" ></script>
<script src="js/filtra.js" ></script>
Devemos pegar o conteúdo de texto que está sendo digitado no campo de busca. Só que quando queremos filtrar? Queremos digitar conforme o usuário vá digitando, a cada letra digitada. Ou seja, queremos detectar o evento de digitar, conhecido como input. Toda vez que alguém inserir dados no campo, esse evento é disparado.

Primeiramente, devemos selecionar o campo de texto:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");
Com o campo em mãos, podemos escutar o evento input:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {

});
A cada letra que inserimos, a função é chamada. A cada vez que digitarmos, devemos pegar o value do campo, e filtrar a tabela. Podemos utilizar campoFiltro.value dentro da função, mas campoFiltro é o dono do evento, certo? Então podemos utilizar a palavra de contexto this, que é referente ao próprio dono do evento.

Agora, conforme o nome for sendo digitado, podemos ir comparando com os nomes de todos os pacientes da tabela. Os que forem iguais, nós mostramos, e os que forem diferentes, nós escondemos. Vamos então selecionar todos os pacientes:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");
});
Só que queremos comparar com o nome dos pacientes, não com a tr. Precisamos então iterar sobre os pacientes, para acessar o nome de cada um:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    for (var i = 0; i < pacientes.length; i++) {

    }
});
Agora selecionamos o paciente, e dele selecionamos a td com a classe info-nome. Dela extrairemos o nome do paciente:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    for (var i = 0; i < pacientes.length; i++) {
        var paciente = pacientes[i];
        var tdNome = paciente.querySelector(".info-nome");
        var nome = tdNome.textContent;
    }
});
Agora temos acesso ao nome de todos os pacientes da tabela, e também ao conteúdo de texto do campo de filtragem, só precisamos esconder todos os pacientes que são diferentes do conteúdo de texto, e mostrar os que são iguais.

Veremos como fazer isso no próximo vídeo :)

Queremos esconder tudo o que for diferente do valor do campo de texto e mostrar tudo o que for igual. Quando nós quisermos deixar um paciente com fundo vermelho, adicionamos uma classe no mesmo e no CSS definimos a cor de fundo dos elementos com essa classe. Fizemos a mesma coisa para sumir com o paciente, quando o mesmo for removido, adicionamos uma classe e no CSS adicionamos o estilo.
Faremos o mesmo para esconder os pacientes, se o nome for diferente do conteúdo de texto, adicionaremos uma classe. Se não for, ou seja, se o nome for igual ao que foi digitado, removemos a classe:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    for (var i = 0; i < pacientes.length; i++) {
        var paciente = pacientes[i];
        var tdNome = paciente.querySelector(".info-nome");
        var nome = tdNome.textContent;

        if (nome != this.value) {
            paciente.classList.add("invisivel");
        } else {
            paciente.classList.remove("invisivel");
        }
    }
});
E no index.css, sumimos com o elemento que tiver a classe invisivel:

.invisivel {
    display: none;
}
Vamos testar agora. Ao digitar Douglas, somente o paciente Douglas é exibido! Mas ao apagar o que digitamos, os pacientes não voltam! Isso porque todos os pacientes estão com a classe invisivel, ou seja, só deveríamos colocar a classe invisivel quando há algum conteúdo no campo, algo digitado.

Então só vamos colocar a classe invisivel se houver algo digitado. Vemos se há algo digitado ou não através do seu length, se ele for 0, significa que o campo está em branco, mas se for maior que 0, significa que há algo digitado:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    if (this.value.length > 0) {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            var tdNome = paciente.querySelector(".info-nome");
            var nome = tdNome.textContent;

            if (nome != this.value) {
                paciente.classList.add("invisivel");
            } else {
                paciente.classList.remove("invisivel");
            }
        }
    }
});
Mas se não houver nada digitado, nós percorremos todos os pacientes e removemos a classe:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    if (this.value.length > 0) {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            var tdNome = paciente.querySelector(".info-nome");
            var nome = tdNome.textContent;

            if (nome != this.value) {
                paciente.classList.add("invisivel");
            } else {
                paciente.classList.remove("invisivel");
            }
        }
    } else {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            paciente.classList.remove("invisivel");
        }
    }
});
Agora, quando filtramos os pacientes, e apagamos o conteúdo do campo de texto, todos os pacientes voltam a ser exibidos!

Estamos com uma busca funcional, mas ela só busca pelo nome inteiro do paciente. Para ficar mais interessante, podemos realizar uma busca letra a letra. Por exemplo, ao digitar a letra P, todos os pacientes que começam com P seriam exibidos, como Pedro, Paulo e Pablo. Ao adicionar um a, ficando Pa, somente os pacientes Paulo e Pablo seriam exibidos. E conforme fomos colocando as letras, a filtragem iria sendo feita.
Para buscar texto em uma outra palavra, as linguagens de programação já possuem uma solução, e isso não é diferente com o JavaScript. Essa solução é a expressão regular.

As expressões regulares nada mais são do que um tipo especial de texto, que nos auxilia em fazer uma busca textual em um texto maior. Pode ser uma busca simples, como a nossa, se a palavra Paulo contém a palavra Pa, por exemplo; ou uma busca mais complexa, se um parágrafo contém a palavra nome, por exemplo, mais ou menos o que os editores de texto utilizam quando queremos buscar por uma palavra, com o famoso CTRL + F.

Criando expressões regulares no JavaScript
Para criar expressões regulares no JavaScript é bem fácil, criamos uma variável e dentro dela colocamos uma expressão regular, que é um objeto especial do JavaScript. Criamos esse objeto com um new e o seu nome, RegExp

var expressao = new RegExp();
Para o objeto, podemos passar dois parâmetros. O primeiro é o texto que queremos buscar, no nosso caso o que está sendo digitado, logo this.value. O segundo é como que queremos que a expressão regular busque, relativo a algumas características suas, mas o importante para nós é que não queremos case-sensitive, que é a diferenciação entre letras maiúsculas e minúsculas. Para buscar tanto letras maiúsculas, quanto minúsculas, passamos a letra i como segundo parâmetro:

var expressao = new RegExp(this.value, "i");
Mas como utilizamos a expressão regular para buscar no nome do paciente o texto que queremos?

Buscando com expressões regulares
Para usar, ao invés de compararmos com o nome inteiro do paciente (como estávamos fazendo), vamos pedir para a expressão regular testar para ver se o nome do paciente possui um pedaço do que foi digitado no campo de busca. Para isso, a expressão regular tem o método test, onde nós passamos para ela o que queremos testar:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    if (this.value.length > 0) {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            var tdNome = paciente.querySelector(".info-nome");
            var nome = tdNome.textContent;
            var expressao = new RegExp(this.value, "i"); 

            if (expressao.test(nome)) {
                paciente.classList.add("invisivel");
            } else {
                paciente.classList.remove("invisivel");
            }
        }
    } else {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            paciente.classList.remove("invisivel");
        }
    }
});
Esse teste irá retornar verdadeiro, caso o nome contenha a expressão, ou falso, caso não contenha. Como estamos testando se o nome não contém a expressão (por isso adicionamos a classe invisivel), precisamos utilizar novamente o operador de negação (!). Logo, se o teste falhar, adicionamos a classe, se não, removemos a classe:

// filtra.js

var campoFiltro = document.querySelector("#filtrar-tabela");

campoFiltro.addEventListener("input", function() {
    var pacientes = document.querySelectorAll(".paciente");

    if (this.value.length > 0) {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            var tdNome = paciente.querySelector(".info-nome");
            var nome = tdNome.textContent;
            var expressao = new RegExp(this.value, "i"); 

            if (!expressao.test(nome)) {
                paciente.classList.add("invisivel");
            } else {
                paciente.classList.remove("invisivel");
            }
        }
    } else {
        for (var i = 0; i < pacientes.length; i++) {
            var paciente = pacientes[i];
            paciente.classList.remove("invisivel");
        }
    }
});
Agora a filtragem é feita letra a letra. Conseguimos deixá-la um pouco mais dinâmica.

Para saber mais sobre expressões regulares, há um curso bem interessante aqui na Alura, o curso Expressões regulares: Capturando textos de forma mágica.

############### 9. AjaxBuscando pacientes com AJAX ###############

A última feature que vamos desenvolver no site da Aparecida é a capacidade dele se integrar a um outro sistema, que também contém pacientes. Esse sistema é um servidor, que funciona externamente ao nosso computador, que contém alguns pacientes, e que a Aparecida resolveu adotar no seu consultório, então ela quer trazer esses pacientes para que eles fiquem cadastrados no sistema dela, integrando assim os dois sistemas.
Acessando o sistema externo de pacientes
O sistema externo de pacientes pode ser acessado no navegador, através da URL https://api-pacientes.herokuapp.com/pacientes. Nele, há uma lista de pacientes que devem ser integrados ao sistema da Aparecida. No site da Aparecida, com o clique de um botão, esses pacientes serão importados, sendo incluídos na tabela.

Ou seja, ao clicar no botão, iremos buscar os dados dos pacientes no sistema externo e adicioná-los no site da Aparecida.

Adicionando um novo botão na página
A primeira coisa que devemos fazer é adicionar o botão na página index.html. É nele que clicaremos para buscar os pacientes externos. Adicionaremos esse botão abaixo da tabela:

<section class="container">
    <h2>Meus pacientes</h2>
    <label for="filtrar-tabela">Filtre:</label>
    <input type="text" name="filtro" id="filtrar-tabela" placeholder="Digite o nome do paciente">
    <table>
        <!-- conteúdo da tabela omitido -->
    </table>

    <button id="buscar-pacientes" class="botao bto-principal">Buscar Pacientes</button>

</section>
Se temos uma nova feature, vamos criar um novo arquivo JavaScript dentro da pasta js, ele será chamado de buscar-pacientes.js. Como temos um novo arquivo, vamos importá-lo na página index.html:

<script src="js/calcula-imc.js" ></script>
<script src="js/form.js" ></script>
<script src="js/remover-paciente.js" ></script>
<script src="js/filtra.js" ></script>
<script src="js/buscar-pacientes.js" ></script>
Se queremos buscar os pacientes ao clicar no botão, devemos selecioná-lo e escutar o seu evento de click:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {

});
No navegador, sabemos como acessar um endereço, podemos abrir uma nova aba, digitar o endereço e clicar ENTER. Ou seja, é o navegador que faz a requisição, ele vai até a URL e nos mostra os dados. Mas como faremos isso de dentro da nossa página?

Varemos como fazer uma requisição com JavaScript de modo que ele vá até a URL, busque os dados e nos traga de volta, sem depender do navegador.

Conhecendo a estrutura da API
No código JavaScript, devemos acessar o endereço https://api-pacientes.herokuapp.com/pacientes, buscar e trazer os seus dados, e colocá-los na tabela. Esse endereço é uma API, que nada mais é que uma interface de programação, que disponibiliza os dados para nós.

Não sabemos da onde vêm os dados, como e de que jeito eles foram gerados, eles já são disponibilizados prontos para usarmos, e isso é uma característica da uma API.

Ao analisar os dados, eles possuem uma estrutura que nós já conhecemos: cada paciente fica entre chaves, e dentro das chaves há itens formados por um par chave e valor. Ou seja, parece muito com um objeto JavaScript.

Além disso, todos os dados estão armazenados entre colchetes, característica de um array do JavaScript. Como os dados estão disponibilizados em uma estrutura que conhecemos, será bem fácil trazê-los para dentro do código JavaScript, só precisamos aprender como acessá-los, como realizar a requisição sem o navegador, somente com JavaScript.

Enviando uma requisição com JavaScript
Para fazer essa requisição, temos um objeto bastante conhecido do mundo JavaScript, o XMLHttpRequest:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();
});
O XMLHttpRequest é um objeto do JavaScript responsável por fazer requisições HTTP. Ele possui o XML no nome porque era utilizado para realizar o transporte de dados do tipo XML, mas hoje em dia ele consegue trafegar outros tipos de dados.

Só que para ele realizar as requisições, devemos ensiná-lo e configurá-lo para fazer as requisições do jeito que queremos. Faremos isso com alguns de seus métodos.

O primeiro deles, o método open, é onde diremos qual tipo de requisição queremos fazer (GET) e para onde. Passamos esses dois valores por parâmetro para ele:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");
});
Essa linha somente configura o endereço que será acessado, verifica se o mesmo está correto, existe, configurando a requisição. Para realizar a requisição em si, precisamos chamar o método send:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.send();
});
Podemos testar o nosso botão somente com esse código. Ao clicar nele, nada acontece. Porque?

Porque no nosso código atual, é como se o JavaScript estivesse abrindo uma nova aba no navegador, digitou o endereço e clicou ENTER. Mas ficou faltando a parte final, que é exibir os dados para nós.

Obtendo e exibindo a resposta da requisição
Para poder exibir os dados, depois que enviamos a requisição, devemos escutar um evento específico que é acionado quando a requisição termina, quando a sua resposta for carregada. Ao escutar esse evento, conseguiremos carregar essa resposta da requisição, justamente os nossos dados. Esse evento é o load, evento característico do XMLHttpRequest:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {

    });

    xhr.send();
});
E para acessar os dados da resposta, acessamos a propriedade responseText do XMLHttpRequest. Para testar, podemos guardá-la em uma variável imprimi-la no console do navegador:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {
        var resposta = xhr.responseText;
        console.log(resposta);
    });

    xhr.send();
});
Agora, ao clicar no botão, os dados são impressos no console! Ou seja, já estamos conseguindo trazer os dados de outro site para o mundo do JavaScript. Falta agora criar os pacientes com esses dados e exibi-los na tabela. Faremos no próximo vídeo :)

Já temos acesso aos dados da requisição, mas para conseguir trabalhar com eles precisamos passá-los para um formato mais palpável, já que a resposta vem como texto. Mas ele tem uma estrutura tão parecida com o objeto do JavaScript...
O formato de dados JSON
Os dados possuem uma estrutura parecida com o objeto do JavaScript porque eles estão no formato JSON (sigla de JavaScript Object Notation), que é um formato de dados (parecidos com os objetos do JavaScript) que podemos transportar pela web.

A semelhança é tanta, que podemos facilmente converter JSON, ou o texto da resposta da requisição, em objetos do JavaScript que estamos mais acostumados a utilizar! Podemos converter para uma string, um objeto puro em si, ou até mesmo um array, que é o que estamos interessados, que a resposta vire um array de objetos, de pacientes.

Convertendo JSON para um array de objetos
Para transformar a resposta que temos atualmente (uma string) em um array de pacientes, devemos usar um transformador, um parseador de JSON para objetos do JavaScript. E quem vai fazer isso é o objeto JSON, que possui um método chamado parse, que pode receber um texto em JSON, que será parseado e nos será retornado um objeto JavaScript. Como nossa resposta tem uma cara de array, o método entenderá isso e nos retornará um array do objetos:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {
        var resposta = xhr.responseText;
        var pacientes = JSON.parse(resposta);
    });

    xhr.send();
});
Agora que temos um array, sendo que cada item do array é um objeto que representa o paciente, basta iterar por eles e adicionar cada um na tabela.

Adicionando os pacientes na tabela
Já implementamos essa adição de pacientes na tabela, certo? Lá no form.js nós já fazemos isso, só que o código está preso ao escutador do evento click do botão Adicionar:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {

    event.preventDefault();

    var form = document.querySelector("#form-adiciona");
    var paciente = obtemPacienteDoFormulario(form);
    var pacienteTr = montaTr(paciente);

    var erros = validaPaciente(paciente);
    if (erros.length > 0) {
        exibeMensagensDeErro(erros);
        return;
    }

    var tabela = document.querySelector("#tabela-pacientes");
    tabela.appendChild(pacienteTr);

    form.reset();

    var mensagensErro = document.querySelector("#mensagens-erro");
    mensagensErro.innerHTML = "";

});
Vamos então reaproveitar esse código, criando a função adicionaPacienteNaTabela. Essa função receberá um paciente, montará a sua tr, selecionará a tabela e adicionará a tr como sua filha:

// form.js

function adicionaPacienteNaTabela(paciente) {
    var pacienteTr = montaTr(paciente);
    var tabela = document.querySelector("#tabela-pacientes");
    tabela.appendChild(pacienteTr);
}
Agora podemos chamar essa função no form.js:

// form.js

var botaoAdicionar = document.querySelector("#adicionar-paciente");
botaoAdicionar.addEventListener("click", function(event) {

    event.preventDefault();

    var form = document.querySelector("#form-adiciona");
    var paciente = obtemPacienteDoFormulario(form);

    var erros = validaPaciente(paciente);
    if (erros.length > 0) {
        exibeMensagensDeErro(erros);
        return;
    }

    // chamando a nova função adicionaPacienteNaTabela
    adicionaPacienteNaTabela(paciente);

    form.reset();

    var mensagensErro = document.querySelector("#mensagens-erro");
    mensagensErro.innerHTML = "";

});
E também no buscar-pacientes.js, basta iterar pelo array, e adicionar cada paciente contido nele, chamando a função que acabamos de criar:

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {
        var resposta = xhr.responseText;
        var pacientes = JSON.parse(resposta);

        pacientes.forEach(function(paciente) {
            adicionaPacienteNaTabela(paciente);
        });
    });

    xhr.send();
});
Podemos ver se está tudo funcionando. Ao abrir a página no navegador e clicar em Buscar Pacientes, a tabela é preenchida com todos os pacientes que estavam no servidor externo!

Essa técnica que fizemos nessa capítulo, é a técnica de fazer AJAX, de fazer uma requisição com JavaScript de forma assíncrona. Porque de forma assíncrona? Porque a requisição não está parando o fluxo do JavaScript, ou seja, no momento em que a requisição é feita, o nosso código JavaScript continua sendo executado normalmente, podemos excluir pacientes, adicionar, tudo isso enquanto estamos buscando os pacientes no servidor externo.

Já estamos conseguindo trazer os pacientes e adicioná-los na tabela, somente clicando em um botão, mas sabemos que na web, nem sempre todas as requisições que fazemos dão certo.
Muitas vezes, ao acessar um site, podemos receber um erro 404. Por exemplo, ao tentar acessar a Alura, através de uma URL que não existe (por exemplo https://www.alura.com.br/akcnadsinficaqof), recebemos o erro 404, porque essa URL não existe. Não existe somente esse erro, também existem os erros 201, 402, 503, etc... Vários erros que podem ocorrer quando fazemos uma requisição web.

Seria interessante, quando fizermos uma requisição com o JavaScript, detectar se acontece algum erro, e avisar isso ao usuário.

Para testar se uma requisição falhou ou não, devemos verificar o seu código HTTP. O código HTTP para uma requisição perfeita, quando deu tudo certo, é o código 200. Então, depois que carregar a requisição, podemos testar se o código é o 200, se não for significa que houve algum erro. Para saber o código da requisição, acessamos a propriedade status do XMLHttpRequest

// buscar-pacientes.js

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {

        if (xhr.status == 200) {
            var resposta = xhr.responseText;
            var pacientes = JSON.parse(resposta);

            pacientes.forEach(function(paciente) {
                adicionaPacienteNaTabela(paciente);
            });
        } else {
            console.log(xhr.status);
            console.log(xhr.responseText);
        }
    });

    xhr.send();
});
Com isso, o erro e a mensagem de resposta são exibidos no console, mas seria interessante deixar mais claro ao usuário que um erro ocorreu.

Mostrando a mensagem de erro para o usuário
Para exibir a mensagem de erro para o usuário, podemos adicionar um span no index.html, logo abaixo da tabela e acima do botão:

<main>
    <section class="container">
        <h2>Meus pacientes</h2>
        <label for="filtrar-tabela">Filtre:</label>
        <input type="text" name="filtro" id="filtrar-tabela" placeholder="Digite o nome do paciente">
        <table>
            <!-- conteúdo da tabela omitido -->
        </table>

        <span id="erro-ajax" class="invisivel">Erro ao buscar os pacientes</span>

        <button id="buscar-pacientes" class="botao bto-principal">Buscar Pacientes</button>

    </section>
</main>
Como o span possui a classe invisivel, por padrão ele não aparecerá na página. E no buscar-pacientes.js, selecionamos esse span, e se um erro ocorrer, removemos a classe invisivel, deixando assim a mensagem visível para o usuário:

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {
        var erroAjax = document.querySelector("#erro-ajax");

        if (xhr.status == 200) {
            var resposta = xhr.responseText;
            var pacientes = JSON.parse(resposta);

            pacientes.forEach(function(paciente) {
                adicionaPacienteNaTabela(paciente);
            });
        } else {
            erroAjax.classList.remove("invisivel");
        }
    });

    xhr.send();
});
Mas se a requisição ocorrer normalmente, sem erros, nós ocultamos a mensagem novamente, adicionando a classe invisivel:

var botaoAdicionar = document.querySelector("#buscar-pacientes");

botaoAdicionar.addEventListener("click", function() {
    var xhr = new XMLHttpRequest();

    xhr.open("GET", "https://api-pacientes.herokuapp.com/pacientes");

    xhr.addEventListener("load", function() {
        var erroAjax = document.querySelector("#erro-ajax");

        if (xhr.status == 200) {
            erroAjax.classList.add("invisivel");
            var resposta = xhr.responseText;
            var pacientes = JSON.parse(resposta);

            pacientes.forEach(function(paciente) {
                adicionaPacienteNaTabela(paciente);
            });
        } else {
            erroAjax.classList.remove("invisivel");
        }
    });

    xhr.send();
});
Ao testar, verificamos que se ocorrer tudo certo, nenhuma mensagem é exibida. Se alterarmos a URL para uma que não exista, a mensagem é apresentada para o usuário.





