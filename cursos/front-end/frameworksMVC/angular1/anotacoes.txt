##### 1. Testando seus conhecimentos #####

Quando desenvolvemos no server-side, organizamos nosso código em camadas para facilitar a manutenção, o reaproveitamento e a legibilidade de nosso código. É muito comum aplicarmos o modelo MVC (Model, View, Controller), que consiste na separação de tarefas, facilitando assim a reescrita de alguma parte e a manutenção do código.

Porém, não é raro o mesmo desenvolvedor deixar de lado essas práticas quando codifica no client-side. Mesmo aqueles que procuram organizar melhor seu código acabam criando soluções caseiras que nem sempre são bem documentadas.

Tendo como base este cenário, frameworks MVC client-side foram criados. Entre eles temos o Backbone, Ember, Knockout, CanJS, Batman, entre outros.

Angular, o framework MVC da Google
Um framework MVC no lado do cliente que tem ganhado muita atenção da comunidade é o Angular. Criado como um projeto interno da Google e liberado para o público em 2009, ele tem como foco a criação de Single Page Applications (SPA’s). Este tipo de aplicação não recarrega a página durante seu uso, dando uma experiência mais fluída para o usuário. Não se preocupe se você é novo para este tipo de aplicação, você terá a oportunidade de entender melhor seus conceitos ao longo do treinamento.

Conhecendo um pouco da nossa aplicação, o Alurapic
Durante o treinamento construiremos a aplicação Alurapic, um sistema simples de gerenciamento de imagens, permitindo que o usuário busque por aquelas que seguem determinado critério. Mas não se engane: o domínio do problema, apesar de simples, será suficiente para empregarmos grande parte do "arsenal" que o Angular nos fornece, inclusive toda aplicação funcionará em cima de um servidor web já preparado.

Preview da aplicação

Preview da aplicação

Preview da aplicação

Instalando e configurando toda infra necessária
Agora que você já conhece um pouco sobre a aplicação que construiremos, saiba que alguns recursos do Angular dependem de um servidor web para funcionarem, em nosso caso, um servidor local. A boa notícia é que já disponibilizamos um para você, livrando-o dos seus detalhes de configuração. Inclusive ele fará persistência de dados sem que você tenha que instalar um banco de dados específico para isso. Porém, para tudo funcionar, você precisa ter instalado o Node.js.

O arquivo do projeto, o tutorial de instalação do Node.js e as instruções de como levantar o servidor estão no primeiro exercício deste capítulo. Esta é uma boa hora de fazê-lo antes de continuar. Vamos assumir a partir deste ponto que você realizou este primeiro exercício.

Por onde começar?
Angular é um framework que roda no lado do cliente, sendo assim, como qualquer outro script, deve ser importado na página que desejamos eleger como principal da aplicação, em nosso caso, a página já existente, index.html, que está salva dentro da pasta alurapic/public (não sabe que pasta é essa? Você fez o primeiro exercício do capítulo conforme solicitado?). Primeiramente vamos dar uma olhada em sua estrutura:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que a página já importa o CSS do Bootstrap. Se você ainda não o conhece, fique sabendo que ele permite aplicar um visual profissional em nosso projeto, com zero de esforço, apenas adicionando classes declaradas em seu arquivo CSS. Que classes são essas? Muita calma nessa hora! Elas serão introduzidas à medida que formos evoluindo nossa aplicação, mas já podemos adiantar que a classe container centraliza todo conteúdo da página e a text-center centraliza um elemento do tipo block, em nosso caso, a tag h1.

Agora que você já entendeu o papel do Bootstrap em nosso projeto, já podemos continuar. Todas as páginas, bibliotecas, scripts e qualquer outro arquivo dentro da pasta alurapic/public serão acessíveis através do seu navegador, inclusive já temos dentro da pasta alurapic/public/js/lib todos os arquivos do Angular que importaremos à medida que formos precisando. Vamos importar o script angular.min.js, o core do Angular dentro da tag head:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, mas ainda não escrevemos um código que utiliza o Angular! Para fazermos isso, primeiro precisamos criar um módulo.

Criando o alicerce da nossa aplicação, o módulo principal
A história é a seguinte: o framework nos ajuda a separar nosso código em pequenos grupos de código que podem ser combinados e reaproveitados quando necessário, esses grupos são chamados de módulos. Uma aplicação pode ter um, dez ou até mesmo mais de cinquenta módulos, tudo dependerá da complexidade da aplicação. Porém, há sempre um módulo que é o primeiro a ser inicializado assim que sua página é carregada pela primeira vez, inclusive ele também é o responsável pelo carregamento de outros módulos de que sua aplicação precisa para funcionar. É este que criaremos agora!

Vamos criar o arquivo public/js/main.js e mesmo sem escrever qualquer linha de código, vamos importá-lo sem demora na página index.html, abaixo da importação do core do Angular, para não corrermos o risco de esquecermos de importá-lo:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, e agora? Como criamos nosso módulo? Bem, o Angular disponibiliza para nós no escopo global o objeto angular (nada criativo, não?) que possui uma série de funções que nos permite interagir com o framework, entre elas a função module responsável pela criação de módulos.

Você deve estar pensando "Ok, entendi que é através desse objeto global que eu crio módulos e um monte de coisas do framework, mas escopo global não é algo ruim?". Preocupação justa, mas não se preocupe! Em uma aplicação bem-feita em Angular, este é o único objeto disponível globalmente, todo restante fica confinado dentro dos módulos do Angular! Com o tempo isso ficará ainda mais claro para você.

Criando o módulo principal da aplicação:

// public/js/main.js

angular.module('alurapic', []);
Acabamos de criar nosso primeiro módulo. Perceba que a função module recebe dois parâmetros. O primeiro é o nome do módulo que desejamos criar e o segundo é uma array com todos os módulos de que nosso módulo depende. Como não avançamos ainda com o projeto, não temos nenhuma dependência ainda, porém, você não deve omitir este parâmetro. Mais tarde você entenderá o que acontece quando ele é omitido (suspense!).

Ensinando um truque novo para o navegador
Tudo certo, criamos nosso módulo, mas como o Angular saberá que deve carregá-lo? Será que importar o script public/js/main.js é suficiente? Com certeza não.

Precisamos indicar em nossa página qual será o escopo de atuação do Angular, isto é, se ele gerenciará a página inteira ou apenas parte dela. Isso é importante, porque outro framework MVC pode estar sendo utilizado (algo raro, porém pode acontecer) e não queremos que o Angular bagunce seu trabalho.

Como apenas utilizaremos o Angular, gerenciaremos a página inteira, isto, a tag html e todos seus elementos filhos! Tudo bem, mas como faremos essa associação? Através do atributo ng-app:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que o atributo ng-app tem como valor o nome do nosso módulo e não poderia ser diferente. Quando nossa página é carregada pela primeira vez o Angular encontrará esse atributo e carregará o módulo alurapic, tudo isso automaticamente, sem termos que nos preocupar em carregá-lo! É claro que se você esquecer de importar o arquivo main.js o Angular não será capaz de carregar o módulo, certo?

Ah, então isso é uma diretiva?
Agora, só uma coisa antes de continuarmos: o atributo ng-app existe no mundo HTML? Com certeza não, ele não faz parte da especificação da W3C. O "atributo" ng-app é na verdade uma diretiva do Angular.

Diretivas ampliam o vocabulário do navegador, ensinando-o novos truques, inclusive aprenderemos a criar nossas próprias diretivas ao longo do treinamento! Nesse caso a diretiva ng-app fornece a capacidade de nossa página carregar/iniciar o módulo principal da aplicação. Aliás, não vamos mais usar o termo página, usaremos view, termo mais correto quando estamos no universo do Angular!

Nossa primeira página dinâmica
Legal, agora, com o servidor iniciado (não lembra como iniciá-lo? Veja o primeiro exercício do capítulo) vamos acessar o endereço http://localhost:3000 e verificar o resultado. Como esperado, nada impressionante, pois apenas preparamos a infraestrutura mínima de uma aplicação em Angular, que nada faz. No máximo, podemos ver através do console do navegador (eu uso Chrome, e você?) todos os arquivos carregados:

arquivos carregados

Bom, vamos começar a dar um colorido para nossa view index.html. Vamos adicionar uma foto, você pode escolher a URL de uma específica, não precisa ser igual a minha. Na tag img, utilizaremos as classes img-responsive center-block para que ela escale corretamente nos mais diversos dispositivos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
        </div><!-- fim container -->
    </body>
</html>
imagem de animal

Bravo! Mas isso não impressiona, além do mais, se tivéssemos 100 imagens teríamos que repetir a tag img 100 vezes! Em nossa aplicação aprenderemos a cadastrar informações de imagens e a partir desses dados cadastrados montaremos dinamicamente uma lista de imagens! Só que antes de pensar em integração com o back-end, precisamos primeiro entender como o Angular fornece dados para a nossa view e como ela se constrói a partir desses dados.

Vamos realizar uma pequena mudança na tag img, alterando os atributos src e alt:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
A primeira coisa é entender que abrimos lacunas em nossa view index.html através da sintaxe {{ }}. Se temos uma view que agora possui lacunas, podemos chamá-la de template. Quando alguém envia um memorando para outra, raramente ela começa do zero, ou seja, ela adota um template, toda uma estrutura já pronta e seu único trabalho é preencher essas lacunas que variam de acordo com a situação. Isso se aplica no mundo Angular! O que acontece se visualizarmos nossa página agora? Nenhuma imagem será exibida e nenhum erro ocorrerá! Aliás, o termo lacuna é muito genérico, no mundo Angular usamos Angular Expression (AE). Todo {{ }} que encontrarmos chamaremos de AE. Combinado?

Quando temos um template que precisa de algum dado através de uma AE e não encontra, simplesmente aquela expressão fica em branco. Agora, a pergunta que não quer calar: quem, no modelo MVC é o responsável em disponibilizar dados para a views? Se você respondeu controller acertou!

Nosso primeiro controller
Precisamos criar um controller que disponibilize para a view o dado que ela precisa, no caso um objeto que contenha como chave o título e o endereço de uma foto, por exemplo { titulo: 'Leão', url : 'http://www.fundosanimais.com/Minis/leoes.jpg'}.

Lembra do nosso módulo principal da aplicação? Podemos criar um ou mais controllers diretamente nele, porém é uma boa prática declarar cada controller em arquivos separados, mesmo que eles façam parte do módulo alurapic. Vamos criar dentro de public/js/controllers/fotos-controller.js.

Criando nosso controller:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {
  // definição do controller aqui 
});
Veja que chamamos novamente angular.module, só que dessa vez sem passar o segundo parâmetro, o array vazio. Quando fazemos isso, indicamos que queremos acessar o módulo e não criar um novo. Faz todo sentido, se queremos que nosso controller faça parte do módulo alurapic. Em seguida encadeamos uma chamada à função controller que recebe dois parâmetros. O primeiro é o nome do controller que estamos criando na convenção PascalCase, o segundo uma função que define o controller.

Sabemos que o controller deve fornecer o objeto foto para a view e que esse objeto deve conter as chaves titulo e url. Faremos isso agora!

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {

    var foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Excelente, agora precisamos importar o novo arquivo js que acabamos de criar em nossa view principal index.html:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que isso é suficiente? Não, precisamos indicar dentro da nossa view index.html qual fragmento será gerenciado pelo nosso controller. Angular permite associarmos diferentes controllers para diferentes partes de nossa view, uma maneira de separar responsabilidades. Porém, neste exemplo, queremos que o controller gerencie a tag body e todos os seus elementos filhos e fazemos isso através da diretiva ng-controller, que deve ter como valor o nome exato do controller que criamos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que funciona? Visualizando no navegador, a imagem não é exibida e também não temos uma mensagem de erro. Por quê? O objeto foto não foi criado dentro do nosso controller? Sim, mas como ele foi declarado com var dentro de uma função, ele possui escopo privado. Ah, então para resolvermos vamos remover var, fazendo com que ele caia no escopo global? Nem pensar! Porém, o Angular disponibiliza uma ponte de ligação entre o controller e a view chamada $scope e tudo que for "pendurado" neste objeto será enxergado pela view. Mas como teremos acesso a esse objeto tão especial dentro do mundo Angular? Pedindo! Como? Recebendo-o na função que declara o controller:

angular.module('alurapic').controller('FotosController', function($scope) {

});
Angular encontra na declaração do controller $scope e sabe que tem que criar um para nós. Se tivéssemos escrito o nome do parâmetro de outra maneira, o framework não o criaria. Ou seja, Angular sabe o que deve buscar de sua infraestrutura de acordo com o nome do parâmetro que recebemos em nosso controller. Agora que já temos acesso à $scope, a ponte de ligação do controller com a view, podemos pendurar os dados da foto como sua propriedade.

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Lembre-se que tudo pendurado em $scope será acessível em nossa view, em nosso caso , através da angular expression. Duvida? Só testar e verificar o resultado.

imagem de animal

Ah, isso é data binding?
Angular possui um termo apropriado para associação de um dado disponibilizado por um controller para a view: data binding (associação/ligação de dados). Qualquer alteração no dado do controller dispara uma atualização da view sem que o desenvolvedor tenha que se preocupar ou intervir no processo.

Excelente! Conseguimos um resultado semelhante ao que tínhamos antes, com a diferença de que agora a AE (Angular Expression) de nossa view foi processada com os dados fornecidos por FotosController. Pode parecer pouco, mas isso abre a porteira para que possamos avançar ainda mais no framework da Google.

O que aprendemos neste capítulo?
o papel do modelo MVC
o objeto global angular
importação do Angular e criação do módulo principal da aplicação
as diretivas ng-app e ng-controller
Angular Expression (AE)
o conceito de template
criação de um controller
o conceito de data binding

Preparando o ambiente
Nosso foco é aprender Angular, porém alguns recursos do framework necessitam de um servidor web rodando localmente em sua máquina. Para que você não perca o foco do Angular e não caia em questões de infraestrutura que dizem respeito a um servidor web, disponibilizamos o projeto alurapic (baixe agora) com tudo necessário para subir um servidor web localmente, inclusive com os arquivos do angular já baixados.

É importante destacar que o uso do projeto inicial alurapic não é opcional, pois ele já possui registrado todos os endpoints que serão consumidos pela nossa aplicação em Angular. Além disso, para que o servidor funcione, é necessário ter o Node.js instalado em sua máquina.

O Node.js é um ambiente JavaScript multiplataforma disponível para Linux, Mac e Windows. Para instalá-lo, siga as instruções abaixo referentes a sua plataforma (versão 4.X):

Linux (Ubuntu)
No Ubuntu, através do terminal (permissão de administrador necessária) execute o comando abaixo:

sudo apt-get install -y nodejs
ATENÇÃO: em algumas distribuições Linux, pode haver um conflito de nomes quando o Node é instalado pelo apt-get. Neste caso específico, no lugar do binário ser node, ele passa a se chamar nodejs. Isso gera problemas, pois a instrução npm start não funcionará, pois ela procura o binário node e não nodejs. Para resolver, use a seguinte instrução no terminal para subir o servidor:

nodejs server
É uma pena haver essa discrepância, mas fica aqui essa dica!

Windows
Baixe o instalador clicando no grande botão install diretamente da página do Node.js. Durante a instalação, você apenas clicará botões para continuar o assistente. Não troque a pasta padrão do Node.js durante a instalação a não ser que você saiba exatamente o que está fazendo.

MAC
O homebrew é a maneira mais recomendada para instalar o Node.js em sua máquina, através do comando:

brew update
brew install node
Não usa homebrew? Sem problema, baixe o instalador clicando no grande botão install diretamente da página do Node.js.

Rodando o servidor
Depois do Node.js ter sido instalado, dentro da pasta do projeto alurapic que você descompactou anteriormente, busque todas as dependências do projeto através do seu terminal (prompt de comando, no caso do Windows) favorito com o comando.

npm install
ATENÇÃO USUÁRIOS DE WINDOWS: se por acaso mensagem de erro serem exibidas, procure pelo texto npm ERR! self signed certificate. Se ele existir, isso indica um problema no certificado do seu roteador (proxy). Não se preocupe, basta rodar o comando no terminal npm set strict-ssl false que resolvera este problema.

Em menos de um minuto, todas as dependências para rodar o servidor terão sido baixadas. Para subi-lo utilizamos o comando:

npm start
Repare que seu terminal ficará aguardando indefinidamente, sinal de que o servidor está escutando. Agora é só abrir o navegador no endereço http://localhost:3000. Uma página de boas-vindas será exibida.

Curiosidade
O projeto Alurapic utiliza Express para criar endpoints REST e o NeDB, um banco de dados totalmente feito em Node.js e que não necessita qualquer configuração especial.

##### 2. Construindo o alicerce da nossa aplicação #####

Quando desenvolvemos no server-side, organizamos nosso código em camadas para facilitar a manutenção, o reaproveitamento e a legibilidade de nosso código. É muito comum aplicarmos o modelo MVC (Model, View, Controller), que consiste na separação de tarefas, facilitando assim a reescrita de alguma parte e a manutenção do código.

Porém, não é raro o mesmo desenvolvedor deixar de lado essas práticas quando codifica no client-side. Mesmo aqueles que procuram organizar melhor seu código acabam criando soluções caseiras que nem sempre são bem documentadas.

Tendo como base este cenário, frameworks MVC client-side foram criados. Entre eles temos o Backbone, Ember, Knockout, CanJS, Batman, entre outros.

Angular, o framework MVC da Google
Um framework MVC no lado do cliente que tem ganhado muita atenção da comunidade é o Angular. Criado como um projeto interno da Google e liberado para o público em 2009, ele tem como foco a criação de Single Page Applications (SPA’s). Este tipo de aplicação não recarrega a página durante seu uso, dando uma experiência mais fluída para o usuário. Não se preocupe se você é novo para este tipo de aplicação, você terá a oportunidade de entender melhor seus conceitos ao longo do treinamento.

Conhecendo um pouco da nossa aplicação, o Alurapic
Durante o treinamento construiremos a aplicação Alurapic, um sistema simples de gerenciamento de imagens, permitindo que o usuário busque por aquelas que seguem determinado critério. Mas não se engane: o domínio do problema, apesar de simples, será suficiente para empregarmos grande parte do "arsenal" que o Angular nos fornece, inclusive toda aplicação funcionará em cima de um servidor web já preparado.

Preview da aplicação

Preview da aplicação

Preview da aplicação

Instalando e configurando toda infra necessária
Agora que você já conhece um pouco sobre a aplicação que construiremos, saiba que alguns recursos do Angular dependem de um servidor web para funcionarem, em nosso caso, um servidor local. A boa notícia é que já disponibilizamos um para você, livrando-o dos seus detalhes de configuração. Inclusive ele fará persistência de dados sem que você tenha que instalar um banco de dados específico para isso. Porém, para tudo funcionar, você precisa ter instalado o Node.js.

O arquivo do projeto, o tutorial de instalação do Node.js e as instruções de como levantar o servidor estão no primeiro exercício deste capítulo. Esta é uma boa hora de fazê-lo antes de continuar. Vamos assumir a partir deste ponto que você realizou este primeiro exercício.

Por onde começar?
Angular é um framework que roda no lado do cliente, sendo assim, como qualquer outro script, deve ser importado na página que desejamos eleger como principal da aplicação, em nosso caso, a página já existente, index.html, que está salva dentro da pasta alurapic/public (não sabe que pasta é essa? Você fez o primeiro exercício do capítulo conforme solicitado?). Primeiramente vamos dar uma olhada em sua estrutura:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que a página já importa o CSS do Bootstrap. Se você ainda não o conhece, fique sabendo que ele permite aplicar um visual profissional em nosso projeto, com zero de esforço, apenas adicionando classes declaradas em seu arquivo CSS. Que classes são essas? Muita calma nessa hora! Elas serão introduzidas à medida que formos evoluindo nossa aplicação, mas já podemos adiantar que a classe container centraliza todo conteúdo da página e a text-center centraliza um elemento do tipo block, em nosso caso, a tag h1.

Agora que você já entendeu o papel do Bootstrap em nosso projeto, já podemos continuar. Todas as páginas, bibliotecas, scripts e qualquer outro arquivo dentro da pasta alurapic/public serão acessíveis através do seu navegador, inclusive já temos dentro da pasta alurapic/public/js/lib todos os arquivos do Angular que importaremos à medida que formos precisando. Vamos importar o script angular.min.js, o core do Angular dentro da tag head:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, mas ainda não escrevemos um código que utiliza o Angular! Para fazermos isso, primeiro precisamos criar um módulo.

Criando o alicerce da nossa aplicação, o módulo principal
A história é a seguinte: o framework nos ajuda a separar nosso código em pequenos grupos de código que podem ser combinados e reaproveitados quando necessário, esses grupos são chamados de módulos. Uma aplicação pode ter um, dez ou até mesmo mais de cinquenta módulos, tudo dependerá da complexidade da aplicação. Porém, há sempre um módulo que é o primeiro a ser inicializado assim que sua página é carregada pela primeira vez, inclusive ele também é o responsável pelo carregamento de outros módulos de que sua aplicação precisa para funcionar. É este que criaremos agora!

Vamos criar o arquivo public/js/main.js e mesmo sem escrever qualquer linha de código, vamos importá-lo sem demora na página index.html, abaixo da importação do core do Angular, para não corrermos o risco de esquecermos de importá-lo:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, e agora? Como criamos nosso módulo? Bem, o Angular disponibiliza para nós no escopo global o objeto angular (nada criativo, não?) que possui uma série de funções que nos permite interagir com o framework, entre elas a função module responsável pela criação de módulos.

Você deve estar pensando "Ok, entendi que é através desse objeto global que eu crio módulos e um monte de coisas do framework, mas escopo global não é algo ruim?". Preocupação justa, mas não se preocupe! Em uma aplicação bem-feita em Angular, este é o único objeto disponível globalmente, todo restante fica confinado dentro dos módulos do Angular! Com o tempo isso ficará ainda mais claro para você.

Criando o módulo principal da aplicação:

// public/js/main.js

angular.module('alurapic', []);
Acabamos de criar nosso primeiro módulo. Perceba que a função module recebe dois parâmetros. O primeiro é o nome do módulo que desejamos criar e o segundo é uma array com todos os módulos de que nosso módulo depende. Como não avançamos ainda com o projeto, não temos nenhuma dependência ainda, porém, você não deve omitir este parâmetro. Mais tarde você entenderá o que acontece quando ele é omitido (suspense!).

Ensinando um truque novo para o navegador
Tudo certo, criamos nosso módulo, mas como o Angular saberá que deve carregá-lo? Será que importar o script public/js/main.js é suficiente? Com certeza não.

Precisamos indicar em nossa página qual será o escopo de atuação do Angular, isto é, se ele gerenciará a página inteira ou apenas parte dela. Isso é importante, porque outro framework MVC pode estar sendo utilizado (algo raro, porém pode acontecer) e não queremos que o Angular bagunce seu trabalho.

Como apenas utilizaremos o Angular, gerenciaremos a página inteira, isto, a tag html e todos seus elementos filhos! Tudo bem, mas como faremos essa associação? Através do atributo ng-app:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que o atributo ng-app tem como valor o nome do nosso módulo e não poderia ser diferente. Quando nossa página é carregada pela primeira vez o Angular encontrará esse atributo e carregará o módulo alurapic, tudo isso automaticamente, sem termos que nos preocupar em carregá-lo! É claro que se você esquecer de importar o arquivo main.js o Angular não será capaz de carregar o módulo, certo?

Ah, então isso é uma diretiva?
Agora, só uma coisa antes de continuarmos: o atributo ng-app existe no mundo HTML? Com certeza não, ele não faz parte da especificação da W3C. O "atributo" ng-app é na verdade uma diretiva do Angular.

Diretivas ampliam o vocabulário do navegador, ensinando-o novos truques, inclusive aprenderemos a criar nossas próprias diretivas ao longo do treinamento! Nesse caso a diretiva ng-app fornece a capacidade de nossa página carregar/iniciar o módulo principal da aplicação. Aliás, não vamos mais usar o termo página, usaremos view, termo mais correto quando estamos no universo do Angular!

Nossa primeira página dinâmica
Legal, agora, com o servidor iniciado (não lembra como iniciá-lo? Veja o primeiro exercício do capítulo) vamos acessar o endereço http://localhost:3000 e verificar o resultado. Como esperado, nada impressionante, pois apenas preparamos a infraestrutura mínima de uma aplicação em Angular, que nada faz. No máximo, podemos ver através do console do navegador (eu uso Chrome, e você?) todos os arquivos carregados:

arquivos carregados

Bom, vamos começar a dar um colorido para nossa view index.html. Vamos adicionar uma foto, você pode escolher a URL de uma específica, não precisa ser igual a minha. Na tag img, utilizaremos as classes img-responsive center-block para que ela escale corretamente nos mais diversos dispositivos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
        </div><!-- fim container -->
    </body>
</html>
imagem de animal

Bravo! Mas isso não impressiona, além do mais, se tivéssemos 100 imagens teríamos que repetir a tag img 100 vezes! Em nossa aplicação aprenderemos a cadastrar informações de imagens e a partir desses dados cadastrados montaremos dinamicamente uma lista de imagens! Só que antes de pensar em integração com o back-end, precisamos primeiro entender como o Angular fornece dados para a nossa view e como ela se constrói a partir desses dados.

Vamos realizar uma pequena mudança na tag img, alterando os atributos src e alt:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
A primeira coisa é entender que abrimos lacunas em nossa view index.html através da sintaxe {{ }}. Se temos uma view que agora possui lacunas, podemos chamá-la de template. Quando alguém envia um memorando para outra, raramente ela começa do zero, ou seja, ela adota um template, toda uma estrutura já pronta e seu único trabalho é preencher essas lacunas que variam de acordo com a situação. Isso se aplica no mundo Angular! O que acontece se visualizarmos nossa página agora? Nenhuma imagem será exibida e nenhum erro ocorrerá! Aliás, o termo lacuna é muito genérico, no mundo Angular usamos Angular Expression (AE). Todo {{ }} que encontrarmos chamaremos de AE. Combinado?

Quando temos um template que precisa de algum dado através de uma AE e não encontra, simplesmente aquela expressão fica em branco. Agora, a pergunta que não quer calar: quem, no modelo MVC é o responsável em disponibilizar dados para a views? Se você respondeu controller acertou!

Nosso primeiro controller
Precisamos criar um controller que disponibilize para a view o dado que ela precisa, no caso um objeto que contenha como chave o título e o endereço de uma foto, por exemplo { titulo: 'Leão', url : 'http://www.fundosanimais.com/Minis/leoes.jpg'}.

Lembra do nosso módulo principal da aplicação? Podemos criar um ou mais controllers diretamente nele, porém é uma boa prática declarar cada controller em arquivos separados, mesmo que eles façam parte do módulo alurapic. Vamos criar dentro de public/js/controllers/fotos-controller.js.

Criando nosso controller:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {
  // definição do controller aqui 
});
Veja que chamamos novamente angular.module, só que dessa vez sem passar o segundo parâmetro, o array vazio. Quando fazemos isso, indicamos que queremos acessar o módulo e não criar um novo. Faz todo sentido, se queremos que nosso controller faça parte do módulo alurapic. Em seguida encadeamos uma chamada à função controller que recebe dois parâmetros. O primeiro é o nome do controller que estamos criando na convenção PascalCase, o segundo uma função que define o controller.

Sabemos que o controller deve fornecer o objeto foto para a view e que esse objeto deve conter as chaves titulo e url. Faremos isso agora!

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {

    var foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Excelente, agora precisamos importar o novo arquivo js que acabamos de criar em nossa view principal index.html:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que isso é suficiente? Não, precisamos indicar dentro da nossa view index.html qual fragmento será gerenciado pelo nosso controller. Angular permite associarmos diferentes controllers para diferentes partes de nossa view, uma maneira de separar responsabilidades. Porém, neste exemplo, queremos que o controller gerencie a tag body e todos os seus elementos filhos e fazemos isso através da diretiva ng-controller, que deve ter como valor o nome exato do controller que criamos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que funciona? Visualizando no navegador, a imagem não é exibida e também não temos uma mensagem de erro. Por quê? O objeto foto não foi criado dentro do nosso controller? Sim, mas como ele foi declarado com var dentro de uma função, ele possui escopo privado. Ah, então para resolvermos vamos remover var, fazendo com que ele caia no escopo global? Nem pensar! Porém, o Angular disponibiliza uma ponte de ligação entre o controller e a view chamada $scope e tudo que for "pendurado" neste objeto será enxergado pela view. Mas como teremos acesso a esse objeto tão especial dentro do mundo Angular? Pedindo! Como? Recebendo-o na função que declara o controller:

angular.module('alurapic').controller('FotosController', function($scope) {

});
Angular encontra na declaração do controller $scope e sabe que tem que criar um para nós. Se tivéssemos escrito o nome do parâmetro de outra maneira, o framework não o criaria. Ou seja, Angular sabe o que deve buscar de sua infraestrutura de acordo com o nome do parâmetro que recebemos em nosso controller. Agora que já temos acesso à $scope, a ponte de ligação do controller com a view, podemos pendurar os dados da foto como sua propriedade.

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Lembre-se que tudo pendurado em $scope será acessível em nossa view, em nosso caso , através da angular expression. Duvida? Só testar e verificar o resultado.

imagem de animal

Ah, isso é data binding?
Angular possui um termo apropriado para associação de um dado disponibilizado por um controller para a view: data binding (associação/ligação de dados). Qualquer alteração no dado do controller dispara uma atualização da view sem que o desenvolvedor tenha que se preocupar ou intervir no processo.

Excelente! Conseguimos um resultado semelhante ao que tínhamos antes, com a diferença de que agora a AE (Angular Expression) de nossa view foi processada com os dados fornecidos por FotosController. Pode parecer pouco, mas isso abre a porteira para que possamos avançar ainda mais no framework da Google.

O que aprendemos neste capítulo?
o papel do modelo MVC
o objeto global angular
importação do Angular e criação do módulo principal da aplicação
as diretivas ng-app e ng-controller
Angular Expression (AE)
o conceito de template
criação de um controller
o conceito de data binding

Preparando o ambiente
Nosso foco é aprender Angular, porém alguns recursos do framework necessitam de um servidor web rodando localmente em sua máquina. Para que você não perca o foco do Angular e não caia em questões de infraestrutura que dizem respeito a um servidor web, disponibilizamos o projeto alurapic (baixe agora) com tudo necessário para subir um servidor web localmente, inclusive com os arquivos do angular já baixados.

É importante destacar que o uso do projeto inicial alurapic não é opcional, pois ele já possui registrado todos os endpoints que serão consumidos pela nossa aplicação em Angular. Além disso, para que o servidor funcione, é necessário ter o Node.js instalado em sua máquina.

O Node.js é um ambiente JavaScript multiplataforma disponível para Linux, Mac e Windows. Para instalá-lo, siga as instruções abaixo referentes a sua plataforma (versão 4.X):

Linux (Ubuntu)
No Ubuntu, através do terminal (permissão de administrador necessária) execute o comando abaixo:

sudo apt-get install -y nodejs
ATENÇÃO: em algumas distribuições Linux, pode haver um conflito de nomes quando o Node é instalado pelo apt-get. Neste caso específico, no lugar do binário ser node, ele passa a se chamar nodejs. Isso gera problemas, pois a instrução npm start não funcionará, pois ela procura o binário node e não nodejs. Para resolver, use a seguinte instrução no terminal para subir o servidor:

nodejs server
É uma pena haver essa discrepância, mas fica aqui essa dica!

Windows
Baixe o instalador clicando no grande botão install diretamente da página do Node.js. Durante a instalação, você apenas clicará botões para continuar o assistente. Não troque a pasta padrão do Node.js durante a instalação a não ser que você saiba exatamente o que está fazendo.

MAC
O homebrew é a maneira mais recomendada para instalar o Node.js em sua máquina, através do comando:

brew update
brew install node
Não usa homebrew? Sem problema, baixe o instalador clicando no grande botão install diretamente da página do Node.js.

Rodando o servidor
Depois do Node.js ter sido instalado, dentro da pasta do projeto alurapic que você descompactou anteriormente, busque todas as dependências do projeto através do seu terminal (prompt de comando, no caso do Windows) favorito com o comando.

npm install
ATENÇÃO USUÁRIOS DE WINDOWS: se por acaso mensagem de erro serem exibidas, procure pelo texto npm ERR! self signed certificate. Se ele existir, isso indica um problema no certificado do seu roteador (proxy). Não se preocupe, basta rodar o comando no terminal npm set strict-ssl false que resolvera este problema.

Em menos de um minuto, todas as dependências para rodar o servidor terão sido baixadas. Para subi-lo utilizamos o comando:

npm start
Repare que seu terminal ficará aguardando indefinidamente, sinal de que o servidor está escutando. Agora é só abrir o navegador no endereço http://localhost:3000. Uma página de boas-vindas será exibida.

Curiosidade
O projeto Alurapic utiliza Express para criar endpoints REST e o NeDB, um banco de dados totalmente feito em Node.js e que não necessita qualquer configuração especial.

Vejamos as seguintes afirmações sobre Angular:
1) Angular é um script como outro qualquer, por isso precisa ser importado em nossa página através da tag script.

2) A diretiva ng-app carrega e importa o módulo que desejamos utilizar.

3) A diretiva ng-app possui como valor o nome do módulo que desejamos carregar assim que nossa página for carregada.

4) Um módulo pode ter de 0 a N dependências.

Com base nessas afirmações, podemos dizer que:

1,3 e 4 são verdadeiras
 
Correto! Precisamos importar o script do Angular como fazemos com qualquer outro, como os demais módulos criados, por exemplo. Além disso temos de carregar um módulo através da diretiva ng-app. Esses por sua vez podem carregar ou não demais módulos, isto é, suas dependências.

Temos:
1) angular.module('alurapic', []);

2) angular.module('alurapic');

3) angular.module('alurapic', ['calopsitaStyle']);

4) module('alurapic', []);

No que diz respeito à criação de módulos, podemos afirmar que:

2 e 4 estão erradas
 
Perfeito! Criamos um módulo através do objeto global angular passando dois parâmetros: o nome do módulo e um array com suas dependências, que pode ser vazio caso não possua. No exemplo angular.module('alurapic'); estamos apenas acessar um módulo já existente.

Temos as seguintes declarações sobre Angular Expression (AE):
1) Angular Expression serve para abrir lacunas em nossas views, que por sua vez passam a funcionar como templates.

2) Angular Expression possui a sintaxe {nomeDaPropriedade}.

3) Controllers podem fornecer dados para uma Angular Expression.

4) Uma Angular Expression não avaliada tem como valor null.

1 e 3 estão corretas
 
Usamos Angular Expressions para abrir "lacunas" em views. Essa ideia remete ao uso de templates: modelos com uma base pronta, mas que possuem trechos de informações dinâmicas. Essas informações dinâmicas são fornecidas pelos nossos controllers. A sintaxe de uma AE é {{nomeDaPropriedade}}.

Vejamos os seguintes códigos:
1) angular.module('contasAhReceber').controller(function($scope) { });

2) angular.module('contabilidade', []).controller('LancamentosController', function() { });

3) angular.module('estoque').controller('Provisao', function($scope) { });

4) angular.controller('CaixaCtrl', function($scope) { });

Sobre a criação de Controller em Angular, podemos afirmar sobre as alternativas apresentadas que:

2 e 3 estão corretas
 
Perfeito! Um controller pode ser criado com um módulo ou mais tarde adicionado em um módulo já existente. A função controller recebe como primeiro parâmetro o nome do controller e como segundo a função que o define.

Temos a seguinte marcação em nossa view:
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código omitido -->
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
O controller FotosController foi associado ao elemento body e qualquer um de seus elementos filhos terão acesso a tudo o que foi adicionado no escopo do controller. Qual das opções abaixo disponibiliza corretamente foto no escopo do controller:

angular.module('alurapic').controller('FotosController', function($scope) {
  $scope.foto = {
      titulo : 'Leão',
      url: 'http://fotosdoalem.com/leao.jpg'
  };
});
 
Perfeito! A comunicação entre um controller e uma view é feita através do objeto $scope, que representa o escopo de um controller. Qualquer propriedade adicionada neste objeto estará disponível na view e acessível através de AEs, para o elemento onde definimos o escopo do controller, assim como seus filhos.

Temos as seguintes afirmativas:
1 - Data binding significa associação de dado, isto é, podemos associar um dado à view através de Angular Expression e qualquer mudança nesse dado refletirá na sua apresentação na view.

2 - Uma Angular Expression (AE) é somente leitura, isto é, alterações dos dados na view não se propaga para o model.

3 - Um model no Angular pode ser um objeto ou qualquer tipo literal do JavaScript, como String ou Boolean.

4 - Angular não é uma solução que se coaduna com a prática de Progressive Enhancement no que diz respeito a criação de páginas web.

Podemos afirmar que:

Todas as afirmativas estão corretas
 
Uma AE é somente leitura, nossa view lê a informação no escopo do controller, mas não é capaz de atualizá-la. Este tipo de associação é chamado de one-way data binding, a informação flui do controller para a view. Aliás, esse dado associado à view pode ser qualquer tipo literal do JavaScript, inclusive um objeto.
Angular não se coaduna com a prática do Progressive Enhancement, no qual criamos uma página usando um simples HTML e CSS, usando JavaScript apenas para adicionar melhorias. Com Angular, se o JavaScript estiver desativado ou não for suportado, nada da aplicação funcionará.

Chegou a hora de praticar!
Neste exercício, implemente os passos que foram vistos durante esta aula para conseguir o mesmo resultado apresentado. Não consegue lembrar de tudo? Não se preocupe, apresentarei passos gerais para guiá-lo nesta tarefa. Se isso ainda não for suficiente, não se preocupe, você pode consultar o vídeo e o texto explicativo do capítulo, mas sugiro que tente primeiro sem antes consultá-los. Combinado?

No final, cole o código dos arquivos que você modificou:

1) Angular nada mais é do que um framework escrito em JavaScript e como qualquer script deve ser importado na página. Importe-o dentro da tag <head>. Lembre-se que você pode verificar através do developer tools (console do navegador) se o script foi importado, olhando a aba network (rede). Isso é importante, porque muitas vezes perdemos tempo achando que nosso código não funciona, quando na verdade é o script que não foi carregado.

2) Só carregar o Angular não é suficiente, precisamos criar o primeiro módulo da aplicação. Crie o arquivo main.js "no diretório js que se encontra dentro da pasta public". Declare o módulo nomeando de alurapic. Lembre-se que esse processo é feito por intermédio do objeto global angular.

3) Um módulo criado ainda não é suficiente. Você precisa fazer com que o Angular carregue o módulo assim que sua página for carregada. Lembra da diretiva ng-app? Lembra qual tem que ser o valor atribuído à ela? Mais alguma coisa? O módulo main.js tem que ser importado também na página, certo?

4) Agora que tudo está no lugar, dentro da tag <body> você vai adicionar a marcação que existe uma foto. Não lembra da marcação? Não se preocupe, vai uma cola:

<!-- dentro do body -->
<div class="container">
   <h1 class="text-center">Alurapic</h1>
   <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
</div><!-- fim container -->
5) Abra uma lacuna para os atributos src e alt da imagem, criando um controller que forneça os dados de que ela precisa. Lembre-se de criar um controller em um arquivo em separado usando a convenção de pastas que vimos. Ele se chamará FotosController e disponibilizará para a view um objeto foto com duas propriedades: url e titulo. Ainda lembra como um controller disponibiliza dados para a view?

6) Ainda lembra como criamos o controller para o módulo alurapic? Ainda lembra que precisamos importar o script do controller em nossa view index.html. Por fim, ainda lembra para que serve a diretiva ng-controller?

Mãos à obra e bom estudo!

Importando o script do Angular, o módulo principal da aplicação e adicionando a diretiva ng-app:
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <!-- código omitido -->        
    </body>
</html>
Abrindo uma lacuna no template index.html, através de AE (Angular Expression):

<!-- public/index.html -->
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
Criando o controller que fornecerá os dados para a view:

// public/js/controllers/fotos-controller.js
angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Importando o controller e adicionando a diretiva ng-controller:

<!-- public/index.html -->
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
       <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>

##### 3. Tornando nossa aplicação mais próxima de uma aplicação real #####

Melhorando a apresentação da nossa página
Bom, antes de avançarmos, vamos melhorar rapidamente o visual da nossa aplicação. Primeiro, vamos colocar seu título em destaque movendo a tag h1 para dentro de uma div, com a classe jumbotron:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
Em seguida, vamos colocar nossa figura dentro de um painel do Bootstrap:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">

            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
Preview Jumbotron e Panel

Que tal agora adicionarmos mais fotos? Para simplificar, vamos copiar e colar o painel que já criamos!

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
O resultado, como esperado, é a repetição da imagem do leonino:

Painel duplicado

Repetição de marcação dá trabalho!
E se agora quisermos uma foto diferente para cada painel? Sabemos que, dentro de um controller, é por intermédio de $scope que disponibilizamos dados para a view. Que tal criarmos foto2 e foto3? Só para simplificar, vamos deixar a mesma url para eles, apenas mudaremos seus títulos:

// public/js/controllers/fotos-controller.js 

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo: 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

    $scope.foto2 = {
        titulo: 'Leão2',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

    $scope.foto3 = {
        titulo: 'Leão3',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Precisamos alterar a AE dos novos painéis para apontar para os dados corretos:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto2.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto2.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto3.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto3.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
Preview de várias fotos

Legal, cada foto possui um nome, porém essa solução deixa a desejar. Perceba que estamos repetindo a mesma marcação do painel do Bootstrap três vezes, mas o que muda é apenas o valor da AE. Segundo, para cada nova foto teremos que adicionar mais uma propriedade em $scope e copiar e colocar um novo painel.

Primeiro, vamos resolver o problema das múltiplas propriedades em $scope. No mundo JavaScript, quando queremos representar uma lista utilizamos um array:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.fotos = [
        {
            titulo: 'Leão',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        },

        {
            titulo: 'Leão2',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        },

        {
            titulo: 'Leão3',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        }
    ];

});
Hum, interessante. Se precisarmos adicionar mais uma foto, basta adicioná-la dentro da lista. Porém, isso não resolve a renderização da nossa view. Se visualizarmos novamente, três painéis vazios serão exibidos, porque a view não foi capaz de avaliar a AE de cada um deles.

Repetir? É com o Angular mesmo!
Não seria interessante se o Angular fosse inteligente o suficiente para repetir o HTML do painel para cada objeto foto de nossa lista? Puxa vida, teríamos apenas um painel, o que evitaria a repetição, inclusive, para cada nova foto que entrar na lista, um novo painel seria criado! Já aprendemos as diretivas ng-app e a ng-controller, consegue ver um padrão? Diretivas do Angular começam com ng-! Então, como é repetir em inglês? Repeat! Então, se eu quero uma diretiva do Angular que repita a criação de uma marcação HTML para uma determinada lista temos a diretiva ng-repeat:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default" ng-repeat="foto in fotos">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->
        </div><!-- fim container -->
    </body>
</html>
Ao recarregarmos nossa página, as três imagens são exibidas, cada uma com seu título, com a diferença que temos um código HTML mais enxuto!

Preview

Na diretiva ng-repeat indicamos qual lista estamos varrendo, em nosso caso, fotos, que está no $scope de FotosController. Mas como ter acesso a cada contato da lista? Para isso, damos um apelido para cada item da lista, em nosso caso, escolhemos o apelido foto. Como temos três fotos em nossa lista, a diretiva ng-repeat será repetida três vezes e através da AE podemos ter acesso aos dados da foto, por exemplo, com {{foto.titulo}} acessamos seu título.

O bonito seria se a lista de fotos viesse de um servidor web. É tão bonito que faremos isso agora, chega de ficar digitando dados fixos!

Chega de dados fixos! Vamos buscá-los do servidor!
É extremamente comum uma aplicação feita em Angular consumir dados de um servidor através de uma API REST, que retorna esses dados na estrutura JSON. Nosso servidor já possui uma série de endpoints que utilizaremos ao longo do treinamento, porém há um deles que nos interessa. Que tal abrir em seu navegador para ver o resultado?

http://localhost:3000/v1/fotos
Fotos

Não se assuste, mas o que o servidor retornou para você foi uma lista de fotos, porém, na chave url, não há o endereço de uma foto, mas o DataUri de uma foto. Fizemos isso para termos a garantia de que a foto sempre existirá, o que poderia não acontecer caso tivéssemos preenchido com o endereço de uma foto da web qualquer. Pois bem, a ideia é acessarmos essa lista através da nossa aplicação para em seguida jogá-la em $scope.fotos.

Para que possamos acessar os dados do nosso servidor precisaremos realizar requisições Ajax. Lembre-se que este tipo de requisição é assíncrono, isto é, que não bloqueia o uso da aplicação enquanto é executado. Se você vem do mundo jQuery já deve ter usado $.ajax ou uma de suas especializações, porém, o Angular possui seu próprio serviço para executar este tipo de requisição, o $http.

Da mesma maneira que pedimos ao Angular a criação de um $scope podemos pedir o $http recebendo-o como parâmetro na função que define FotosController. Vamos aproveitar e deixar a lista de fotos vazia:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];
});
Esse sistema de "pedirmos" ao Angular o que precisamos é chamado de injeção de dependências. Nós gritamos "eu preciso de um $http!" e o framework se vira para nos entregar um. Outra coisa é que podemos inverter a ordem dos parâmetros da função que ainda assim o Angular saberá injetá-los. É por isso que o nome dos parâmetros são importantes. Se digitarmos http no lugar de $http, Angular não saberá que precisamos desse serviço e seu valor será undefined.

Pois bem, temos $http. E agora? Como realizamos uma requisição assíncrona para o endpoint v1/fotos? Como queremos obter dados, usamos a função get:

// não entra em nenhum lugar, apenas ilustrativo
$http.get('/v1/fotos');
Então, o retorno da função $http.get é a nossa lista de fotos do servidor? Não, não é! Toda requisição assíncrona é incerta, não sabemos quanto tempo ela demorará para ser executada e se realmente será bem sucedida.

Angular faz promessas?
O que $http.get nos retorna é uma promessa de que ele buscará os dados. Sabemos que se essa promessa for cumprida, teremos os dados, caso contrário, ficaremos a ver navios. Tecnicamente falando, o que $http.get retorna é uma promise:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');  
});
Quando essa promessa for cumprida, daí (then) podemos ter acesso aos dados retornados:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');
    promise.then(function(retorno) {
        $scope.fotos = retorno.data;
    });
});
Veja que a função then recebe como parâmetro uma função passada por nós que será chamada apenas quando a requisição for concluída com sucesso, ou melhor, quando nossa promessa for resolvida. Na documentação do Angular, está escrito que é nela que temos acesso aos dados retornados pelo servidor, em nosso caso, escolhemos o nome retorno, mas poderia ser qualquer um. Porém, é de retorno.data que efetivamente temos nossa lista de fotos.



E se alguma coisa der errada? Por exemplo, a URL não existir ou o servidor cair? Podemos encadear uma chamada à função .catch que nos fornecerá um objeto com informações do erro que ocorreu:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');
    promise.then(function(retorno) {
        $scope.fotos = retorno.data;
    })
    .catch(function(erro) {
        console.log(erro)
    }); 
});
Por enquanto só vamos exibir no console do navegador a mensagem, mais tarde aprenderemos a exibir mensagens amigáveis para o usuário.

Podemos ainda omitir a declaração da variável promise:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .then(function(retorno) {
        $scope.fotos = retorno.data;
    })
    .catch(function(erro) {
        console.log(erro);
    }); 
});
Ou ainda usarmos success e error. A diferença é que com success não precisamos fazer retorno.data:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .success(function(retorno) {
        console.log(retorno);
        $scope.fotos = retorno; // não precisa fazer retorno.data
    })
    .error(function(erro) {
        console.log(erro);
    });

});
Ainda neste treinamento aprenderemos a cadastrar novas fotos, editar, inclusive apagar aquelas que não nos interessam. Porém, como podemos perceber, a quantidade de fotos aumentou e pode ficar ainda maior. Vamos ajustar nosso layout colocando um grid responsivo do Bootstrap:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">

                <div class="panel panel-default col-md-2" ng-repeat="foto in fotos">
                    <div class="panel-heading">
                        <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                    </div>
                    <div class="panel-body">
                        <img class="img-responsive center-block" src="{{foto.url}}">
                    </div><!-- fim panel-body -->
                </div><!-- fim panel panel-default -->

            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Grid

O que aprendemos neste capítulo?
a diretiva ng-repeat
injeção de dependências baseada no nome de parâmetro
o serviço $http
o conceito de promise
comunicação com o back-end

O Angular permite repetir marcações HTML através da diretiva ng-repeat. Primeiro, precisamos adicioná-la no elemento que desejamos repetir, segundo, precisamos indicar na diretiva a propriedade em $scope do controller que será iterada. Dentro desse contexto, temos alguns exemplos abaixo do uso da diretiva:
1) <p ng-repeat="frase in frases">{{frase}}</p>

2) <p ng-repeat="frases">{{frase}}</p>

3) <div ng-repeat="produto in produtos">{{produtos}}</p>

4) <section ng-repeat="propaganda">{{propaganda}}</p>

Podemos afirmar sobre os exemplos acima que:

Apenas 1 está correta
 
O código <p ng-repeat="frase in frases">{{frase}}</p> é funcional. Ele itera sobre a lista frases, que existe no escopo de algum controller e para cada elemento fornece um apelido, no caso frase. Assim conseguimos acessar cada elemento da lista através da Angular Expression (AE) {{frase}}.

Angular possui seu próprio sistema de injeção de dependências:
1) angular.module('alurapic').controller('a', function($http, $scope) {});

2) angular.module('alurapic').controller('b', $http, $scope) {};

3) angular.module('alurapic').controller('c', function($scope, $http) {});

4) angular.module('alurapic').controller('d', function($scope, http) {});

Levando em consideração o que você aprendeu neste capítulo, qual das alternativas abaixo é verdadeira?

2 e 4 não injetam corretamente $http e $scope
 
Angular foi pioneiro no suporte à injeção de dependências no lado do cliente. Uma característica desse sistema é que toda injeção é feita pelo nome do parâmetro, por isso é muito importante passarmos os parâmetros nomeados de acordo com o serviço ou recurso do Angular que desejamos usar.

Angular fornece um serviço exclusivo para realização de requisição Ajax, o $http.Vejamos algumas afirmativas sobre este serviço:
1) Pode ser injetado como qualquer outro artefato do Angular

2) Possui a função .get, que recebe como parâmetro um endereço, inclusive é especializada na leitura de dados.

3) A função .get retorna uma promise.

4) Podemos usar .then e .catch para obter os dados e capturar erros respectivamente ou .success e .error, açúcares sintáticos com a mesma finalidade.

Com base nas afirmações acima, podemos dizer que:

Todas são verdadeiras, exceto a 1
 
Ops! Lembre-se que podemos sim contar com a injeção do serviço $http do Angular, por exemplo, como fazemos nos controllers: angular.module('alurapic').controller('FotosController', function($http, $scope){ ... })

Qual das opções abaixo declara corretamente um controller e configura corretamente um elemento da view para usar a diretiva ng-repeat?

// controller
angular.module('alurapic').controller('NomeDoController', function($scope) {
   $scope.letras = ['A', 'B', 'C'];
});
// na view

<ul ng-controller="NomeDoController">
    <li ng-repeat="letra in letras">{{letra}}</li>
</ul>
 
Muito bem! Angular não perdoa! Basta um erro de sintaxe ou omitir um artefato, como $scope, para que nossa funcionalidade deixe de funcionar.

Sabemos que $http.get retorna uma promise e que podemos encadear uma chamada à then. Um exemplo:
$http.get('v1/fotos')
  .then(function(retorno) {
    $scope.fotos = retorno.data;
  })
  .catch(function(erro) {
    // trata o erro
  });
Para praticar outras formas de escrita, tente reescrever o código acima utilizando .success e .error, aqueles açúcares sintáticos de $http.

O código modificado fica:
$http.get('v1/fotos')
  .success(function(fotos) {
    $scope.fotos = fotos;  
  })
  .error(function(erro) {
    // trata o erro
  });
Neste exemplo, é importante notar que a função success recebe a lista de fotos diretamente retornada pelo servidor e não um objeto que contém a propriedade .data, quando usamos then. Como temos acesso à lista diretamente, fica mais legível chamarmos o parâmetro de fotos do que simplesmente retorno.

Chegou a hora de praticar, mais uma vez!
Neste exercício, implemente os passos que foram vistos durante esta aula, para conseguir o mesmo resultado apresentado, evoluindo ainda mais nossa aplicação. Não consegue lembrar de tudo? Não se preocupe, apresentarei passos gerais para guiá-lo nesta tarefa. Se isso ainda não for suficiente, não se preocupe, você pode consultar o vídeo e o texto explicativo do capítulo, mas sugiro que tente primeiro sem antes consultá-los.

1) Melhore a experiência do usuário adicionando um componente jumbotron do Bootstrap. Este é um treinamento de Angular e não de Bootstrap, sendo assim, fique livre para consultar a qualquer momento o vídeo e o texto explicativo caso tenha dúvidas nas marcações do Bootstrap.

2) No lugar de exibir a imagem da foto diretamente, exiba-a através de um panel-default do Bootstrap. Repare que até agora não há nenhuma novidade do mundo Angular. Aproveite também para adicionar o sistema de grids do Bootstrap.

3) Altere seu controller para disponibilizar no mínimo três fotos para a view. Como? Lembra que uma propriedade em $scope pode ser uma lista, um array em JavaScript?

4) Com esta alteração, altere seu painel em index.html para que ele construa um painel para cada foto em $scope.fotos. Para esta tarefa, você precisará realizar uma repetição através da diretiva ng-repeat.

5) Agora que sua view index.html consegue exibir um painel para cada foto $scope.fotos, está na hora de deixar de trabalhar com dados fixos e buscar esses dados do servidor. Solicite em seu controller o serviço $http via injeção, aquele responsável por realizar requisições Ajax.

6) O projeto baixado no primeiro capítulo já possui um servidor com endereços específicos para operações de inclusão, alteração, deleção e listagem. Nosso foco é no Angular, não na criação do back-end, porém é importantíssimo saber que consumiremos endpoints REST, que nada mais são do que URLs seguindo a convenção REST. A URL http://localhost:3000/v1/fotos é a responsável por obter todas as fotos, porém $http só precisa da parte v1/fotos para trabalhar.

7) Acesse a URL através de $http.get, lembrando que este serviço retorna uma promise. O $http possui dois atalhos para esta operação e serão estes que você utilizará: success e error.

8) Atualize $scope.fotos com os dados retornados pelo servidor. Agora, você terá dados dinâmicos e não estáticos como antes!

9) Muita informação? Fique à vontade para assistir o vídeo e consultar a explicação textual quantas vezes for necessária. Não sinta a obrigação de decorar tudo de uma só vez, é natural dúvidas no que diz respeito à sintaxe do Angular.

Bom exercício!

A página principal alterada, com os componentes jumbotron e panel-default do Bootstrap, e com a diretiva ng-repeat!
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">

                <div class="panel panel-default col-md-2" ng-repeat="foto in fotos">
                    <div class="panel-heading">
                        <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                    </div>
                    <div class="panel-body">
                        <img class="img-responsive center-block" src="{{foto.url}}">
                    </div><!-- fim panel-body -->
                </div><!-- fim panel panel-default -->

            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
O controller alterado, agora buscando os dados do servidor:

// public/js/controllers/fotos-controller.js
angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .success(function(retorno) {
        console.log(retorno);
        $scope.fotos = retorno; // não precisa fazer retorno.data
    })
    .error(function(erro) {
        console.log(erro);
    });

});

##### 4. Minimizando a complexidade do nosso HTML #####

Progredimos com nossa aplicação, porém a marcação HTML da página index.html está um pouco confusa, pelo menos para mim. São muitas divs e classes, tudo porque estamos usando o Bootstrap. Ganhamos de um lado, mas perdemos em termos de legibilidade. Por exemplo, a marcação de um painel é assim:

<!-- exemplo, não entra em nenhum lugar -->
<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title text-center">Leão</h3>
      </div> 
      <div>
           // conteúdo do painel
      </div>
</div>
Confinando a complexidade do painel em uma diretiva
O mundo seria melhor se pudéssemos esconder a complexidade da marcação que vimos utilizando algo como um componente:

<!-- exemplo, não entra em nenhum lugar -->
<meu-painel titulo="Leão">
  // conteúdo do Painel
</meu-painel>
Mas a tag meu-painel é um componente que não existe no mundo HTML. Porém, lembram das diretivas do Angular? Elas nada mais são do que componentes reutilizáveis e que podem existir não apenas como atributos, mas como tags também. Será que podemos criar uma diretiva customizada do Angular que esconda a complexidade do painel do Bootstrap? Sim e é isso que faremos agora para deixar nossa marcação mais elegante, inclusive poderemos aproveitá-la em outros lugares da nossa aplicação.

O primeiro passo é criar um módulo em separado que conterá nossas diretivas. Vamos criá-lo em:

public/js/directives/minhas-diretivas.js

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
Criamos um novo módulo. Antes de mais nada, precisamos importar seu script em index.html, e inclusive adicioná-lo como dependência do módulo principal da nossa aplicação.

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">
                <div class="panel panel-default col-md-2" ng-repeat="foto in fotos">
                    <div class="panel-heading">
                        <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                    </div>
                    <div class="panel-body">
                        <img class="img-responsive center-block" src="{{foto.url}}">
                    </div><!-- fim panel-body -->
                </div><!-- fim panel panel-default -->
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
// public/js/main.js

angular.module('alurapic', ['minhasDiretivas']);
Pronto, agora criamos nossa primeira diretiva através da função directive. Ela recebe como primeiro parâmetro o nome da diretiva em camelCase e como segundo uma função que deve retornar um directive definition object (DDO):

// public/js/directives/minhas-diretivas.js 

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {
        var ddo = {};
        return ddo;
    });
Veja que estamos retornando um objeto ainda sem qualquer configuração. Vamos começar restringindo a forma de uso da nossa diretiva. Como assim? Uma diretiva em Angular pode ser usada como Elemento, Atributo ou Comentário (esta última muito incomum). Vamos estipular que nossa diretiva pode ser usada tanto como atributo ou como elemento, adicionando em nosso DDO a propriedade restrict com valor "AE":

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {
        var ddo = {};

        ddo.restrict = "AE";

        return ddo;
    });
Nossa diretiva ainda não está pronta, mas ela pode ser usada como elemento, assim:

<!-- exemplo, não entra em nenhum lugar -->
<meu-painel></meu-painel>
Ou como atributo, neste caso, usamos uma div adicionando a diretiva:

<!-- exemplo, não entra em nenhum lugar -->
<div meu-painel></div>
Uma coisa importante que pode ter passado sem você perceber. O nome da nossa diretiva está em camelCase, porém na marcação HTML estamos usando hífen. Este é um padrão do Angular que não podemos deixar de seguir, caso contrário nossa diretiva não funcionará.

Muito bem, qual é o próximo passo? Bem, podemos ter várias diretivas meu-painel numa mesma página, mas cada uma com seu próprio título. Algo assim:

<!-- exemplo, não entra em nenhum lugar -->
<meu-painel titulo="Leão"></meu-painel>
<meu-painel titulo="Zebra"></meu-painel>
<meu-painel titulo="Girafa"></meu-painel>
Isolando nossa diretiva
Para que cada diretiva tenha seu próprio título, cada uma precisará ter um escopo isolado, que existe independente do contexto na qual está incluída. Além de permitir que cada uma tenha seus próprios dados, podemos reutilizar a diretiva em qualquer lugar sem que ela bagunce o escopo pai no qual está inserida!

Precisamos capturar o título passado pela diretiva para dentro de seu escopo isolado e fazemos isso adicionando em nosso DDO a propriedade scope:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};
        ddo.restrict = "AE";

        ddo.scope = {
            titulo: '@titulo'
        };

        return ddo;
    });
Criamos a propriedade titulo no escopo isolado da diretiva, porém o valor desta propriedade é curioso. Veja que nele temos @titulo, a sintaxe @ indica que estamos copiando o valor como string do atributo titulo adicionando na diretiva em nossa marcação. Porém, quando o nome do atributo na diretiva na marcação é igual ao nome da propriedade que guardará o seu valor, podemos deixar apenas @:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};
        ddo.restrict = "AE";

        ddo.scope = {
            titulo: '@'
        };

        return ddo;
    });
Agora que restringimos a forma de uso da diretiva e criamos seu escopo isolado, precisamos definir a marcação HTML que será utilizada por ela. Fazemos isso através da propriedade template:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};

        ddo.restrict = "AE";

        ddo.scope = {
            titulo: '@'
        };

        ddo.template = 
                '<div class="panel panel-default">'
            +   '   <div class="panel-heading">'
            +   '        <h3 class="panel-title text-center">{{titulo}}</h3> '
            +   '   </div>'
            +   '   <div class="panel-body">'
            +   '   </div>'
            +   '</div>'

        return ddo;
    });
Veja que no próprio template estamos usando a Angular Expression {{titulo}} para exibir o titulo passado como parâmetro para a diretiva. Será que funciona? Primeiro, vamos alterar index.html para fazer uso da nossa diretiva:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">
                <meu-painel ng-repeat="foto in fotos" titulo="{{foto.titulo}}">
                    <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Veja que adicionamos em nossa diretiva também a diretiva ng-repeat, porque queremos repetir nossa diretiva de acordo com a quantidade de fotos. E o resultado final fica:

Problema com diretiva

Resultado não esperado? Entendendo um pouco mais de diretivas
Ops! Funcionou parcialmente! Veja que o painel é montado e o título exibido, mas parece que nossa diretiva ignorou todo o seu conteúdo. Isso acontece porque o Angular altera aquele fragmento do DOM substituindo por um novo que representa a marcação da nossa diretiva, nesse processo, perdemos todos os seus elementos filhos. Para que o Angular preserve o conteúdo original da diretiva, precisamos usar o mecanismo de transclusão.

Apesar do nome intimidador, não se preocupe. Para ativarmos a transclusão basta adicionar no DDO a propriedade transclude com valor true e na marcação da diretiva adicionar a diretiva ng-transclude no elemento que deve preservar seus elementos filhos:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};

        ddo.restrict = "AE";
        ddo.transclude = true;

        ddo.scope = {
            titulo: '@'
        };

        ddo.template = 
                '<div class="panel panel-default">'
            +   '   <div class="panel-heading">'
            +   '        <h3 class="panel-title text-center">{{titulo}}</h3> '
            +   '   </div>'
            +   '   <div class="panel-body" ng-transclude>'
            +   '   </div>'
            +   '</div>'

        return ddo;
    });
Agora sim! Vejamos o resultado:

Transclude

Separar ainda é a melhor coisa: HTML de um lado e diretiva do outro
Criamos nossa primeira diretiva! Porém, ficar concatenando HTML dentro da propriedade template não é algo gostoso de se fazer. Que tal colocarmos a marcação dentro de um arquivo HTML, local onde ele pertence? Para isso, vamos criar o arquivo public/js/directives/meu-painel.html com a marcação:

<!-- public/js/directives/meu-painel.html -->

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title text-center">{{titulo}}</h3>
    </div>
    <div class="panel-body" ng-transclude>
    </div>
</div>
E agora, trocamos em nossa diretiva a propriedade template por templateUrl apontando para o arquivo HTML com a marcação da diretiva:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};

        ddo.restrict = "AE";
        ddo.transclude = true;

        ddo.scope = {
            titulo: '@'
        };

        ddo.templateUrl = 'js/directives/meu-painel.html';           

        return ddo;
    });
O resultado tem que continuar o mesmo, pois alteramos apenas a maneira pela qual organizamos nosso código.

O que aprendemos neste capítulo?
diretivas são componentes reutilizáveis
a criar nossas própria diretivas
diretivas reutilizáveis devem possuir escopo isolado
mecanismo de transclusão

Temos as seguintes declarações sobre diretivas:
1) Diretivas são criadas através da função .directive.

2) Diretivas retornam opcionalmente um DDO (Directive Definition Object).

3) Diretivas são componentes do Angular que ensinam novos truques para o navegador.

4) Diretivas ensinam novos truques para o navegador, e podem existir sem pertencerem a um módulo

Podemos afirmar que:

1 e 3 são verdadeiras
 
Diretivas são componentes reutilizáveis que podem encapsular marcação e comportamento. São criadas sempre dentro de um módulo através da função .directive. Toda diretiva deve sempre retornar um DDO (Directive Definition Object) configurado para que funcione

Veja a definição da diretiva:
angular.module('minhasDiretivas', [])
    .directive('abasDinamicasEspeciais', function() {
       var ddo = {};
       ddo.restrict = 'AE';

      // implementação da diretiva omitida
    });
Quais são todos os possíveis usos da diretiva no HTML?

<abas-dinamicas-especiais></abas-dinamicas-especiais> e <div abas-dinamicas-especiais></div>
 
Com a propriedade restrict declaramos que ela pode ser utilizada tanto como atributo (A), quanto como elemento (E). Mesmo usando camelCase na definição da diretiva, devemos utilizar o hífen na marcação HTML.

Para definir a diretiva no Angular devemos criar um Directive Definition Object (DDO), por exemplo:
angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {
        var ddo = {};

        //propriedades aqui

        return ddo;
    });
Qual das propriedades abaixos não fazem parte de um DDO?

url
 
A propriedade url não faz parte de um DDO, mas temos a propriedade templateUrl, que permite criar um arquivo HTML separado para toda a marcação HTML dessa diretiva, indicando apenas o caminho para o arquivo. Alternativamente podemos usar a propriedade template com toda marcação necessária da diretiva.

Veja o uso de uma diretiva para mostrar os dados de um usuario logado:
<usuario-logado nome-completo="{{usuario.nome-completo}}"></usuario-logado>
Como sabemos, para capturar dados da diretiva, usamos a propriedade scope:

angular.module('minhasDiretivas', [])
    .directive('usuarioLogado', function() {

        var ddo = {};
        ddo.restrict = "AE";

        ddo.scope = {
            nome: 'AQUI'
        };

        return ddo;
    });
O que devemos usar no lugar de AQUI para a diretiva funcionar corretamente?

@nome-completo
 
Repare que o atributo no elemento HTML se chama nome-completo e na diretiva usamos apenas nome. Se os dois fossem iguais, bastaria colocar @ no lugar de AQUI. Mas, como possuem nomes diferentes, é preciso ser explícito na declaração do scope usando @nome-completo para capturar o valor do atributo.

Diretiva, marcação e definição
Vejamos a seguinte marcação HTML:

<p meu-paragrafo titulo="Bem-vindo ao alura"></p>
Qual das opções abaixo cria corretamente a diretiva que nada mais faz do que exibir um parágrafo com o titulo recebido?

angular.module('minhasDiretivas').directive('meuParagrafo', function() {

    var ddo = {};
    ddo.restrict = 'A';

    ddo.scope = {
        titulo : '@titulo'
    };

    ddo.template = '<p>{{titulo}}</p>';
    return ddo;
}):
 
Muito bem! Nesse exercício vimos uma utilização de diretiva apenas como Atributo.

O Bootstrap ajuda na aplicação de um visual profissional em nossa aplicação, porém seu uso baseado em tags e classes pode acabar deixando nosso HTML difícil de manter. Podemos minimizar essa complexidade através do Angular, criando componentes reutilizáveis chamados de diretivas, que podem encapsular, esconder a complexidade da marcação, inclusive de comportamento (algo que veremos mais à frente).
Neste exercício, implemente os passos que foram vistos durante esta aula para criar sua primeira diretiva. Como sempre, seguem os passos gerais que devem ser empreendidos nesta tarefa:

1) Sua primeira diretiva viverá em um módulo exclusivo chamado minhasDiretivas, declarado no arquivo public/js/directives/minhas-diretivas.js Criar módulos não é novidade, você já fez isso no primeiro capítulo. Não esqueça de importar o script do novo módulo em index.html, inclusive não esqueça de adicioná-lo como dependência do módulo alurapic, o módulo principal da aplicação.

2) Do que adianta um módulo sem qualquer funcionalidade? Para o módulo minhasDiretivas crie a diretiva meuPainel através do encadeamento da função .directive. Ela recebe dois parâmetros, o nome da diretiva e a função que a define.

3) Você precisa indicar a restrição da diretiva, seu template e escopo. Quando for declarar o template da diretiva, use templateUrl declarando seu template separadamente em um arquivo. Isso o ajudará na manutenção do seu código, principalmente do template.

4) Terminou? Por mais que sua diretiva tenha o nome meuPainel, quando for utilizá-la em sua view index.html precisará usá-la como <meu-painel></meu-painel>, fechando obrigatoriamente a tag. O padrão camelCase é substituído pelo uso de hífens na marcação HTML. Aliás, a diretiva deve ter a seguinte interface de uso: <meu-painel titulo="meuTitulo"></meu-painel>.

5) A diretiva conterá elementos filhos e quando o Angular for trocá-la na view pela marcação do Bootstrap perderemos todos os seus elementos. Lembra ainda qual é o mecanismo do Angular que faz com que a diretiva mantenha seus elementos filhos? Você precisará utilizá-lo!

6) Por fim, faça uso da diretiva, alterando index.html.

Diretivas não encapsulam apenas marcações HTML, veremos ao longo do treinamento como encapsularmos comportamentos.

Mãos à obra e bom estudo!

Seguem abaixo as alterações necessárias até aqui.
A diretiva meuPainel:

// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        var ddo = {};

        ddo.restrict = "AE";
        ddo.transclude = true;

        ddo.scope = {
            titulo: '@'
        };

       ddo.templateUrl = 'js/directives/meu-painel.html';        

        return ddo;
    });
Agora, a marcação da diretiva usada como template da diretiva. Note o uso da diretiva ng-transclude, indicando qual elemento do template deve manter seus elementos filhos:

<!-- public/js/directives/meu-painel.html -->

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title text-center">{{titulo}}</h3>
    </div>
    <div class="panel-body" ng-transclude>
    </div>
</div>
Por fim, importando o script do módulo minhasDiretivas, inclusive já declarando este módulo como dependência do módulo alurapic:

<!-- public/index.html -->
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
   <!-- código posterior omitido -->
Como criamos um módulo, precisamos importá-lo em index.html e declará-lo como dependência do módulo principal da aplicação:

// public/js/main.js

angular.module('alurapic', ['minhasDiretivas']);
Por fim, alterando index.html para que faça uso da diretiva:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">
                <meu-painel ng-repeat="foto in fotos" titulo="{{foto.titulo}}">
                    <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>

##### 5. Melhorando a experiência do usuário #####

A lista pode crescer, e agora?
Muito bem, evoluímos ainda mais nossa aplicação sob o ponto de vista interno, porém podemos melhorar a experiência do usuário. Por enquanto temos poucas fotos, mas eu tenho certeza que assim que aprendermos a cadastrar novas fotos e agrupá-las, o número será muito, muito maior! Então, que tal já implementarmos um mecanismo de procura que permita o usuário exibir apenas fotos de acordo com algum critério?

Que tal filtrarmos nossa lista?
Primeiro, vamos adicionar o campo de entrada da pesquisa. Vamos aproveitar a adicionar mais uma linha usando o sistema de GRID do Bootstrap, inclusive utilizaremos algumas classes especiais para estilizar elementos de entrada:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2" ng-repeat="foto in fotos" titulo="{{foto.titulo}}">
                     <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Filtro de pesquisa

A ideia é simples: a medida que formos digitando, queremos exibir apenas as fotos que contenham em qualquer uma de suas propriedades o texto procurado.

Vamos adicionar em FotosController uma propriedade que guardará o texto digitado pelo usuário:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];
    $scope.filtro = '';

    $http.get('/v1/fotos')
    .success(function(retorno) {
        $scope.fotos = retorno;
    })
    .error(function(erro) {
        console.log(erro)
    });

});
Ah, então esse é o two-way data binding?
Já sabemos acessar qualquer propriedade de $scope através de uma angular expression (AE), porém temos um problema: toda AE é somente leitura, isto é, não é capaz de atualizar $scope, que é justamente o que precisamos. É com base no que o usuário digitar que elaboraremos nossa estratégia de busca. Não queremos um data binding unidirecional, queremos um bidirecional, aquele que é capaz de ler de $scope, inclusive atualizar seu valor de acordo com a entrada do usuário.

Felizmente o Angular suporta two-way data binding. A diferença é que não usamos AE, mas a diretiva ng-model. Vamos adicioná-la no input que recebe o filtro do usuário:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2" ng-repeat="foto in fotos" titulo="{{foto.titulo}}">
                       <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Eu não sabia que podemos filtrar com ng-repeat!
E agora? Bem, toda vez que o usuário digitar neste campo, a propriedade $scope.filtro será atualizada! Excelente, mas como utilizaremos o valor corrente de $scope.filtro para filtrar a lista de fotos? A diretiva ng-repeat aceita receber um filtro através da propriedade filter, que deve ser adicionada imediatamente após um pipe |, sendo assim, ela ficará assim: ng-repeat="foto in fotos | filter: filtro"

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
                      <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Filtro em ação

Inacreditável! Com pouquíssimo esforço, filtramos nossa lista, porém vale ressaltar que o filtro é aplicado em todas as propriedade do objeto foto de nossa lista, sendo assim, podemos encontrar uma foto pelo seu título, descrição, etc.

Deixando o usuário ainda mais feliz animando nossa lista
Você há de concordar que melhoramos bastante a aplicação, porém a aplicação do filtro é abrupta, instantânea, imediata! Para deixar o usuário feliz, que tal se animássemos a aplicação do filtro? Podemos fazer isso de várias maneiras, por exemplo, aplicado um efeito fadeout nas fotos que não atenderem nosso filtro.

Normalmente, esta é uma tarefa do mundo CSS, sendo assim, precisamos criar uma classe com o efeito desejado e aplicar essa classe via JavaScript para os elementos que deixarem nossa lista. Vamos criá-la, mas dentro do arquivo public/css/efeitos.css:

/* public/css/efeitos.css*/

.fade {
  -moz-transform: scale(0.1);
  -webkit-transform: scale(0.1);
  -ms-transform: scale(0.1);
  -o-transform: scale(0.1);
  transform: scale(0.1);
}
Agora, vamos importar o CSS em index.html e aplicar a classe fade em nosso painel com a diretiva ng-repeat:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2 fade" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
                        <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
E testar logo em seguida:

Problema na aplicação do nosso painel animado

Hum, não funcionou como esperado. Os elementos já começam invisíveis. A ideia é aplicar a classe painel-animado apenas no elemento que sair (leave) da lista, isto é, para o elemento que não atender o critério do nosso filtro. E agora?

A equipe do Angular criou o módulo ngAnimate, que ataca justamente este problema. Antes de entrarmos nos detalhes de seu funcionamento, vamos importar seu script logo após o script core do Angular e adicioná-lo como dependência no módulo principal da aplicação

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>

        <!-- importando o módulo ngAnimate -->

        <script src="js/lib/angular-animate.min.js"></script>

        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">

               <!-- adicionando a classe painel-animado -->

                <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
                       <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Agora, alterando a main.js:

// public/js/main.js

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate']);
Pronto. Quando usamos o módulo ngAnimate, algumas diretivas do Angular passam a adicionar ou remover classes automaticamente sem a nossa ciência. São classes definidas pelo Angular, algo que lembra muito as pseudo classes do CSS3. Por exemplo, quando usamos a diretiva ng-repeat e um elemento sai da lista ele ganha a classe ng-leave, e quando está para sair ng-leave-active. Existem outras classes e nem todas as diretivas suportam as mesmas classes, sendo necessário recorrer à documentação do Angular. Sendo assim, podemos resolver nosso problema aumentado a especificidade do nosso seletor .painel-animado:

/* public/css/efeitos.css*/

.painel-animado.ng-leave-active {
  -moz-transform: scale(0.1);
  -webkit-transform: scale(0.1);
  -ms-transform: scale(0.1);
  -o-transform: scale(0.1);
  transform: scale(0.1);
}
Testando mais uma vez, nossa lista é exibida mas nenhuma animação é efetuada quando digitamos algo no filtro, isto porque não usamos o poderoso transition do CSS. Por mais que estejamos aprendendo Angular, trabalhar com o módulo ngAnimate requer que você conheça os poderosos recursos do CSS3, a única coisa que o Angular faz é aplicar ou remover determinadas classes. Para efetuar a transição fazemos:

/* public/css/efeitos.css*/

/* novidade! Ativa a transição no elemento. Agora, quando o transform for aplicado apenas para os elementos que estão saindo da lista, a escala será animada!*/

 .painel-animado {
    -moz-transition:transform 0.8s;
    -webkit-transition:transform 0.8s;
    -ms-transition:transform 0.8s;
    -o-transition:transform 0.8s;
    transition:transform 0.8s;
}

.painel-animado.ng-leave-active {
  -moz-transform: scale(0.1);
  -webkit-transform: scale(0.1);
  -ms-transform: scale(0.1);
  -o-transform: scale(0.1);
  transform: scale(0.1);
}
CUIDADO: não é para dar um espaço entre as classes .painel-animado e .ng-leave-active , caso contrário o seletor se tornará hierárquico e o efeito não vai funcionar. Os dois devem estar grudados! Se quiser saber mais sobre esse tipo de seletor o Alura possui treinamentos de CSS.
Maravilha! Agora nossa transição funciona perfeitamente, ou quase perfeita (para perceber, é necessário ver o vídeo, não é possível através da foto ilustrar o problema a seguir)!

O atraso pode ser a melhor opção!
Repare que nossa lista é filtrada a cada tecla que pressionamos e os elementos que não condizem com nosso filtro são animados e retirados da lista, mas a coisa é feita tão instantaneamente que o efeito deixa um pouco a desejar. Para resolvermos isso, precisamos realizar um pequeno atraso (delay) na entrada do usuário. Por exemplo, a cada dígito do usuário, vamos aguardar meio segundo (500ms) para que o framework atualize o valor de $scope.filtro e filtre nossa lista. Fazemos isso através da diretiva ng-model-options:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>

        <!-- importando o módulo ngAnimte -->

        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro" ng-model-options="{ debounce: 500 }">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
                      <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Agora sim! Há um pequeno atraso na atualização do valor de $scope.filtro, por conseguinte um atraso nos elementos que deixaram a lista, deixando nossa animação mais bacana.

Melhoramos ainda mais a experiência do usuário e com certeza, só temos a ganhar com isso!

O que aprendemos neste capítulo?
a diretiva ng-model e two-way data binding
aplicação de filtro na diretiva ng-repeat
ng-model-options e postergação do two-way data binding
animações com o módulo ngAnimate
animações requerem conhecimento sólido de CSS3


Seguem afirmativas sobre two-way data binding:
1) Permite ler dados (model) sem propagar atualizações desses dados a partir da view.

2) É realizado através de Angular Expression (AE)

3) É realizado pela combinação de Angular Expression (AE) e ng-model

4) É realizado através da diretiva ng-bind.

Podemos dizer que:

Todas são falsas
 
Perfeito! Diferente da Angular Expression (AE) que é somente leitura (one-way data binding), a diretiva ng-model permite ler e propagar alterações de dados a partir da view.

Qual a diferença entre a diretiva ng-model e Angular Expression (AE)?

O primeiro lê e grava no model, enquanto o segundo apenas lê.
 
A diretiva ng-model permite ler e também alterar o model associado (two-way data binding). É muito comum em telas de cadastro, onde precisamos capturar os dados do usuário para depois enviá-los numa requisição Ajax, por exemplo. Já a Angular Expression (AE) apenas lê o model (one-way data binding).

Veja o esboço de código HTML abaixo:
<label>
    <input type="search" ng-model="textoFiltro">
</label>

<ul>
    <li ng-repeat="funcionario in funcionarios">
        {{funcionario.nome}}
    </li>
</ul>
O que devemos colocar na diretiva ng-repeat para filtrar a lista de funcionários a partir do input, com base no valor de textoFiltro? Teste alguns códigos em busca da solução desse exemplo.

No final da diretiva ng-repeat devemos adicionar um | (o char pipe) seguido do nome do model: textoFiltro
<label>
    <input type="search" ng-model="textoFiltro">
</label>

<ul>
    <li ng-repeat="funcionario in funcionarios | filter: textoFiltro">
        {{funcionario.nome}}
    </li>
</ul>
Essa configuração fará com que a nossa lista seja filtrada dinamicamente com base no valor de textoFiltro. Poderoso e simples!

Quando usamos filter, todas as propriedades dos objetos são vasculhadas à procura do valor digitado. E se quisermos buscar apenas, por exemplo, pelo nome do funcionário? Podemos fazer essa forma:

ng-repeat="funcionario in funcionarios | filter: {nome: textoFiltro} "
Veja que agora iremos comparar o valor digitado apenas com a propriedade nome do objeto funcionario.

Simples e poderoso!

Temos as seguintes frases a respeito da diretiva ng-model-options:
1) Serve para postergar a atualização do modelo (dado).

2) Sua unidade de trabalho é em milissegundos, passada através da propriedade debounce.

3) Não pode ser usada sem a diretiva ng-model

4) Pode vir antes ou depois da diretiva ng-model sem problemas.

Todas as afirmativas são verdadeiras
 
Perfeito! Não faz sentido usarmos ng-model-options sem ng-model, já que a primeira passa opções especiais para a segunda. A diretiva ng-model-options pode ser usada para postergar a atualização do model, recebendo um objeto com a propriedade debounce com valor em milissegundos. A ordem de escrita não é importante.

No mundo CSS, não é incomum termos uma classe declarada que é ativada apenas quando algum elemento tiver essa classe. Geralmente, podemos adicionar e remover classes via JavaScript, o que permite a aplicação condicional do estilo. O Angular possui o módulo ngAnimate, que pode nos ajudar nessa tarefa. Sobre este módulo podemos afirmar que:
1) Quando carregado, faz com que algumas diretivas do core do Angular adicionem e removam classes dinamicamente. Porém, não temos controle das classes adicionadas e precisamos recorrer à documentação para ver aquelas que nos interessam.

2) Quando carregado, traz uma série de animações já prontas para uso.

3) Quando carregado, permite que apenas a diretiva ng-repeat adicione dinamicamente classes de acordo com o estado dos elementos.

4) É um módulo que não faz parte do core do Angular.

1 e 4 são verdadeiras
 
O módulo ngAnimate precisa ser carregado, uma vez que o módulo core angular.min.js não o carrega automaticamente. Este módulo, apesar do nome sugestivo, não traz qualquer animação pronta para uso, ele apenas habilita para uma série de diretivas a capacidade de adicionarem ou removerem classes de acordo com o estado de seus elementos. Fazendo uma analogia com CSS, é como se fossem pseudo classes.

Hora de praticar, implementando as novas funcionalidades apresentadas no capítulo. Como de costume, segue um resumo dos passos que devem ser executados:
1) Permita que o usuário filtre a lista digitando em um campo. Ele ficará imediatamente abaixo do jumbotron, como uma linha do grid do Bootstrap. Uma linha no grid do bootstrap é qualquer elemento container que tenha a classe row. Dúvida? Você pode consultar a explicação do capítulo e "colar" a estrutura, deixe para quebrar a cabeça com Angular apenas! Para filtrar, aplique um filter na diretiva ng-repeat, mas tome cuidado, pois tanto o campo de entrada quanto o valor de filter devem apontar para a mesma propriedade. A diferença é que o campo de entrada utilizará two-way data binding e a diretiva ng-repeat utilizará filter.

2) Agora que sua lista é filtrada, melhore ainda mais a experiência do usuário animando os elementos que são removidos da lista, aplicando uma espécie de fade, que na verdade realiza uma transição do tamanho atual do elemento para um tamanho menor. Para esta tarefa, você precisará do módulo ngAnimate que, para estar disponível, você precisa importar o script angular-animate.min.js, já disponibilizado na pasta public/js/lib. Não custa nada lembrá-lo de que você ainda precisará declarar o módulo ngAnimate como dependência do módulo principal alurapic.

3) Ter o módulo ngAnimate carregado não é suficiente. Você deve criar seus estilos CSS pegando carona nas classes adicionadas dinamicamente pelo Angular, quando este módulo está presente. Existem uma série de classes, porém foque na ng-leave-active. Como este é um treinamento de Angular e não de CSS, sinta-se livre para consultar o CSS na explicação do capítulo, inclusive para saber onde gravar o CSS e como adicioná-lo na marcação.

4) Agora que sua lista é filtrada e elementos removidos sofrem animações, repare que a cada dígito o two-way data binding do Angular atualiza em$scope a propriedade que guarda o que o usuário digitou através da diretiva ng-model. Podemos dar um tempo antes que ng-model atualize a propriedade em $scope, que é usada por ng-repeat para filtrar a lista. Usamos para isso a diretiva ng-model-options. Lembre-se que ela trabalha com milissegundos, sendo assim, postergue em meio segundo a atualização.

Mãos à obra!

Segue o index.html alterado com o campo que captura o termo que desejamos filtrar, digitado pelo usuário. Ele já possui as diretivas ng-model e ng-options-model, este último para realizar um delay da atualização de $scope.filtro:
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>

        <!-- importando o módulo ngAnimte -->

        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <!-- novidade, a row com o campo de busca -->
            <div class="row">
                <div class="col-md-12">
                <form>
                     <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro" ng-model-options="{ debounce: 500 }">
                </form>
                </div> <!-- fim col-md-12 -->
            </div> <!-- fim row -->

            <div class="row">
                <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
                      <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </meu-painel>
            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
O controller modificado, com a propriedade filtro. Na verdade, ela nem precisaria existir, porque o two-way data binding a criaria automaticamente caso não existisse. Foi adicionada para deixar claro o que o controller fornece e recebe da view.

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];
    $scope.filtro = '';

    $http.get('/v1/fotos')
    .success(function(retorno) {
        $scope.fotos = retorno;
    })
    .error(function(erro) {
        console.log(erro)
    });

});
Repare que o HTML anterior já importa um CSS. É o arquivo que contém nossos estilos usados pelo ngAnimate:

.painel-animado {
    -moz-transition:transform 0.8s;
    -webkit-transition:transform 0.8s;
    -ms-transition:transform 0.8s;
    -o-transition:transform 0.8s;
    transition:transform 0.8s;
}

.painel-animado.ng-leave-active {
  -moz-transform: scale(0.1);
  -webkit-transform: scale(0.1);
  -ms-transform: scale(0.1);
  -o-transform: scale(0.1);
  transform: scale(0.1);
}
Ainda no HTML da solução, veja que a diretiva meu-painel possui a classe painel-animado. Quando o elemento é removido da lista ele ganha ng-leave-active. Por isso no arquivo CSS temos o seletor .painel-animado.ng-leave-active, que significa: aplique o estilo apenas se o elemento tiver essas duas classes ao mesmo tempo.

É claro, para funcionar precisamos declarar o módulo ngAmimate como dependência do módulo alurapic:

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate']);

##### 6. Dividir para conquistar! #####

Desmistificando Single Page Applications
Agora que a nossa aplicação ficou mais atraente, permitiremos que o usuário cadastre e edite fotos. Nada mais justo do que criarmos uma página de cadastro exclusiva. Porém, o Angular tem como foco a criação de Single Page Applications (Aplicação de única página), aquele tipo de aplicação que não recarrega durante uso. Então, será que a solução é colocar o HTML da página de cadastro e de todas as outras dentro de index.html? Com certeza não, já demos um duro para tornar nossa página mais fácil de manter. Então que diabos é esse de "não recarrega a página durante seu uso"?

Então, realmente a página index.html não é recarregada, é a mesma durante todo o ciclo de vida da aplicação. Porém, é através de URL's especiais chamadas de rotas que o Angular busca a página desejada, inclusive ele já faz o trabalho de atualizar index.html automaticamente para nós com o conteúdo da página. É como se index.html fosse um template com uma única lacuna que recebe o conteúdo de outras páginas, mas uma por vez! Essas páginas não devem conter as tags head e body, pois serão inseridas dentro da página principal da aplicação que já os tem. É por isso que são chamadas de páginas parciais , ou partial pages, no inglês.

Nossas primeiras views parciais
Antes de avançarmos, vamos criar a parcial: public/partials/principal.html. Ela conterá a cópia da marcação que lista nossas fotos lá em index.html:

<!-- public/partials/principal.html -->

<div class="jumbotron">
    <h1 class="text-center">Alurapic</h1>
</div>

<div class="row">
    <div class="col-md-12">
    <form>
         <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro" ng-model-options="{ debounce: 500 }">
    </form>
    </div> <!-- fim col-md-12 -->
</div> <!-- fim row -->

<div class="row">
    <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
        <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
    </meu-painel>
</div>
Então, em index.html vamos substituir esta marcação pela diretiva ng-view. Vamos aproveitar e remover a diretiva ng-controller da tag body:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body>
        <div class="container">

            <!-- opa! abri uma mega lacuna! -->        
            <ng-view></ng-view>

        </div><!-- fim container -->
    </body>
</html>
O módulo ngRoute e configurações de rotas
Você não precisa ser um vidente para saber que, assim que abrirmos o endereço http://localhost:3000, veremos uma página em branco, porém já sabe que precisamos configurar as tais rotas do Angular.

Rotas são configuradas com auxílio do módulo ngRoute. Como sempre, isso envolve a importação de um script e adição do módulo como dependência do módulo principal da aplicação:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/lib/angular-animate.min.js"></script>

        <!-- Importando o script do módulo ngRoute -->

        <script src="js/lib/angular-route.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body>
        <div class="container">
            <ng-view></ng-view>
        </div><!-- fim container -->
    </body>
</html>
Agora, em main.js:

// public/js/main.js

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute']);
Pronto, agora que temos encaixadas as peças do quebra-cabeças, vamos às configurações! Bem, poderíamos até criar um módulo exclusivo com as configurações das rotas da aplicação, mas não é incomum essa configuração ser feita diretamente no módulo principal da aplicação através do serviço $routeProvider, que obtemos através do sistema de injeção de dependências do Angular, dentro da função config:

// public/js/main.js 

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider) {

    });
Usamos $routeProvider da seguinte maneira. Quando (when) o usuário acessar determinada rota, enviaremos para ele uma view parcial (templateUrl) e também indicamos qual é o controlador (controller) para aquela parcial. Definir o controller nos dá flexibilidade de usar uma mesma parcial com controllers diferentes:

// public/js/main.js 

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider) {

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

    });
Se abrirmos o endereço http://localhost:3000 nada será exibido, inclusive se tentarmos acessar http://localhost:3000/fotos. O Angular precisa de alguma maneira saber que o endereço que estamos tentando acessar não é um endereço do nosso servidor, mas uma de suas rotas. Fazemos isso adicionando um # (hash) antes da rota:

http://localhost:3000/#/fotos
Rotas ainda mais elegantes com Html5Mode
Agora sim! Nossa view parcial principal.html é exibida! Mas um olhar atento revela que essa URL é um tanto estranha, pela presença do #, mas esse é um subterfúgio muito utilizado para que seja possível favoritar em seu navegador a parcial, mas, ainda assim, quando alguém abrir o endereço, quem será carregada é a view principal index.html, que buscará a parcial através do sistema de rotas do Angular. Com o advento do HTML5 foi criada a History API, que permite conseguirmos o mesmo resultado, mas sem o uso do #. O Angular suporta a History API e podemos ativá-la através do serviço $locationProvider, que também podemos pedir através do sistema de injeção de dependências:

// public/js/main.js 

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider,  $locationProvider) {

       $locationProvider.html5Mode(true);

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

    });
Além dessa configuração, precisamos adicionar a tag <base href="/">:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <base href="/">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/lib/angular-route.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body>
        <div class="container">
            <ng-view></ng-view>
        </div><!-- fim container -->
    </body>
</html>
Agora, podemos remover o hash e acessar a URL diretamente:

http://localhost:3000/fotos
Outro ponto importante é que se o seu navegador não suportar este modo, automaticamente o Angular adotará a estratégia com # (hash).

ATENÇÃO: para usar html5Mode seu servidor precisa estar preparado. Esta configuração está fora do escopo deste treinamento e você deve consultar a documentação do seu servidor favorito.

Excelente, mas o que acontece se agora acessarmos um endereço que não existe? Nada será exibido, porém podemos indicar uma rota alternativa caso o endereço acessado pelo usuário não exista:

// public/js/main.js 

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider, $locationProvider) {

        $locationProvider.html5Mode(true);

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

        $routeProvider.otherwise({redirectTo: '/fotos'});

    });
Fantástico! Agora vamos criar a parcial do cadastro de fotos, apenas com um título e sua respectiva rota:

<!-- public/partials/foto.html -->
<h1>Cadastro</h1>
E agora vamos a rota /fotos/new, porém ainda sem definirmos um controller:

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider, $locationProvider) {

        $locationProvider.html5Mode(true);

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

       // foto no singular!

        $routeProvider.when('/fotos/new', {
            templateUrl: 'partials/foto.html'
        });

        $routeProvider.otherwise({redirectTo: '/fotos'});

    });
Agora, basta acessarmos:

http://localhost:3000/fotos/new
Agora sim! Temos duas parciais com responsabilidades diferentes.

O que aprendemos neste capítulo?
criação de parciais
a diretiva ng-view
o módulo ngRoute
$routeProvider e configurações de rota
rota padrão
hash
$LocationProvider e html5Mode

Sobre Single Page Applications (SPA), podemos afirmar:
1) Não recarrega durante seu uso.

2) Parciais (partials) são fragmentos de páginas que são carregados dinamicamente.

3) Ao trabalhar com SPA no Angular, indicamos onde serão carregadas as partials usando a diretiva <ng-view>.

4) Podemos usar Angular em uma aplicação que não seja SPA.

Das afirmações acima, podemos diz que:

Todas são verdadeiras
 
Angular tem como foco a criação de Single Page Applications (SPA's), porém seu uso não é exclusivo para este tipo de aplicação. Uma SPA é aquela aplicação que não recarrega durante seu uso. No caso do Angular, há um sistema de rotas que funciona no lado do cliente capaz de carregar do servidor fragmentos de páginas, chamadas de partials (parciais). Esses fragmentos são inseridos na página principal da aplicação.

Surpresa! Você aprendeu em um dos capítulos anteriores a criar a diretiva meuPainel. Para que seu conhecimento não caia em esquecimento , neste exercício você criará a diretiva minhaFoto, ela deve encapsular a seguinte marcação:
<img class="img-responsive center-block" src="{{url}}" alt="{{titulo}}">
Seu uso será:

<minha-foto url="{{foto.url}}" titulo="{{foto.titulo}}"></minha-foto>
Será que você consegue? Você pode consultar, o importante é que você crie essa diretiva do zero!

Bom exercício!

Alterando minhas-diretivas.js para encadear mais uma chamada à .directive:
// public/js/directives/minhas-diretivas.js

angular.module('minhasDiretivas', [])
    .directive('meuPainel', function() {

        // código omitido

    })
    .directive('minhaFoto', function() {

        var ddo = {};

        ddo.restrict = "AE";

        ddo.scope = {
            titulo: '@',
            url: '@'
        };

        ddo.template = '<img class="img-responsive center-block" src="{{url}}" alt="{{titulo}}">';           

        return ddo;

    });
Agora, usando nossa diretiva em index.html:

<!-- public/index.html -->

<meu-painel ng-repeat="foto in fotos" titulo="{{foto.titulo}}">
     <minha-foto url="{{foto.url}}" titulo="{{foto.titulo}}"></minha-foto>
</meu-painel>
Para saber mais: a diretiva ng-src
Muitas vezes, recebemos mensagens estranhas no console do navegador, principalmente quando usamos uma AE para o atributo src da tag img. Isso acontece porque o browser tem uma política agressiva no carregamento de imagens baixando-as antes que o Angular possa processar as AE. Se isso incomodá-lo, você pode usar a diretiva ng-src no lugar src. Com isso, apenas Angular processará a diretiva, inclusive só depois da AE ter sido avaliada.

Sua diretiva fica assim:

ddo.template = '<img class="img-responsive center-block" ng-src="{{url}}" alt="{{titulo}}">';

Sobre a configuração de rotas no lado do cliente Angular:
1) Precisamos importar o módulo ngRoute para que consigamos configurar rotas.

2) O artefato $routeProvider é um artefato injetável dependente do carregamento do módulo de rotas.

3) Rotas podem ser configuradas sem a necessidade de pertencerem a um módulo.

4) Para configurarmos uma rota, precisamos fornecer no mínimo o nome da rota e qual parcial será carregada.

Sobre as afirmativas anteriores, podemos dizer que:

1, 2 e 4 são verdadeiras
 
Para que configuremos rotas, o módulo ngRoute precisa estar carregado, isso significa que precisamos importar o script do módulo e adicioná-lo como dependência de algum módulo que realizará a configuração de rotas. É através da função .config que configuramos rotas, solicitando através de injeção $routeProvider. O artefato $routeProvider só estará disponível para injeção se o módulo ngRoute tiver sido carregado previamente. Podemos usar a função .when do $routeProvider para configurar efetivamente uma rota. Ela recebe um nome, e um objeto contendo, o controller que será associado (pode ser omitido) e o caminho para a parcial que será carregada.

Pode ser que o usuário queira ele mesmo digitar uma rota específica do Angular na barra de endereços do navegador e acabe errando. Nesse caso, podemos redirecionar o usuário para uma rota conhecida.
Qual das opções realiza esse redirecionamento corretamente?

 angular.module('controle', ['ngRoute'])
    .config(function($routeProvider) {

        $routeProvider.when('/produtos', {
            templateUrl: 'partials/produtos.html',
            controller: 'ProdutosController'
        });

        $routeProvider.otherwise({redirectTo: '/produtos'});

    });
 
Precisamos de um módulo que tem como dependência o módulo ngRoute, sem o qual não seria possível recebermos via injeção $routeProvider. É através de $routeProvider.otherwise que realizamos um redirecionamento, passando um objeto com a propriedade redirectTo, que tem como valor uma rota existente do Angular.

Temos a seguinte configuração de rota:
angular.module('controle', ['ngRoute'])
    .config(function($routeProvider) {

        $routeProvider.when('/produtos', {
            templateUrl: 'partials/produtos.html',
            controller: 'ProdutosController'
        });

        $routeProvider.otherwise({redirectTo: '/produtos'});

    });
Para habilitarmos o sistema de rotas no modo html5Mode sabemos que é necessária a diretiva <base href="/"> dentro da tag <head> da view principal da aplicação, porém isso não é suficiente.

Altere o código anterior habilitando o módulo HTML5.

Para resolver esse exercício você poderia ter escrito o seguinte código:
angular.module('controle', ['ngRoute'])
    .config(function($routeProvider, $locationProvider) {

       // habilitando
       $locationProvider.html5Mode(true);

        $routeProvider.when('/produtos', {
            templateUrl: 'partials/produtos.html',
            controller: 'ProdutosController'
        });

        $routeProvider.otherwise({redirectTo: '/produtos'});

    });
Precisamos do artefato $locationProvider para habilitarmos o html5Mode. É através dele que habilitamos este modo.

Hora de praticar implementando as novas funcionalidades apresentadas no capítulo. Como de costume, segue um resumo dos passos que devem ser executados:
1) Por mais que o Angular seja feito para criação de SPA's, não faz sentido colocar tudo numa única view, principalmente se o escopo do seu sistema for grande. O primeiro passo é extrair todo o conteúdo da tag body de index.html para um arquivo em separado. Adote a convenção de que todas as views parciais ficarão dentro de public/partials (em inglês). Para o conteúdo extraído, o nome da view será principal.html. Não esqueça que uma view parcial não possui as tag's head nem body. As dicas não foram suficientes? Você pode recorrer sempre à explicação do capítulo, mas encare o desafio!

2) Com a parcial principal.html criada, abra uma lacuna em index.html usando a diretiva do sistema de rotas do Angular. Ainda lembra seu nome? Ela é muito importante, porque todo o conteúdo das parciais serão "jogadas" para dentro dela. Porém, vale frisar que apenas uma parcial por vez pode ser exibida.

3) Neste ponto você tem a parcial criada e a lacuna na view index.html . Chegou a hora de habilitar o sistema de rotas na aplicação (ainda não configure as rotas). Lembre-se que dois passos são necessários: importar o script do módulo de rotas e declará-lo como dependência no módulo alurapic. Dica: o nome do módulo é ngRoute.

4) Muito bem! O Angular não fez curso de adivinhação para saber como exibir suas views parciais. Podem existir zilhões delas em seu projeto e no mundo Web navegamos entre páginas através de links que acessam URL's. A questão é que essas URL's não podem ser URL's acessadas diretamente do nosso servidor, caso contrário as parciais seriam baixadas diretamente, a página seria recarregada (matando a SPA, que nunca recarrega sua página durante uso) e pior: como a parcial não tem head nem body, ela não seria exibida corretamente. Para resolver esse problema, podemos registrar URL's de 'mentirinha' no sistema de rotas do Angular. Essas URL's não acessam um recurso diretamente no servidor, elas são processadas no lado do cliente através do Angular, que traduz aquela URL em uma chamada Ajax que carrega a parcial para aquela URL. Como é o Angular que faz esse processo, ele se encarrega de incluir a parcial dentro da diretiva ng-view em index.html. Configure duas rotas (você precisará injetar um artefato do angular responsável por isso, lembra?): a primeira com o endereço /fotos, associada com controller FotosController. Não esqueça também de indicar qual template será carregado (parcial). A segunda rota é aquele disparada quando o usuário acessar uma rota que não existe, que por sua vez redirecionará o usuário para /fotos.

5) Faça um teste. Acesse a URL localhost:3000/#/fotos ou localhost:3000/index.html#/fotos. Repare que o conteúdo de index.html é trocado pelo conteúdo da parcial. Não funcionou? Reveja seus passos e consulte a explicação do capítulo para verificar se deixou alguma coisa de fora das configurações.

6) Habilite o HTML5MODE no sistema de rotas e faça um teste sem usar o hash, por exemplo, acessando localhost:3000/fotos. Só não esqueça de adicionar o base em index.html, caso contrário a rota não funcionará.

A solução (não segue necessariamente os passos sugeridos):
A página index.html importando o módulo de rotas do Angular, com a diretiva ng-view e base:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <base href="/">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/lib/angular-route.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body>
        <div class="container">
            <ng-view></ng-view>
        </div><!-- fim container -->
    </body>
</html>
A parcial principal.html, que agora contém o conteúdo que fazia parte de index.html:

<!-- public/partials/principal.html -->

<div class="jumbotron">
    <h1 class="text-center">Alurapic</h1>
</div>

<div class="row">
    <div class="col-md-12">
    <form>
         <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro" ng-model-options="{ debounce: 500 }">
    </form>
    </div> <!-- fim col-md-12 -->
</div> <!-- fim row -->

<div class="row">
    <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
        <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
    </meu-painel>
</div>
O módulo principal da aplicação importando o módulo ngRoute e configurando as rotas, mas ativando o módulo HTML5:

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider, $locationProvider) {

        $locationProvider.html5Mode(true);

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

       // foto no singular!

        $routeProvider.when('/fotos/new', {
            templateUrl: 'partials/foto.html'
        });

        $routeProvider.otherwise({redirectTo: '/fotos'});

    });

##### 7. Precisamos alimentar esse sistema #####

Não podemos postergar ainda mais, precisamos concluir o cadastro de novas fotos! Sabemos que a rota do Angular localhost:3000/fotos/new exibirá a view, mas não é nada elegante pedir que o usuário digite esse endereço toda vez quando for cadastrar uma foto, não?

Navegando entre views
Podemos melhorar sua experiência adicionando um link que, ao ser clicado na parcial principal.html, chamará nossa rota que exibirá nossa tela de cadastro.

Vamos editar public/partials/principal.html para adicionarmos um link que terá um visual de botão graças ao Bootstrap:

<!-- public/partials/principal.html -->

<div class="jumbotron">
    <h1 class="text-center">Alurapic</h1>
</div>

<div class="row">
    <div class="col-md-12">
        <form>

            <!-- Novidade! -->

             <div class="input-group">
                <span class="input-group-btn">
                    <a href="/fotos/new" class="btn btn-primary" type="button">
                        Nova foto
                    </a>
                </span>
                <input class="form-control" placeholder="filtrar pelo título da foto" ng-model="filtro" ng-model-options="{ debounce: 500 }">
            </div> 

            <!-- fim novidade! -->

        </form>
    </div> <!-- fim col-md-12 -->
</div> <!-- fim row -->

<div class="row">
    <meu-painel class="col-md-2 painel-animado" ng-repeat="foto in fotos | filter: filtro" titulo="{{foto.titulo}}">
        <minha-foto url="{{foto.url}}" titulo="{{foto.titulo}}">
        </minha-foto>
    </meu-painel>
</div>
Botão novo

Agrupamos nosso botão e nosso campo de pesquisa dentro de um input-group do Bootstrap, inclusive nosso botão decora o campo de pesquisa com a classe input-group-btn.

Repare também que nosso botão, na verdade um link, aponta para o endereço /fotos/new, justamente a rota que já temos registrada. Agora que já conseguimos navegar entre as parciais principal.html e foto.html, podemos atacar a marcação desta última.

Nossa primeira view de cadastro
Vamos criar nosso formulário de cadastro, mas ainda sem nos preocuparmos com expressões do Angular, inclusive já vamos adicionar os botões "salvar" e "voltar":

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>TITULO DA FOTO AQUI</h1>
</div>

<form name="formulario" class="row">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control">    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control">
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Excelente, já podemos verificar o resultado!

Esboço cadastro de fotos

Queremos agora que cada input do nosso formulário alimente as propriedades de um objeto foto sem qualquer informação. Vamos adicionar a já conhecida diretiva ng-model para cada um dos inputs. No título da página, usaremos uma AE:

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form name="formulario" class="row">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" ng-model="foto.titulo">    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" ng-model="foto.url">
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Quando recarregamos nossa página, o título some e o formulário ainda é exibido. Lembre-se que uma AE não avaliada não resulta em erro, mas apenas na ausência de valor no local onde é utilizada. A mesma coisa acontece com a diretiva ng-model.

Agora que já temos o "esqueleto" da nossa tela de cadastro, precisamos de um controller que nos dê suporte para a operação de cadastro. Vamos criar o arquivo public/js/controllers/foto-controller.js e definir o controller FotoController (no singular), importando-o logo em seguida na view principal da aplicação public/index.html:

// public/js/controllers/foto-controller.js
angular.module('alurapic')
    .controller('FotoController', function($scope) {

        $scope.foto = {};

    });
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <base href="/">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <link rel="stylesheet" href="css/efeitos.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/lib/angular-animate.min.js"></script>
        <script src="js/lib/angular-route.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>

        <!-- importando o novo controller -->

        <script src="js/controllers/foto-controller.js"></script>
        <script src="js/directives/minhas-diretivas.js"></script>
    </head>
    <body>
        <div class="container">
            <ng-view></ng-view>
        </div><!-- fim container -->
    </body>
</html>
Veja que não importamos o novo script como último script. Por uma questão de organização apenas, ele foi importado imediatamente após o controller já existente.

Vamos voltar nossa atenção para FotoController. Veja que $scope disponibiliza a propriedade foto, um objeto JavaScript, porém sem qualquer propriedade. Não se preocupe, como estamos usando a diretiva ng-model, a propriedade indicada será criada automaticamente no objeto, sendo assim, se usamos ng-model="foto.titulo", o Angular criará automaticamente em $scope.foto a propriedade titulo, inclusive atribuindo o valor digitado pelo usuário.

Preparando o terreno para cadastrarmos novas fotos
O que precisamos agora é implementar o botão salvar. O que ele deve fazer? Submeter o formulário, claro, mas precisamos acessar $scope.foto no momento da submissão para que possamos enviar os dados assincronamente através do serviço $http. JavaScript possui o evento submit justamente para isso.

O evento submit é disparado quando um formulário é submetido e nele podemos adicionar uma função que permite a execução de um código arbitrário que pode cancelar sua submissão caso haja algum problema, como o de um campo que não foi preenchido. Mas estamos usando Angular, e agora? Como interagir com a interface de eventos do JavaScript?

O Angular suporta a interface de eventos do JavaScript através de diretivas. Por exemplo, se quisermos o evento click, usamos a diretiva ng-click, o evento mouseouver, a diretiva ng-mouseover e assim por diante. Sendo assim, para lidarmos com o evento submit disparado pelo formulário adicionamos a diretiva ng-submit diretamente na tag form:

<!-- public/partials/foto.html -->

<!-- código anterior omitido -->

<form name="formulario" class="row" ng-submit="submeter()">

<!-- código posterior omitido -->
Note que o valor da diretiva ng-submit chama uma função que deve ser definida na propriedade $scope.submeter. Vamos adicioná-la em nosso controller, porém exibiremos apenas os dados da foto no console do navegador:

// public/js/controllers/foto-controller.js

angular.module('alurapic')
    .controller('FotoController', function($scope) {

        $scope.foto = {};

        $scope.submeter = function() {
            console.log($scope.foto);
        };

    });
Se testarmos nosso código, nada acontecerá, por quê? O motivo é simples: não associamos FotoController à view parcial foto.html. Lembram onde realizamos essa associação? Na configuração de rotas! Vamos editar o arquivo public/js/main.js para adicionarmos a chave controller que faltava para a foto /fotos/new:

// public/js/main.js

angular.module('alurapic', ['minhasDiretivas', 'ngAnimate', 'ngRoute'])
    .config(function($routeProvider, $locationProvider) {

        $locationProvider.html5Mode(true);

        $routeProvider.when('/fotos', {
            templateUrl: 'partials/principal.html',
            controller: 'FotosController'
        });

        // adicionando a propriedade controller que faltava. 

        $routeProvider.when('/fotos/new', {
            templateUrl: 'partials/foto.html',
            controller: 'FotoController'
        });

        $routeProvider.otherwise({redirectTo: '/fotos'});

    });
Agora já podemos recarregar nossa página, clicar no botão nova foto, preencher alguma informação e clicar no botão salvar. Para vermos os dados da foto, precisamos abrir o console do navegador com F12 (CMD + SHIFT + C, no MAC):

Exibindo dados da foto no console

Funciona! Agora só nos resta enviar os dados capturados para uma rota back-end especializada nesta tarefa, usando o serviço $http. Porém, não é incomum validarmos os dados do usuário verificando a obrigatoriedade de algum campo ou aplicando alguma regra mais específica de validação. Em nossa aplicação não será diferente e faremos isso através do Angular.

Quando queremos que o Angular tome conta da validação do formulário para nós, precisamos abdicar do sistema de validação do HTML5. Apesar de extremamente funcional, ele não se integra perfeitamente com o Angular e não é tão flexível quanto este último.

Para desabilitar a validação do HTML5, adicionamos o atributo novalidate na tag form:

<!-- public/partials/foto.html -->
<!-- código anterior omitido -->

<form novalidate name="formulario" class="row" ng-submit="submeter()">

<!-- código posterior omitido -->
Pronto, agora vamos tornar todos os campos do nosso formulário obrigatórios, exceto o campo de descrição. Fazemos isso adicionando o mesmo atributo que é usado no HTML5, o atributo required:

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required>    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Desligamos a validação do HTML, mas se deixarmos o título em branco e clicarmos em salvar, já teríamos que receber uma mensagem e não recebemos. Diferente do HTML, que já existe uma mensagem por padrão, o Angular precisa que você defina essa mensagem. A vantagem é que temos a flexibilidade de exibir mensagens de validação da forma que desejarmos.

Vamos adicionar, imediatamente após o campo título do nosso formulário, uma tag span com as classes form-control alert-danger

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required>

            <!-- novidade -->

            <span class="form-control alert-danger">
                Título obrigatório
            </span>    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Ainda não funciona conforme esperado, porque se recarregarmos a página a mensagem de erro será exibida. Para que funcione, sua exibição deve ser condicional. Algo do tipo se o campo titulo é inválido, exiba a tag span. O Angular possui a diretiva ng-show, que permite a exibição condicional de elementos da tela. Quando seu valor é true, o elemento no qual a diretiva está aplicada é exibida, caso contrário não é exibido.

A questão toda é: quem fornecerá o valor da diretiva ng-show? A resposta mora em um objeto criado implicitamente que representa nosso formulário. Qual o nome deste objeto? Seu nome é o valor do atributo name do formulário, em nosso caso, formulario. É através dele que temos acesso a todos os campos do formulário, contanto que cada um deles também tenham definido um valor para o atributo name. Sendo assim, podemos fazer para o campo título:

// apenas exemplo, não entra em nenhum lugar por enquanto

ng-show = "formulario.titulo.$error.required"
Acessamos formulario.titulo.$error, que nos dá acesso à interface de erros do Angular. Como queremos saber o status da validação required, usamos formulario.titulo.$error.required:

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required>

            <!-- novidade -->

            <span ng-show = "formulario.titulo.$error.required" 
                class="form-control alert-danger">
                Título obrigatório
            </span>    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Validação

Hum, nosso formulário já exibe a mensagem de validação assim que é recarregado. Está certo? Depende do que desejamos. Se queremos exibir mensagens de erro sempre que um campo do formulário estiver errado, está certo. Porém, se quisermos validar os campos apenas quando o formulário for submetido, não. Aliás, vamos alterar o valor da diretiva ng-show para exibir a mensagem de erro de validação apenas quando o formulário for submetido. Basta adicionarmos mais uma condição, a formulario.$submitted que retorna verdadeiro apenas se o formulário foi submetido.

<!-- public/partials/foto.html -->
<!-- código anterior omitido -->

  <span ng-show = "formulario.$submitted && formulario.titulo.$error.required" 
                class="form-control alert-danger">
                Título obrigatório
  </span>    
<!-- código posterior omitido -->
Veja que agora ng-show só exibirá o elemento se as duas condições forem verdadeiras: o formulário for submetido e o campo inválido. Agora, ao recarregar a página, nosso formulário só será validado quando salvarmos o formulário, ação que disparará sua submissão.

Vamos deixar agora campo URL obrigatório e também preparar a mensagem de erro:

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required>
            <span ng-show = "formulario.$submitted && formulario.titulo.$error.required" 
                class="form-control alert-danger">
                Título obrigatório
            </span>    
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>

             <!-- novidade -->

            <span ng-show = "formulario.$submitted && formulario.url.$error.required" 
                class="form-control alert-danger">
                URL obrigatória
            </span> 
        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Excelente, mas o Angular permite fazer mais do que simplesmente considerar a obrigatoriedade de um campo. Existem diretivas específicas para validação. Por exemplo, vamos estipular que o campo título não pode passar de 20 caracteres através da diretiva ng-maxlength.

<!-- public/partials/foto.html -->

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required
                ng-maxlength="20">
            <span ng-show = "formulario.$submitted && formulario.titulo.$error.required" 
                class="form-control alert-danger">
                Título obrigatório
            </span> 
            <span ng-show="formulario.$submitted && formulario.titulo.$error.maxlength" class="form-control alert-danger">
                No máximo 20 caracteres!
            </span>   
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>

            <span ng-show = "formulario.$submitted && formulario.url.$error.required" 
                class="form-control alert-danger">
                URL obrigatória
            </span> 

        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto></minha-foto>
    </div>
</form>
Vamos aproveitar e fazer o data binding da URL da foto com nossa diretiva minha-foto:

<!-- public/partials/foto.html -->
<!-- código anterior omitido -->

<div class="col-md-6">
         <minha-foto url="{{foto.url}}" titulo="{{foto.titulo}}">
        </minha-foto>
    </div>
</form>
Agora vamos testar nossa validação. Vamos aproveitar e digitar uma URL válida, isso fará com que nossa diretiva minha-foto exibe a foto instantaneamente:

Testando validação

Perfeito! Agora já podemos alterar a função $scope.submeter e utilizar o serviço $http para gravar nosso produto. Como já dizemos, pedimos $http ao serviço de injeção de dependências do Angular. Como queremos enviar os dados, usamos $http.post, que recebe dois parâmetros. O primeiro é a URL do nosso server, /v1/fotos, e como segundo os dados que serão enviados, no caso, $scope.fotos. O restante é igual já fizemos:

// public/js/controllers/foto-controller.js

angular.module('alurapic')
    .controller('FotoController', function($scope, $http) {

        $scope.foto = {};

        $scope.submeter = function() {

            $http.post('/v1/fotos', $scope.foto)
            .success(function() {
                console.log('Foto adicionada com sucesso');
            })
            .error(function(erro) {
                console.log('Não foi possível cadastrar a foto');
            })
        };

    });
Já podemos testar. Quando digitarmos dados válidos e clicamos em salvar, nosso formulário continua preenchido e nem sequer recebemos uma mensagem de sucesso! Bom, atacaremos isso em breve, mas se as informações foram enviadas e salvas, basta clicarmos no botão voltar e verificarmos se nossa foto aparece na lista, e realmente aparece!

Lista atualizada

Muito perfeito! Mas se clicarmos no botão salvar com dados inválidos? Por exemplo, com o tamanho do título sendo maior do que 20 caracteres e deixando o campo URL em branco? O resultado será este:

Gravação indevida

"Oh my god!", os dados inválidos do nosso formulário foram submetidos e uma foto cadastrada indevidamente. Mas por que o nome ficou em branco? Isso porque dados consideramos inválidos pelo Angular não são aplicados do formulário para o atributo relacionado em $scope. Então, no momento do envio dos dados, $scope.foto.titulo ficou vazio.

Para resolver isso, basta consultarmos em nosso $scope o status do formulário com a sintaxe $scope.formulario.$valid. Isso mesmo, através de $scope podemos acessar nosso formulário através do seu name e perguntarmos se ele é válido consultando a propriedade $valid.

Alterando nosso FotoController:

// public/js/controllers/foto-controller.js

angular.module('alurapic')
    .controller('FotoController', function($scope, $http) {

        $scope.foto = {};

        $scope.submeter = function() {

            if ($scope.formulario.$valid) {

                $http.post('/v1/fotos', $scope.foto)
                .success(function() {
                    console.log('Foto adicionada com sucesso');
                })
                .error(function(erro) {
                    console.log('Não foi possível cadastra a foto');
                })
            }
        };

    });
Agora, nossa lógica de envio das informações só será executada caso o formulário seja válido. Antes de testarmos, podemos melhorar ainda mais a experiência do usuário habilitando a exibição do botão salvar apenas se o formulário estiver válido.

<!-- public/partials/foto.html -->

<!-- código anterior omitido -->
 <button type="submit" class="btn btn-primary" ng-disabled="formulario.$invalid">
            Salvar
</button>
<!-- código posterior omitido -->
A cada interação do usuário com nosso formulário, a diretiva ng-disabled consultará o status do formulário para saber se ele é invalido, caso seja, o botão ficará desabilitado:

Botão desabilitado

Agora, para deixar ainda melhor nosso formulário, vamos exibir uma mensagem de fracasso ou sucesso para indicar o status da operação com o servidor. Inclusive vamos limpar os dados do formulário quando a operação for bem sucedida. Vamos adicionar um parágrafo que consultará $scope.mensagem. O parágrafo só será exibido se exibir alguma mensagem:

<div class="page-header text-center">
    <h1>{{foto.titulo}}</h1>
</div>

<!-- novidade! Aqui será exibida mensagens para o usuário -->

<p ng-show="mensagem.length" class="alert alert-info">{{mensagem}}</p>

<form novalidate name="formulario" class="row" ng-submit="submeter()">
    <div class="col-md-6">
        <div class="form-group">
            <label>Título</label>
            <input name="titulo" class="form-control" 
                ng-model="foto.titulo" required
                ng-maxlength="20">
            <span ng-show = "formulario.$submitted && formulario.titulo.$error.required" 
                class="form-control alert-danger">
                Título obrigatório
            </span> 
            <span ng-show="formulario.$submitted && formulario.titulo.$error.maxlength" class="form-control alert-danger">
                No máximo 20 caracteres!
            </span>   
        </div>
        <div class="form-group">
            <label>URL</label>
            <input name="url" class="form-control" 
            ng-model="foto.url" required>

            <span ng-show = "formulario.$submitted && formulario.url.$error.required" 
                class="form-control alert-danger">
                URL obrigatória
            </span> 

        </div>
        <div class="form-group">
            <label>Descrição</label>
            <textarea name="descricao" class="form-control" ng-model="foto.descricao">
            </textarea>
        </div>

        <button type="submit" class="btn btn-primary" ng-disabled="formulario.$invalid">
            Salvar
        </button>
         <a href="/" class="btn btn-primary">Voltar</a>
        <hr>
    </div>
    <div class="col-md-6">
        <minha-foto url="{{foto.url}}" titulo="{{foto.titulo}}">
        </minha-foto>
    </div>
</form>
Agora, alterando nosso controller para popular a $scope.mensagem:

// public/js/controllers/foto-controller.js

angular.module('alurapic')
    .controller('FotoController', function($scope, $http) {

        $scope.foto = {};
        $scope.mensagem = '';

        $scope.submeter = function() {

            if ($scope.formulario.$valid) {

                $http.post('/v1/fotos', $scope.foto)
                .success(function() {
                    $scope.mensagem = 'Foto cadastrada com sucesso';
                })
                .error(function(erro) {
                    console.log(erro);
                    $scope.mensagem = 'Não foi possível cadastrar a foto';
                })
            }
        };

    });
Muito bem, agora basta cadastrarmos uma nova foto e verificar a exibição da nossa mensagem:

Aviso informativo para o usuário

Quase lá! Precisamos limpar o formulário quando a mensagem for adicionada com sucesso. Basta atribuirmos um objeto vazio à $scope.foto:

angular.module('alurapic')
    .controller('FotoController', function($scope, $http) {

        $scope.foto = {};
        $scope.mensagem = '';

        $scope.submeter = function() {

            if ($scope.formulario.$valid) {

                $http.post('/v1/fotos', $scope.foto)
                .success(function() {
                    $scope.foto = {};
                    $scope.mensagem = 'Foto cadastrada com sucesso';
                })
                .error(function(erro) {
                    console.log(erro);
                    $scope.mensagem = 'Não foi possível cadastrar a foto';
                })
            }
        };

    });
Agora, para cada foto cadastrada com sucesso, o formulário será limpo automaticamente, tudo por causa do data binding do Angular.

O que aprendemos neste capítulo?
navegação entre views
a diretiva ng-submit e a interface de eventos do Angular
executar uma ação no controller através de ações do usuário
validação de formulário com Angular
envio de dados para o servidor com $http.post
mensagens de aviso para o usuário





