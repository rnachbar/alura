##### 1. Testando seus conhecimentos #####

Quando desenvolvemos no server-side, organizamos nosso código em camadas para facilitar a manutenção, o reaproveitamento e a legibilidade de nosso código. É muito comum aplicarmos o modelo MVC (Model, View, Controller), que consiste na separação de tarefas, facilitando assim a reescrita de alguma parte e a manutenção do código.

Porém, não é raro o mesmo desenvolvedor deixar de lado essas práticas quando codifica no client-side. Mesmo aqueles que procuram organizar melhor seu código acabam criando soluções caseiras que nem sempre são bem documentadas.

Tendo como base este cenário, frameworks MVC client-side foram criados. Entre eles temos o Backbone, Ember, Knockout, CanJS, Batman, entre outros.

Angular, o framework MVC da Google
Um framework MVC no lado do cliente que tem ganhado muita atenção da comunidade é o Angular. Criado como um projeto interno da Google e liberado para o público em 2009, ele tem como foco a criação de Single Page Applications (SPA’s). Este tipo de aplicação não recarrega a página durante seu uso, dando uma experiência mais fluída para o usuário. Não se preocupe se você é novo para este tipo de aplicação, você terá a oportunidade de entender melhor seus conceitos ao longo do treinamento.

Conhecendo um pouco da nossa aplicação, o Alurapic
Durante o treinamento construiremos a aplicação Alurapic, um sistema simples de gerenciamento de imagens, permitindo que o usuário busque por aquelas que seguem determinado critério. Mas não se engane: o domínio do problema, apesar de simples, será suficiente para empregarmos grande parte do "arsenal" que o Angular nos fornece, inclusive toda aplicação funcionará em cima de um servidor web já preparado.

Preview da aplicação

Preview da aplicação

Preview da aplicação

Instalando e configurando toda infra necessária
Agora que você já conhece um pouco sobre a aplicação que construiremos, saiba que alguns recursos do Angular dependem de um servidor web para funcionarem, em nosso caso, um servidor local. A boa notícia é que já disponibilizamos um para você, livrando-o dos seus detalhes de configuração. Inclusive ele fará persistência de dados sem que você tenha que instalar um banco de dados específico para isso. Porém, para tudo funcionar, você precisa ter instalado o Node.js.

O arquivo do projeto, o tutorial de instalação do Node.js e as instruções de como levantar o servidor estão no primeiro exercício deste capítulo. Esta é uma boa hora de fazê-lo antes de continuar. Vamos assumir a partir deste ponto que você realizou este primeiro exercício.

Por onde começar?
Angular é um framework que roda no lado do cliente, sendo assim, como qualquer outro script, deve ser importado na página que desejamos eleger como principal da aplicação, em nosso caso, a página já existente, index.html, que está salva dentro da pasta alurapic/public (não sabe que pasta é essa? Você fez o primeiro exercício do capítulo conforme solicitado?). Primeiramente vamos dar uma olhada em sua estrutura:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que a página já importa o CSS do Bootstrap. Se você ainda não o conhece, fique sabendo que ele permite aplicar um visual profissional em nosso projeto, com zero de esforço, apenas adicionando classes declaradas em seu arquivo CSS. Que classes são essas? Muita calma nessa hora! Elas serão introduzidas à medida que formos evoluindo nossa aplicação, mas já podemos adiantar que a classe container centraliza todo conteúdo da página e a text-center centraliza um elemento do tipo block, em nosso caso, a tag h1.

Agora que você já entendeu o papel do Bootstrap em nosso projeto, já podemos continuar. Todas as páginas, bibliotecas, scripts e qualquer outro arquivo dentro da pasta alurapic/public serão acessíveis através do seu navegador, inclusive já temos dentro da pasta alurapic/public/js/lib todos os arquivos do Angular que importaremos à medida que formos precisando. Vamos importar o script angular.min.js, o core do Angular dentro da tag head:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, mas ainda não escrevemos um código que utiliza o Angular! Para fazermos isso, primeiro precisamos criar um módulo.

Criando o alicerce da nossa aplicação, o módulo principal
A história é a seguinte: o framework nos ajuda a separar nosso código em pequenos grupos de código que podem ser combinados e reaproveitados quando necessário, esses grupos são chamados de módulos. Uma aplicação pode ter um, dez ou até mesmo mais de cinquenta módulos, tudo dependerá da complexidade da aplicação. Porém, há sempre um módulo que é o primeiro a ser inicializado assim que sua página é carregada pela primeira vez, inclusive ele também é o responsável pelo carregamento de outros módulos de que sua aplicação precisa para funcionar. É este que criaremos agora!

Vamos criar o arquivo public/js/main.js e mesmo sem escrever qualquer linha de código, vamos importá-lo sem demora na página index.html, abaixo da importação do core do Angular, para não corrermos o risco de esquecermos de importá-lo:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, e agora? Como criamos nosso módulo? Bem, o Angular disponibiliza para nós no escopo global o objeto angular (nada criativo, não?) que possui uma série de funções que nos permite interagir com o framework, entre elas a função module responsável pela criação de módulos.

Você deve estar pensando "Ok, entendi que é através desse objeto global que eu crio módulos e um monte de coisas do framework, mas escopo global não é algo ruim?". Preocupação justa, mas não se preocupe! Em uma aplicação bem-feita em Angular, este é o único objeto disponível globalmente, todo restante fica confinado dentro dos módulos do Angular! Com o tempo isso ficará ainda mais claro para você.

Criando o módulo principal da aplicação:

// public/js/main.js

angular.module('alurapic', []);
Acabamos de criar nosso primeiro módulo. Perceba que a função module recebe dois parâmetros. O primeiro é o nome do módulo que desejamos criar e o segundo é uma array com todos os módulos de que nosso módulo depende. Como não avançamos ainda com o projeto, não temos nenhuma dependência ainda, porém, você não deve omitir este parâmetro. Mais tarde você entenderá o que acontece quando ele é omitido (suspense!).

Ensinando um truque novo para o navegador
Tudo certo, criamos nosso módulo, mas como o Angular saberá que deve carregá-lo? Será que importar o script public/js/main.js é suficiente? Com certeza não.

Precisamos indicar em nossa página qual será o escopo de atuação do Angular, isto é, se ele gerenciará a página inteira ou apenas parte dela. Isso é importante, porque outro framework MVC pode estar sendo utilizado (algo raro, porém pode acontecer) e não queremos que o Angular bagunce seu trabalho.

Como apenas utilizaremos o Angular, gerenciaremos a página inteira, isto, a tag html e todos seus elementos filhos! Tudo bem, mas como faremos essa associação? Através do atributo ng-app:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que o atributo ng-app tem como valor o nome do nosso módulo e não poderia ser diferente. Quando nossa página é carregada pela primeira vez o Angular encontrará esse atributo e carregará o módulo alurapic, tudo isso automaticamente, sem termos que nos preocupar em carregá-lo! É claro que se você esquecer de importar o arquivo main.js o Angular não será capaz de carregar o módulo, certo?

Ah, então isso é uma diretiva?
Agora, só uma coisa antes de continuarmos: o atributo ng-app existe no mundo HTML? Com certeza não, ele não faz parte da especificação da W3C. O "atributo" ng-app é na verdade uma diretiva do Angular.

Diretivas ampliam o vocabulário do navegador, ensinando-o novos truques, inclusive aprenderemos a criar nossas próprias diretivas ao longo do treinamento! Nesse caso a diretiva ng-app fornece a capacidade de nossa página carregar/iniciar o módulo principal da aplicação. Aliás, não vamos mais usar o termo página, usaremos view, termo mais correto quando estamos no universo do Angular!

Nossa primeira página dinâmica
Legal, agora, com o servidor iniciado (não lembra como iniciá-lo? Veja o primeiro exercício do capítulo) vamos acessar o endereço http://localhost:3000 e verificar o resultado. Como esperado, nada impressionante, pois apenas preparamos a infraestrutura mínima de uma aplicação em Angular, que nada faz. No máximo, podemos ver através do console do navegador (eu uso Chrome, e você?) todos os arquivos carregados:

arquivos carregados

Bom, vamos começar a dar um colorido para nossa view index.html. Vamos adicionar uma foto, você pode escolher a URL de uma específica, não precisa ser igual a minha. Na tag img, utilizaremos as classes img-responsive center-block para que ela escale corretamente nos mais diversos dispositivos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
        </div><!-- fim container -->
    </body>
</html>
imagem de animal

Bravo! Mas isso não impressiona, além do mais, se tivéssemos 100 imagens teríamos que repetir a tag img 100 vezes! Em nossa aplicação aprenderemos a cadastrar informações de imagens e a partir desses dados cadastrados montaremos dinamicamente uma lista de imagens! Só que antes de pensar em integração com o back-end, precisamos primeiro entender como o Angular fornece dados para a nossa view e como ela se constrói a partir desses dados.

Vamos realizar uma pequena mudança na tag img, alterando os atributos src e alt:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
A primeira coisa é entender que abrimos lacunas em nossa view index.html através da sintaxe {{ }}. Se temos uma view que agora possui lacunas, podemos chamá-la de template. Quando alguém envia um memorando para outra, raramente ela começa do zero, ou seja, ela adota um template, toda uma estrutura já pronta e seu único trabalho é preencher essas lacunas que variam de acordo com a situação. Isso se aplica no mundo Angular! O que acontece se visualizarmos nossa página agora? Nenhuma imagem será exibida e nenhum erro ocorrerá! Aliás, o termo lacuna é muito genérico, no mundo Angular usamos Angular Expression (AE). Todo {{ }} que encontrarmos chamaremos de AE. Combinado?

Quando temos um template que precisa de algum dado através de uma AE e não encontra, simplesmente aquela expressão fica em branco. Agora, a pergunta que não quer calar: quem, no modelo MVC é o responsável em disponibilizar dados para a views? Se você respondeu controller acertou!

Nosso primeiro controller
Precisamos criar um controller que disponibilize para a view o dado que ela precisa, no caso um objeto que contenha como chave o título e o endereço de uma foto, por exemplo { titulo: 'Leão', url : 'http://www.fundosanimais.com/Minis/leoes.jpg'}.

Lembra do nosso módulo principal da aplicação? Podemos criar um ou mais controllers diretamente nele, porém é uma boa prática declarar cada controller em arquivos separados, mesmo que eles façam parte do módulo alurapic. Vamos criar dentro de public/js/controllers/fotos-controller.js.

Criando nosso controller:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {
  // definição do controller aqui 
});
Veja que chamamos novamente angular.module, só que dessa vez sem passar o segundo parâmetro, o array vazio. Quando fazemos isso, indicamos que queremos acessar o módulo e não criar um novo. Faz todo sentido, se queremos que nosso controller faça parte do módulo alurapic. Em seguida encadeamos uma chamada à função controller que recebe dois parâmetros. O primeiro é o nome do controller que estamos criando na convenção PascalCase, o segundo uma função que define o controller.

Sabemos que o controller deve fornecer o objeto foto para a view e que esse objeto deve conter as chaves titulo e url. Faremos isso agora!

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {

    var foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Excelente, agora precisamos importar o novo arquivo js que acabamos de criar em nossa view principal index.html:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que isso é suficiente? Não, precisamos indicar dentro da nossa view index.html qual fragmento será gerenciado pelo nosso controller. Angular permite associarmos diferentes controllers para diferentes partes de nossa view, uma maneira de separar responsabilidades. Porém, neste exemplo, queremos que o controller gerencie a tag body e todos os seus elementos filhos e fazemos isso através da diretiva ng-controller, que deve ter como valor o nome exato do controller que criamos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que funciona? Visualizando no navegador, a imagem não é exibida e também não temos uma mensagem de erro. Por quê? O objeto foto não foi criado dentro do nosso controller? Sim, mas como ele foi declarado com var dentro de uma função, ele possui escopo privado. Ah, então para resolvermos vamos remover var, fazendo com que ele caia no escopo global? Nem pensar! Porém, o Angular disponibiliza uma ponte de ligação entre o controller e a view chamada $scope e tudo que for "pendurado" neste objeto será enxergado pela view. Mas como teremos acesso a esse objeto tão especial dentro do mundo Angular? Pedindo! Como? Recebendo-o na função que declara o controller:

angular.module('alurapic').controller('FotosController', function($scope) {

});
Angular encontra na declaração do controller $scope e sabe que tem que criar um para nós. Se tivéssemos escrito o nome do parâmetro de outra maneira, o framework não o criaria. Ou seja, Angular sabe o que deve buscar de sua infraestrutura de acordo com o nome do parâmetro que recebemos em nosso controller. Agora que já temos acesso à $scope, a ponte de ligação do controller com a view, podemos pendurar os dados da foto como sua propriedade.

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Lembre-se que tudo pendurado em $scope será acessível em nossa view, em nosso caso , através da angular expression. Duvida? Só testar e verificar o resultado.

imagem de animal

Ah, isso é data binding?
Angular possui um termo apropriado para associação de um dado disponibilizado por um controller para a view: data binding (associação/ligação de dados). Qualquer alteração no dado do controller dispara uma atualização da view sem que o desenvolvedor tenha que se preocupar ou intervir no processo.

Excelente! Conseguimos um resultado semelhante ao que tínhamos antes, com a diferença de que agora a AE (Angular Expression) de nossa view foi processada com os dados fornecidos por FotosController. Pode parecer pouco, mas isso abre a porteira para que possamos avançar ainda mais no framework da Google.

O que aprendemos neste capítulo?
o papel do modelo MVC
o objeto global angular
importação do Angular e criação do módulo principal da aplicação
as diretivas ng-app e ng-controller
Angular Expression (AE)
o conceito de template
criação de um controller
o conceito de data binding

Preparando o ambiente
Nosso foco é aprender Angular, porém alguns recursos do framework necessitam de um servidor web rodando localmente em sua máquina. Para que você não perca o foco do Angular e não caia em questões de infraestrutura que dizem respeito a um servidor web, disponibilizamos o projeto alurapic (baixe agora) com tudo necessário para subir um servidor web localmente, inclusive com os arquivos do angular já baixados.

É importante destacar que o uso do projeto inicial alurapic não é opcional, pois ele já possui registrado todos os endpoints que serão consumidos pela nossa aplicação em Angular. Além disso, para que o servidor funcione, é necessário ter o Node.js instalado em sua máquina.

O Node.js é um ambiente JavaScript multiplataforma disponível para Linux, Mac e Windows. Para instalá-lo, siga as instruções abaixo referentes a sua plataforma (versão 4.X):

Linux (Ubuntu)
No Ubuntu, através do terminal (permissão de administrador necessária) execute o comando abaixo:

sudo apt-get install -y nodejs
ATENÇÃO: em algumas distribuições Linux, pode haver um conflito de nomes quando o Node é instalado pelo apt-get. Neste caso específico, no lugar do binário ser node, ele passa a se chamar nodejs. Isso gera problemas, pois a instrução npm start não funcionará, pois ela procura o binário node e não nodejs. Para resolver, use a seguinte instrução no terminal para subir o servidor:

nodejs server
É uma pena haver essa discrepância, mas fica aqui essa dica!

Windows
Baixe o instalador clicando no grande botão install diretamente da página do Node.js. Durante a instalação, você apenas clicará botões para continuar o assistente. Não troque a pasta padrão do Node.js durante a instalação a não ser que você saiba exatamente o que está fazendo.

MAC
O homebrew é a maneira mais recomendada para instalar o Node.js em sua máquina, através do comando:

brew update
brew install node
Não usa homebrew? Sem problema, baixe o instalador clicando no grande botão install diretamente da página do Node.js.

Rodando o servidor
Depois do Node.js ter sido instalado, dentro da pasta do projeto alurapic que você descompactou anteriormente, busque todas as dependências do projeto através do seu terminal (prompt de comando, no caso do Windows) favorito com o comando.

npm install
ATENÇÃO USUÁRIOS DE WINDOWS: se por acaso mensagem de erro serem exibidas, procure pelo texto npm ERR! self signed certificate. Se ele existir, isso indica um problema no certificado do seu roteador (proxy). Não se preocupe, basta rodar o comando no terminal npm set strict-ssl false que resolvera este problema.

Em menos de um minuto, todas as dependências para rodar o servidor terão sido baixadas. Para subi-lo utilizamos o comando:

npm start
Repare que seu terminal ficará aguardando indefinidamente, sinal de que o servidor está escutando. Agora é só abrir o navegador no endereço http://localhost:3000. Uma página de boas-vindas será exibida.

Curiosidade
O projeto Alurapic utiliza Express para criar endpoints REST e o NeDB, um banco de dados totalmente feito em Node.js e que não necessita qualquer configuração especial.

##### 2. Construindo o alicerce da nossa aplicação #####

Quando desenvolvemos no server-side, organizamos nosso código em camadas para facilitar a manutenção, o reaproveitamento e a legibilidade de nosso código. É muito comum aplicarmos o modelo MVC (Model, View, Controller), que consiste na separação de tarefas, facilitando assim a reescrita de alguma parte e a manutenção do código.

Porém, não é raro o mesmo desenvolvedor deixar de lado essas práticas quando codifica no client-side. Mesmo aqueles que procuram organizar melhor seu código acabam criando soluções caseiras que nem sempre são bem documentadas.

Tendo como base este cenário, frameworks MVC client-side foram criados. Entre eles temos o Backbone, Ember, Knockout, CanJS, Batman, entre outros.

Angular, o framework MVC da Google
Um framework MVC no lado do cliente que tem ganhado muita atenção da comunidade é o Angular. Criado como um projeto interno da Google e liberado para o público em 2009, ele tem como foco a criação de Single Page Applications (SPA’s). Este tipo de aplicação não recarrega a página durante seu uso, dando uma experiência mais fluída para o usuário. Não se preocupe se você é novo para este tipo de aplicação, você terá a oportunidade de entender melhor seus conceitos ao longo do treinamento.

Conhecendo um pouco da nossa aplicação, o Alurapic
Durante o treinamento construiremos a aplicação Alurapic, um sistema simples de gerenciamento de imagens, permitindo que o usuário busque por aquelas que seguem determinado critério. Mas não se engane: o domínio do problema, apesar de simples, será suficiente para empregarmos grande parte do "arsenal" que o Angular nos fornece, inclusive toda aplicação funcionará em cima de um servidor web já preparado.

Preview da aplicação

Preview da aplicação

Preview da aplicação

Instalando e configurando toda infra necessária
Agora que você já conhece um pouco sobre a aplicação que construiremos, saiba que alguns recursos do Angular dependem de um servidor web para funcionarem, em nosso caso, um servidor local. A boa notícia é que já disponibilizamos um para você, livrando-o dos seus detalhes de configuração. Inclusive ele fará persistência de dados sem que você tenha que instalar um banco de dados específico para isso. Porém, para tudo funcionar, você precisa ter instalado o Node.js.

O arquivo do projeto, o tutorial de instalação do Node.js e as instruções de como levantar o servidor estão no primeiro exercício deste capítulo. Esta é uma boa hora de fazê-lo antes de continuar. Vamos assumir a partir deste ponto que você realizou este primeiro exercício.

Por onde começar?
Angular é um framework que roda no lado do cliente, sendo assim, como qualquer outro script, deve ser importado na página que desejamos eleger como principal da aplicação, em nosso caso, a página já existente, index.html, que está salva dentro da pasta alurapic/public (não sabe que pasta é essa? Você fez o primeiro exercício do capítulo conforme solicitado?). Primeiramente vamos dar uma olhada em sua estrutura:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que a página já importa o CSS do Bootstrap. Se você ainda não o conhece, fique sabendo que ele permite aplicar um visual profissional em nosso projeto, com zero de esforço, apenas adicionando classes declaradas em seu arquivo CSS. Que classes são essas? Muita calma nessa hora! Elas serão introduzidas à medida que formos evoluindo nossa aplicação, mas já podemos adiantar que a classe container centraliza todo conteúdo da página e a text-center centraliza um elemento do tipo block, em nosso caso, a tag h1.

Agora que você já entendeu o papel do Bootstrap em nosso projeto, já podemos continuar. Todas as páginas, bibliotecas, scripts e qualquer outro arquivo dentro da pasta alurapic/public serão acessíveis através do seu navegador, inclusive já temos dentro da pasta alurapic/public/js/lib todos os arquivos do Angular que importaremos à medida que formos precisando. Vamos importar o script angular.min.js, o core do Angular dentro da tag head:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, mas ainda não escrevemos um código que utiliza o Angular! Para fazermos isso, primeiro precisamos criar um módulo.

Criando o alicerce da nossa aplicação, o módulo principal
A história é a seguinte: o framework nos ajuda a separar nosso código em pequenos grupos de código que podem ser combinados e reaproveitados quando necessário, esses grupos são chamados de módulos. Uma aplicação pode ter um, dez ou até mesmo mais de cinquenta módulos, tudo dependerá da complexidade da aplicação. Porém, há sempre um módulo que é o primeiro a ser inicializado assim que sua página é carregada pela primeira vez, inclusive ele também é o responsável pelo carregamento de outros módulos de que sua aplicação precisa para funcionar. É este que criaremos agora!

Vamos criar o arquivo public/js/main.js e mesmo sem escrever qualquer linha de código, vamos importá-lo sem demora na página index.html, abaixo da importação do core do Angular, para não corrermos o risco de esquecermos de importá-lo:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Pronto, e agora? Como criamos nosso módulo? Bem, o Angular disponibiliza para nós no escopo global o objeto angular (nada criativo, não?) que possui uma série de funções que nos permite interagir com o framework, entre elas a função module responsável pela criação de módulos.

Você deve estar pensando "Ok, entendi que é através desse objeto global que eu crio módulos e um monte de coisas do framework, mas escopo global não é algo ruim?". Preocupação justa, mas não se preocupe! Em uma aplicação bem-feita em Angular, este é o único objeto disponível globalmente, todo restante fica confinado dentro dos módulos do Angular! Com o tempo isso ficará ainda mais claro para você.

Criando o módulo principal da aplicação:

// public/js/main.js

angular.module('alurapic', []);
Acabamos de criar nosso primeiro módulo. Perceba que a função module recebe dois parâmetros. O primeiro é o nome do módulo que desejamos criar e o segundo é uma array com todos os módulos de que nosso módulo depende. Como não avançamos ainda com o projeto, não temos nenhuma dependência ainda, porém, você não deve omitir este parâmetro. Mais tarde você entenderá o que acontece quando ele é omitido (suspense!).

Ensinando um truque novo para o navegador
Tudo certo, criamos nosso módulo, mas como o Angular saberá que deve carregá-lo? Será que importar o script public/js/main.js é suficiente? Com certeza não.

Precisamos indicar em nossa página qual será o escopo de atuação do Angular, isto é, se ele gerenciará a página inteira ou apenas parte dela. Isso é importante, porque outro framework MVC pode estar sendo utilizado (algo raro, porém pode acontecer) e não queremos que o Angular bagunce seu trabalho.

Como apenas utilizaremos o Angular, gerenciaremos a página inteira, isto, a tag html e todos seus elementos filhos! Tudo bem, mas como faremos essa associação? Através do atributo ng-app:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
        </div> <!-- fim container -->        
    </body>
</html>
Repare que o atributo ng-app tem como valor o nome do nosso módulo e não poderia ser diferente. Quando nossa página é carregada pela primeira vez o Angular encontrará esse atributo e carregará o módulo alurapic, tudo isso automaticamente, sem termos que nos preocupar em carregá-lo! É claro que se você esquecer de importar o arquivo main.js o Angular não será capaz de carregar o módulo, certo?

Ah, então isso é uma diretiva?
Agora, só uma coisa antes de continuarmos: o atributo ng-app existe no mundo HTML? Com certeza não, ele não faz parte da especificação da W3C. O "atributo" ng-app é na verdade uma diretiva do Angular.

Diretivas ampliam o vocabulário do navegador, ensinando-o novos truques, inclusive aprenderemos a criar nossas próprias diretivas ao longo do treinamento! Nesse caso a diretiva ng-app fornece a capacidade de nossa página carregar/iniciar o módulo principal da aplicação. Aliás, não vamos mais usar o termo página, usaremos view, termo mais correto quando estamos no universo do Angular!

Nossa primeira página dinâmica
Legal, agora, com o servidor iniciado (não lembra como iniciá-lo? Veja o primeiro exercício do capítulo) vamos acessar o endereço http://localhost:3000 e verificar o resultado. Como esperado, nada impressionante, pois apenas preparamos a infraestrutura mínima de uma aplicação em Angular, que nada faz. No máximo, podemos ver através do console do navegador (eu uso Chrome, e você?) todos os arquivos carregados:

arquivos carregados

Bom, vamos começar a dar um colorido para nossa view index.html. Vamos adicionar uma foto, você pode escolher a URL de uma específica, não precisa ser igual a minha. Na tag img, utilizaremos as classes img-responsive center-block para que ela escale corretamente nos mais diversos dispositivos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
        </div><!-- fim container -->
    </body>
</html>
imagem de animal

Bravo! Mas isso não impressiona, além do mais, se tivéssemos 100 imagens teríamos que repetir a tag img 100 vezes! Em nossa aplicação aprenderemos a cadastrar informações de imagens e a partir desses dados cadastrados montaremos dinamicamente uma lista de imagens! Só que antes de pensar em integração com o back-end, precisamos primeiro entender como o Angular fornece dados para a nossa view e como ela se constrói a partir desses dados.

Vamos realizar uma pequena mudança na tag img, alterando os atributos src e alt:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
A primeira coisa é entender que abrimos lacunas em nossa view index.html através da sintaxe {{ }}. Se temos uma view que agora possui lacunas, podemos chamá-la de template. Quando alguém envia um memorando para outra, raramente ela começa do zero, ou seja, ela adota um template, toda uma estrutura já pronta e seu único trabalho é preencher essas lacunas que variam de acordo com a situação. Isso se aplica no mundo Angular! O que acontece se visualizarmos nossa página agora? Nenhuma imagem será exibida e nenhum erro ocorrerá! Aliás, o termo lacuna é muito genérico, no mundo Angular usamos Angular Expression (AE). Todo {{ }} que encontrarmos chamaremos de AE. Combinado?

Quando temos um template que precisa de algum dado através de uma AE e não encontra, simplesmente aquela expressão fica em branco. Agora, a pergunta que não quer calar: quem, no modelo MVC é o responsável em disponibilizar dados para a views? Se você respondeu controller acertou!

Nosso primeiro controller
Precisamos criar um controller que disponibilize para a view o dado que ela precisa, no caso um objeto que contenha como chave o título e o endereço de uma foto, por exemplo { titulo: 'Leão', url : 'http://www.fundosanimais.com/Minis/leoes.jpg'}.

Lembra do nosso módulo principal da aplicação? Podemos criar um ou mais controllers diretamente nele, porém é uma boa prática declarar cada controller em arquivos separados, mesmo que eles façam parte do módulo alurapic. Vamos criar dentro de public/js/controllers/fotos-controller.js.

Criando nosso controller:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {
  // definição do controller aqui 
});
Veja que chamamos novamente angular.module, só que dessa vez sem passar o segundo parâmetro, o array vazio. Quando fazemos isso, indicamos que queremos acessar o módulo e não criar um novo. Faz todo sentido, se queremos que nosso controller faça parte do módulo alurapic. Em seguida encadeamos uma chamada à função controller que recebe dois parâmetros. O primeiro é o nome do controller que estamos criando na convenção PascalCase, o segundo uma função que define o controller.

Sabemos que o controller deve fornecer o objeto foto para a view e que esse objeto deve conter as chaves titulo e url. Faremos isso agora!

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function() {

    var foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Excelente, agora precisamos importar o novo arquivo js que acabamos de criar em nossa view principal index.html:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que isso é suficiente? Não, precisamos indicar dentro da nossa view index.html qual fragmento será gerenciado pelo nosso controller. Angular permite associarmos diferentes controllers para diferentes partes de nossa view, uma maneira de separar responsabilidades. Porém, neste exemplo, queremos que o controller gerencie a tag body e todos os seus elementos filhos e fazemos isso através da diretiva ng-controller, que deve ter como valor o nome exato do controller que criamos:

<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
Será que funciona? Visualizando no navegador, a imagem não é exibida e também não temos uma mensagem de erro. Por quê? O objeto foto não foi criado dentro do nosso controller? Sim, mas como ele foi declarado com var dentro de uma função, ele possui escopo privado. Ah, então para resolvermos vamos remover var, fazendo com que ele caia no escopo global? Nem pensar! Porém, o Angular disponibiliza uma ponte de ligação entre o controller e a view chamada $scope e tudo que for "pendurado" neste objeto será enxergado pela view. Mas como teremos acesso a esse objeto tão especial dentro do mundo Angular? Pedindo! Como? Recebendo-o na função que declara o controller:

angular.module('alurapic').controller('FotosController', function($scope) {

});
Angular encontra na declaração do controller $scope e sabe que tem que criar um para nós. Se tivéssemos escrito o nome do parâmetro de outra maneira, o framework não o criaria. Ou seja, Angular sabe o que deve buscar de sua infraestrutura de acordo com o nome do parâmetro que recebemos em nosso controller. Agora que já temos acesso à $scope, a ponte de ligação do controller com a view, podemos pendurar os dados da foto como sua propriedade.

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Lembre-se que tudo pendurado em $scope será acessível em nossa view, em nosso caso , através da angular expression. Duvida? Só testar e verificar o resultado.

imagem de animal

Ah, isso é data binding?
Angular possui um termo apropriado para associação de um dado disponibilizado por um controller para a view: data binding (associação/ligação de dados). Qualquer alteração no dado do controller dispara uma atualização da view sem que o desenvolvedor tenha que se preocupar ou intervir no processo.

Excelente! Conseguimos um resultado semelhante ao que tínhamos antes, com a diferença de que agora a AE (Angular Expression) de nossa view foi processada com os dados fornecidos por FotosController. Pode parecer pouco, mas isso abre a porteira para que possamos avançar ainda mais no framework da Google.

O que aprendemos neste capítulo?
o papel do modelo MVC
o objeto global angular
importação do Angular e criação do módulo principal da aplicação
as diretivas ng-app e ng-controller
Angular Expression (AE)
o conceito de template
criação de um controller
o conceito de data binding

Preparando o ambiente
Nosso foco é aprender Angular, porém alguns recursos do framework necessitam de um servidor web rodando localmente em sua máquina. Para que você não perca o foco do Angular e não caia em questões de infraestrutura que dizem respeito a um servidor web, disponibilizamos o projeto alurapic (baixe agora) com tudo necessário para subir um servidor web localmente, inclusive com os arquivos do angular já baixados.

É importante destacar que o uso do projeto inicial alurapic não é opcional, pois ele já possui registrado todos os endpoints que serão consumidos pela nossa aplicação em Angular. Além disso, para que o servidor funcione, é necessário ter o Node.js instalado em sua máquina.

O Node.js é um ambiente JavaScript multiplataforma disponível para Linux, Mac e Windows. Para instalá-lo, siga as instruções abaixo referentes a sua plataforma (versão 4.X):

Linux (Ubuntu)
No Ubuntu, através do terminal (permissão de administrador necessária) execute o comando abaixo:

sudo apt-get install -y nodejs
ATENÇÃO: em algumas distribuições Linux, pode haver um conflito de nomes quando o Node é instalado pelo apt-get. Neste caso específico, no lugar do binário ser node, ele passa a se chamar nodejs. Isso gera problemas, pois a instrução npm start não funcionará, pois ela procura o binário node e não nodejs. Para resolver, use a seguinte instrução no terminal para subir o servidor:

nodejs server
É uma pena haver essa discrepância, mas fica aqui essa dica!

Windows
Baixe o instalador clicando no grande botão install diretamente da página do Node.js. Durante a instalação, você apenas clicará botões para continuar o assistente. Não troque a pasta padrão do Node.js durante a instalação a não ser que você saiba exatamente o que está fazendo.

MAC
O homebrew é a maneira mais recomendada para instalar o Node.js em sua máquina, através do comando:

brew update
brew install node
Não usa homebrew? Sem problema, baixe o instalador clicando no grande botão install diretamente da página do Node.js.

Rodando o servidor
Depois do Node.js ter sido instalado, dentro da pasta do projeto alurapic que você descompactou anteriormente, busque todas as dependências do projeto através do seu terminal (prompt de comando, no caso do Windows) favorito com o comando.

npm install
ATENÇÃO USUÁRIOS DE WINDOWS: se por acaso mensagem de erro serem exibidas, procure pelo texto npm ERR! self signed certificate. Se ele existir, isso indica um problema no certificado do seu roteador (proxy). Não se preocupe, basta rodar o comando no terminal npm set strict-ssl false que resolvera este problema.

Em menos de um minuto, todas as dependências para rodar o servidor terão sido baixadas. Para subi-lo utilizamos o comando:

npm start
Repare que seu terminal ficará aguardando indefinidamente, sinal de que o servidor está escutando. Agora é só abrir o navegador no endereço http://localhost:3000. Uma página de boas-vindas será exibida.

Curiosidade
O projeto Alurapic utiliza Express para criar endpoints REST e o NeDB, um banco de dados totalmente feito em Node.js e que não necessita qualquer configuração especial.

Vejamos as seguintes afirmações sobre Angular:
1) Angular é um script como outro qualquer, por isso precisa ser importado em nossa página através da tag script.

2) A diretiva ng-app carrega e importa o módulo que desejamos utilizar.

3) A diretiva ng-app possui como valor o nome do módulo que desejamos carregar assim que nossa página for carregada.

4) Um módulo pode ter de 0 a N dependências.

Com base nessas afirmações, podemos dizer que:

1,3 e 4 são verdadeiras
 
Correto! Precisamos importar o script do Angular como fazemos com qualquer outro, como os demais módulos criados, por exemplo. Além disso temos de carregar um módulo através da diretiva ng-app. Esses por sua vez podem carregar ou não demais módulos, isto é, suas dependências.

Temos:
1) angular.module('alurapic', []);

2) angular.module('alurapic');

3) angular.module('alurapic', ['calopsitaStyle']);

4) module('alurapic', []);

No que diz respeito à criação de módulos, podemos afirmar que:

2 e 4 estão erradas
 
Perfeito! Criamos um módulo através do objeto global angular passando dois parâmetros: o nome do módulo e um array com suas dependências, que pode ser vazio caso não possua. No exemplo angular.module('alurapic'); estamos apenas acessar um módulo já existente.

Temos as seguintes declarações sobre Angular Expression (AE):
1) Angular Expression serve para abrir lacunas em nossas views, que por sua vez passam a funcionar como templates.

2) Angular Expression possui a sintaxe {nomeDaPropriedade}.

3) Controllers podem fornecer dados para uma Angular Expression.

4) Uma Angular Expression não avaliada tem como valor null.

1 e 3 estão corretas
 
Usamos Angular Expressions para abrir "lacunas" em views. Essa ideia remete ao uso de templates: modelos com uma base pronta, mas que possuem trechos de informações dinâmicas. Essas informações dinâmicas são fornecidas pelos nossos controllers. A sintaxe de uma AE é {{nomeDaPropriedade}}.

Vejamos os seguintes códigos:
1) angular.module('contasAhReceber').controller(function($scope) { });

2) angular.module('contabilidade', []).controller('LancamentosController', function() { });

3) angular.module('estoque').controller('Provisao', function($scope) { });

4) angular.controller('CaixaCtrl', function($scope) { });

Sobre a criação de Controller em Angular, podemos afirmar sobre as alternativas apresentadas que:

2 e 3 estão corretas
 
Perfeito! Um controller pode ser criado com um módulo ou mais tarde adicionado em um módulo já existente. A função controller recebe como primeiro parâmetro o nome do controller e como segundo a função que o define.

Temos a seguinte marcação em nossa view:
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código omitido -->
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>

             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">

        </div><!-- fim container -->
    </body>
</html>
O controller FotosController foi associado ao elemento body e qualquer um de seus elementos filhos terão acesso a tudo o que foi adicionado no escopo do controller. Qual das opções abaixo disponibiliza corretamente foto no escopo do controller:

angular.module('alurapic').controller('FotosController', function($scope) {
  $scope.foto = {
      titulo : 'Leão',
      url: 'http://fotosdoalem.com/leao.jpg'
  };
});
 
Perfeito! A comunicação entre um controller e uma view é feita através do objeto $scope, que representa o escopo de um controller. Qualquer propriedade adicionada neste objeto estará disponível na view e acessível através de AEs, para o elemento onde definimos o escopo do controller, assim como seus filhos.

Temos as seguintes afirmativas:
1 - Data binding significa associação de dado, isto é, podemos associar um dado à view através de Angular Expression e qualquer mudança nesse dado refletirá na sua apresentação na view.

2 - Uma Angular Expression (AE) é somente leitura, isto é, alterações dos dados na view não se propaga para o model.

3 - Um model no Angular pode ser um objeto ou qualquer tipo literal do JavaScript, como String ou Boolean.

4 - Angular não é uma solução que se coaduna com a prática de Progressive Enhancement no que diz respeito a criação de páginas web.

Podemos afirmar que:

Todas as afirmativas estão corretas
 
Uma AE é somente leitura, nossa view lê a informação no escopo do controller, mas não é capaz de atualizá-la. Este tipo de associação é chamado de one-way data binding, a informação flui do controller para a view. Aliás, esse dado associado à view pode ser qualquer tipo literal do JavaScript, inclusive um objeto.
Angular não se coaduna com a prática do Progressive Enhancement, no qual criamos uma página usando um simples HTML e CSS, usando JavaScript apenas para adicionar melhorias. Com Angular, se o JavaScript estiver desativado ou não for suportado, nada da aplicação funcionará.

Chegou a hora de praticar!
Neste exercício, implemente os passos que foram vistos durante esta aula para conseguir o mesmo resultado apresentado. Não consegue lembrar de tudo? Não se preocupe, apresentarei passos gerais para guiá-lo nesta tarefa. Se isso ainda não for suficiente, não se preocupe, você pode consultar o vídeo e o texto explicativo do capítulo, mas sugiro que tente primeiro sem antes consultá-los. Combinado?

No final, cole o código dos arquivos que você modificou:

1) Angular nada mais é do que um framework escrito em JavaScript e como qualquer script deve ser importado na página. Importe-o dentro da tag <head>. Lembre-se que você pode verificar através do developer tools (console do navegador) se o script foi importado, olhando a aba network (rede). Isso é importante, porque muitas vezes perdemos tempo achando que nosso código não funciona, quando na verdade é o script que não foi carregado.

2) Só carregar o Angular não é suficiente, precisamos criar o primeiro módulo da aplicação. Crie o arquivo main.js "no diretório js que se encontra dentro da pasta public". Declare o módulo nomeando de alurapic. Lembre-se que esse processo é feito por intermédio do objeto global angular.

3) Um módulo criado ainda não é suficiente. Você precisa fazer com que o Angular carregue o módulo assim que sua página for carregada. Lembra da diretiva ng-app? Lembra qual tem que ser o valor atribuído à ela? Mais alguma coisa? O módulo main.js tem que ser importado também na página, certo?

4) Agora que tudo está no lugar, dentro da tag <body> você vai adicionar a marcação que existe uma foto. Não lembra da marcação? Não se preocupe, vai uma cola:

<!-- dentro do body -->
<div class="container">
   <h1 class="text-center">Alurapic</h1>
   <img class="img-responsive center-block" src="http://www.fundosanimais.com/Minis/leoes.jpg" alt="Leão">
</div><!-- fim container -->
5) Abra uma lacuna para os atributos src e alt da imagem, criando um controller que forneça os dados de que ela precisa. Lembre-se de criar um controller em um arquivo em separado usando a convenção de pastas que vimos. Ele se chamará FotosController e disponibilizará para a view um objeto foto com duas propriedades: url e titulo. Ainda lembra como um controller disponibiliza dados para a view?

6) Ainda lembra como criamos o controller para o módulo alurapic? Ainda lembra que precisamos importar o script do controller em nossa view index.html. Por fim, ainda lembra para que serve a diretiva ng-controller?

Mãos à obra e bom estudo!

Importando o script do Angular, o módulo principal da aplicação e adicionando a diretiva ng-app:
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <!-- código omitido -->        
    </body>
</html>
Abrindo uma lacuna no template index.html, através de AE (Angular Expression):

<!-- public/index.html -->
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
    </head>
    <body>
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
Criando o controller que fornecerá os dados para a view:

// public/js/controllers/fotos-controller.js
angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo : 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Importando o controller e adicionando a diretiva ng-controller:

<!-- public/index.html -->
<html lang="pt-br" ng-app="alurapic">
    <head>
       <!-- código anterior omitido -->
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
       <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <h1 class="text-center">Alurapic</h1>
            <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>

##### 3. Tornando nossa aplicação mais próxima de uma aplicação real #####

Melhorando a apresentação da nossa página
Bom, antes de avançarmos, vamos melhorar rapidamente o visual da nossa aplicação. Primeiro, vamos colocar seu título em destaque movendo a tag h1 para dentro de uma div, com a classe jumbotron:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
             <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
        </div><!-- fim container -->
    </body>
</html>
Em seguida, vamos colocar nossa figura dentro de um painel do Bootstrap:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">

            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}" alt="{{foto.titulo}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
Preview Jumbotron e Panel

Que tal agora adicionarmos mais fotos? Para simplificar, vamos copiar e colar o painel que já criamos!

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
O resultado, como esperado, é a repetição da imagem do leonino:

Painel duplicado

Repetição de marcação dá trabalho!
E se agora quisermos uma foto diferente para cada painel? Sabemos que, dentro de um controller, é por intermédio de $scope que disponibilizamos dados para a view. Que tal criarmos foto2 e foto3? Só para simplificar, vamos deixar a mesma url para eles, apenas mudaremos seus títulos:

// public/js/controllers/fotos-controller.js 

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.foto = {
        titulo: 'Leão',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

    $scope.foto2 = {
        titulo: 'Leão2',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

    $scope.foto3 = {
        titulo: 'Leão3',
        url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
    };

});
Precisamos alterar a AE dos novos painéis para apontar para os dados corretos:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto2.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto2.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

            <div class="panel panel-default">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto3.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto3.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->

        </div><!-- fim container -->
    </body>
</html>
Preview de várias fotos

Legal, cada foto possui um nome, porém essa solução deixa a desejar. Perceba que estamos repetindo a mesma marcação do painel do Bootstrap três vezes, mas o que muda é apenas o valor da AE. Segundo, para cada nova foto teremos que adicionar mais uma propriedade em $scope e copiar e colocar um novo painel.

Primeiro, vamos resolver o problema das múltiplas propriedades em $scope. No mundo JavaScript, quando queremos representar uma lista utilizamos um array:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope) {

    $scope.fotos = [
        {
            titulo: 'Leão',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        },

        {
            titulo: 'Leão2',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        },

        {
            titulo: 'Leão3',
            url : 'http://www.fundosanimais.com/Minis/leoes.jpg'
        }
    ];

});
Hum, interessante. Se precisarmos adicionar mais uma foto, basta adicioná-la dentro da lista. Porém, isso não resolve a renderização da nossa view. Se visualizarmos novamente, três painéis vazios serão exibidos, porque a view não foi capaz de avaliar a AE de cada um deles.

Repetir? É com o Angular mesmo!
Não seria interessante se o Angular fosse inteligente o suficiente para repetir o HTML do painel para cada objeto foto de nossa lista? Puxa vida, teríamos apenas um painel, o que evitaria a repetição, inclusive, para cada nova foto que entrar na lista, um novo painel seria criado! Já aprendemos as diretivas ng-app e a ng-controller, consegue ver um padrão? Diretivas do Angular começam com ng-! Então, como é repetir em inglês? Repeat! Então, se eu quero uma diretiva do Angular que repita a criação de uma marcação HTML para uma determinada lista temos a diretiva ng-repeat:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="panel panel-default" ng-repeat="foto in fotos">
                <div class="panel-heading">
                    <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                </div>
                <div class="panel-body">
                    <img class="img-responsive center-block" src="{{foto.url}}">
                </div><!-- fim panel-body -->
            </div><!-- fim panel panel-default -->
        </div><!-- fim container -->
    </body>
</html>
Ao recarregarmos nossa página, as três imagens são exibidas, cada uma com seu título, com a diferença que temos um código HTML mais enxuto!

Preview

Na diretiva ng-repeat indicamos qual lista estamos varrendo, em nosso caso, fotos, que está no $scope de FotosController. Mas como ter acesso a cada contato da lista? Para isso, damos um apelido para cada item da lista, em nosso caso, escolhemos o apelido foto. Como temos três fotos em nossa lista, a diretiva ng-repeat será repetida três vezes e através da AE podemos ter acesso aos dados da foto, por exemplo, com {{foto.titulo}} acessamos seu título.

O bonito seria se a lista de fotos viesse de um servidor web. É tão bonito que faremos isso agora, chega de ficar digitando dados fixos!

Chega de dados fixos! Vamos buscá-los do servidor!
É extremamente comum uma aplicação feita em Angular consumir dados de um servidor através de uma API REST, que retorna esses dados na estrutura JSON. Nosso servidor já possui uma série de endpoints que utilizaremos ao longo do treinamento, porém há um deles que nos interessa. Que tal abrir em seu navegador para ver o resultado?

http://localhost:3000/v1/fotos
Fotos

Não se assuste, mas o que o servidor retornou para você foi uma lista de fotos, porém, na chave url, não há o endereço de uma foto, mas o DataUri de uma foto. Fizemos isso para termos a garantia de que a foto sempre existirá, o que poderia não acontecer caso tivéssemos preenchido com o endereço de uma foto da web qualquer. Pois bem, a ideia é acessarmos essa lista através da nossa aplicação para em seguida jogá-la em $scope.fotos.

Para que possamos acessar os dados do nosso servidor precisaremos realizar requisições Ajax. Lembre-se que este tipo de requisição é assíncrono, isto é, que não bloqueia o uso da aplicação enquanto é executado. Se você vem do mundo jQuery já deve ter usado $.ajax ou uma de suas especializações, porém, o Angular possui seu próprio serviço para executar este tipo de requisição, o $http.

Da mesma maneira que pedimos ao Angular a criação de um $scope podemos pedir o $http recebendo-o como parâmetro na função que define FotosController. Vamos aproveitar e deixar a lista de fotos vazia:

// public/js/controllers/fotos-controller.js

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];
});
Esse sistema de "pedirmos" ao Angular o que precisamos é chamado de injeção de dependências. Nós gritamos "eu preciso de um $http!" e o framework se vira para nos entregar um. Outra coisa é que podemos inverter a ordem dos parâmetros da função que ainda assim o Angular saberá injetá-los. É por isso que o nome dos parâmetros são importantes. Se digitarmos http no lugar de $http, Angular não saberá que precisamos desse serviço e seu valor será undefined.

Pois bem, temos $http. E agora? Como realizamos uma requisição assíncrona para o endpoint v1/fotos? Como queremos obter dados, usamos a função get:

// não entra em nenhum lugar, apenas ilustrativo
$http.get('/v1/fotos');
Então, o retorno da função $http.get é a nossa lista de fotos do servidor? Não, não é! Toda requisição assíncrona é incerta, não sabemos quanto tempo ela demorará para ser executada e se realmente será bem sucedida.

Angular faz promessas?
O que $http.get nos retorna é uma promessa de que ele buscará os dados. Sabemos que se essa promessa for cumprida, teremos os dados, caso contrário, ficaremos a ver navios. Tecnicamente falando, o que $http.get retorna é uma promise:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');  
});
Quando essa promessa for cumprida, daí (then) podemos ter acesso aos dados retornados:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');
    promise.then(function(retorno) {
        $scope.fotos = retorno.data;
    });
});
Veja que a função then recebe como parâmetro uma função passada por nós que será chamada apenas quando a requisição for concluída com sucesso, ou melhor, quando nossa promessa for resolvida. Na documentação do Angular, está escrito que é nela que temos acesso aos dados retornados pelo servidor, em nosso caso, escolhemos o nome retorno, mas poderia ser qualquer um. Porém, é de retorno.data que efetivamente temos nossa lista de fotos.



E se alguma coisa der errada? Por exemplo, a URL não existir ou o servidor cair? Podemos encadear uma chamada à função .catch que nos fornecerá um objeto com informações do erro que ocorreu:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    var promise = $http.get('/v1/fotos');
    promise.then(function(retorno) {
        $scope.fotos = retorno.data;
    })
    .catch(function(erro) {
        console.log(erro)
    }); 
});
Por enquanto só vamos exibir no console do navegador a mensagem, mais tarde aprenderemos a exibir mensagens amigáveis para o usuário.

Podemos ainda omitir a declaração da variável promise:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .then(function(retorno) {
        $scope.fotos = retorno.data;
    })
    .catch(function(erro) {
        console.log(erro);
    }); 
});
Ou ainda usarmos success e error. A diferença é que com success não precisamos fazer retorno.data:

angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .success(function(retorno) {
        console.log(retorno);
        $scope.fotos = retorno; // não precisa fazer retorno.data
    })
    .error(function(erro) {
        console.log(erro);
    });

});
Ainda neste treinamento aprenderemos a cadastrar novas fotos, editar, inclusive apagar aquelas que não nos interessam. Porém, como podemos perceber, a quantidade de fotos aumentou e pode ficar ainda maior. Vamos ajustar nosso layout colocando um grid responsivo do Bootstrap:

<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">

                <div class="panel panel-default col-md-2" ng-repeat="foto in fotos">
                    <div class="panel-heading">
                        <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                    </div>
                    <div class="panel-body">
                        <img class="img-responsive center-block" src="{{foto.url}}">
                    </div><!-- fim panel-body -->
                </div><!-- fim panel panel-default -->

            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
Grid

O que aprendemos neste capítulo?
a diretiva ng-repeat
injeção de dependências baseada no nome de parâmetro
o serviço $http
o conceito de promise
comunicação com o back-end

O Angular permite repetir marcações HTML através da diretiva ng-repeat. Primeiro, precisamos adicioná-la no elemento que desejamos repetir, segundo, precisamos indicar na diretiva a propriedade em $scope do controller que será iterada. Dentro desse contexto, temos alguns exemplos abaixo do uso da diretiva:
1) <p ng-repeat="frase in frases">{{frase}}</p>

2) <p ng-repeat="frases">{{frase}}</p>

3) <div ng-repeat="produto in produtos">{{produtos}}</p>

4) <section ng-repeat="propaganda">{{propaganda}}</p>

Podemos afirmar sobre os exemplos acima que:

Apenas 1 está correta
 
O código <p ng-repeat="frase in frases">{{frase}}</p> é funcional. Ele itera sobre a lista frases, que existe no escopo de algum controller e para cada elemento fornece um apelido, no caso frase. Assim conseguimos acessar cada elemento da lista através da Angular Expression (AE) {{frase}}.

Angular possui seu próprio sistema de injeção de dependências:
1) angular.module('alurapic').controller('a', function($http, $scope) {});

2) angular.module('alurapic').controller('b', $http, $scope) {};

3) angular.module('alurapic').controller('c', function($scope, $http) {});

4) angular.module('alurapic').controller('d', function($scope, http) {});

Levando em consideração o que você aprendeu neste capítulo, qual das alternativas abaixo é verdadeira?

2 e 4 não injetam corretamente $http e $scope
 
Angular foi pioneiro no suporte à injeção de dependências no lado do cliente. Uma característica desse sistema é que toda injeção é feita pelo nome do parâmetro, por isso é muito importante passarmos os parâmetros nomeados de acordo com o serviço ou recurso do Angular que desejamos usar.

Angular fornece um serviço exclusivo para realização de requisição Ajax, o $http.Vejamos algumas afirmativas sobre este serviço:
1) Pode ser injetado como qualquer outro artefato do Angular

2) Possui a função .get, que recebe como parâmetro um endereço, inclusive é especializada na leitura de dados.

3) A função .get retorna uma promise.

4) Podemos usar .then e .catch para obter os dados e capturar erros respectivamente ou .success e .error, açúcares sintáticos com a mesma finalidade.

Com base nas afirmações acima, podemos dizer que:

Todas são verdadeiras, exceto a 1
 
Ops! Lembre-se que podemos sim contar com a injeção do serviço $http do Angular, por exemplo, como fazemos nos controllers: angular.module('alurapic').controller('FotosController', function($http, $scope){ ... })

Qual das opções abaixo declara corretamente um controller e configura corretamente um elemento da view para usar a diretiva ng-repeat?

// controller
angular.module('alurapic').controller('NomeDoController', function($scope) {
   $scope.letras = ['A', 'B', 'C'];
});
// na view

<ul ng-controller="NomeDoController">
    <li ng-repeat="letra in letras">{{letra}}</li>
</ul>
 
Muito bem! Angular não perdoa! Basta um erro de sintaxe ou omitir um artefato, como $scope, para que nossa funcionalidade deixe de funcionar.

Sabemos que $http.get retorna uma promise e que podemos encadear uma chamada à then. Um exemplo:
$http.get('v1/fotos')
  .then(function(retorno) {
    $scope.fotos = retorno.data;
  })
  .catch(function(erro) {
    // trata o erro
  });
Para praticar outras formas de escrita, tente reescrever o código acima utilizando .success e .error, aqueles açúcares sintáticos de $http.

O código modificado fica:
$http.get('v1/fotos')
  .success(function(fotos) {
    $scope.fotos = fotos;  
  })
  .error(function(erro) {
    // trata o erro
  });
Neste exemplo, é importante notar que a função success recebe a lista de fotos diretamente retornada pelo servidor e não um objeto que contém a propriedade .data, quando usamos then. Como temos acesso à lista diretamente, fica mais legível chamarmos o parâmetro de fotos do que simplesmente retorno.

Chegou a hora de praticar, mais uma vez!
Neste exercício, implemente os passos que foram vistos durante esta aula, para conseguir o mesmo resultado apresentado, evoluindo ainda mais nossa aplicação. Não consegue lembrar de tudo? Não se preocupe, apresentarei passos gerais para guiá-lo nesta tarefa. Se isso ainda não for suficiente, não se preocupe, você pode consultar o vídeo e o texto explicativo do capítulo, mas sugiro que tente primeiro sem antes consultá-los.

1) Melhore a experiência do usuário adicionando um componente jumbotron do Bootstrap. Este é um treinamento de Angular e não de Bootstrap, sendo assim, fique livre para consultar a qualquer momento o vídeo e o texto explicativo caso tenha dúvidas nas marcações do Bootstrap.

2) No lugar de exibir a imagem da foto diretamente, exiba-a através de um panel-default do Bootstrap. Repare que até agora não há nenhuma novidade do mundo Angular. Aproveite também para adicionar o sistema de grids do Bootstrap.

3) Altere seu controller para disponibilizar no mínimo três fotos para a view. Como? Lembra que uma propriedade em $scope pode ser uma lista, um array em JavaScript?

4) Com esta alteração, altere seu painel em index.html para que ele construa um painel para cada foto em $scope.fotos. Para esta tarefa, você precisará realizar uma repetição através da diretiva ng-repeat.

5) Agora que sua view index.html consegue exibir um painel para cada foto $scope.fotos, está na hora de deixar de trabalhar com dados fixos e buscar esses dados do servidor. Solicite em seu controller o serviço $http via injeção, aquele responsável por realizar requisições Ajax.

6) O projeto baixado no primeiro capítulo já possui um servidor com endereços específicos para operações de inclusão, alteração, deleção e listagem. Nosso foco é no Angular, não na criação do back-end, porém é importantíssimo saber que consumiremos endpoints REST, que nada mais são do que URLs seguindo a convenção REST. A URL http://localhost:3000/v1/fotos é a responsável por obter todas as fotos, porém $http só precisa da parte v1/fotos para trabalhar.

7) Acesse a URL através de $http.get, lembrando que este serviço retorna uma promise. O $http possui dois atalhos para esta operação e serão estes que você utilizará: success e error.

8) Atualize $scope.fotos com os dados retornados pelo servidor. Agora, você terá dados dinâmicos e não estáticos como antes!

9) Muita informação? Fique à vontade para assistir o vídeo e consultar a explicação textual quantas vezes for necessária. Não sinta a obrigação de decorar tudo de uma só vez, é natural dúvidas no que diz respeito à sintaxe do Angular.

Bom exercício!

A página principal alterada, com os componentes jumbotron e panel-default do Bootstrap, e com a diretiva ng-repeat!
<!-- public/index.html -->
<!DOCTYPE html>
<html lang="pt-br" ng-app="alurapic">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>Alurapic</title>
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <link rel="stylesheet" href="css/bootstrap-theme.min.css">
        <script src="js/lib/angular.min.js"></script>
        <script src="js/main.js"></script>
        <script src="js/controllers/fotos-controller.js"></script>
    </head>
    <body ng-controller="FotosController">
        <div class="container">
            <div class="jumbotron">
                <h1 class="text-center">Alurapic</h1>
            </div>
            <div class="row">

                <div class="panel panel-default col-md-2" ng-repeat="foto in fotos">
                    <div class="panel-heading">
                        <h3 class="panel-title text-center">{{foto.titulo}}</h3>
                    </div>
                    <div class="panel-body">
                        <img class="img-responsive center-block" src="{{foto.url}}">
                    </div><!-- fim panel-body -->
                </div><!-- fim panel panel-default -->

            </div><!-- fim row -->
        </div><!-- fim container -->
    </body>
</html>
O controller alterado, agora buscando os dados do servidor:

// public/js/controllers/fotos-controller.js
angular.module('alurapic').controller('FotosController', function($scope, $http) {

    $scope.fotos = [];

    $http.get('/v1/fotos')
    .success(function(retorno) {
        console.log(retorno);
        $scope.fotos = retorno; // não precisa fazer retorno.data
    })
    .error(function(erro) {
        console.log(erro);
    });

});





