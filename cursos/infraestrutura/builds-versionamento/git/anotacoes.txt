GIT - trabalho em equipe com controle e segurança
GIT - Controle de versão distribuído
Com o GIT se ganha histórico de versões

GITHUB - plataforma online onde se pode hospedar o código com o controle de versão do git

Criar usuário e senha: https://github.com

Branche é desenvolver em uma área específica do seu repositório e depois integrar essa área no repositório principal

############### 1. Introdução ao controle de versões com Git ###############

Quando iniciamos um novo projeto, uma das primeiras perguntas que surge é: onde os arquivos desse projeto ficarão armazenados?. É necessário, principalmente quando trabalhamos em conjunto com outros desenvolvedores, que o projeto esteja armazenado em um local que esteja acessível a todos os membros da equipe, com as respectivas permissões para que os mesmos sejam alterados, para que novos arquivos sejam criados e que arquivos existentes possam ser excluídos.

Tendo em vista esse cenário, podemos definir que qualquer computador, numa rede onde todos os membros da equipe tenham acesso, é candidato a "local do projeto". Mas, e se ocorrer algum problema com esse computador como, por exemplo, alguma falha em seu hardware?

Então podemos pensar em armazenar os arquivos do projeto em um servidor, com redundância de dispositivos de armazenamento e backups constantes. Uma pasta compartilhada na rede em uma máquina mais segura do que uma estação de trabalho torna-se uma opção melhor. Agora temos um local propício para que o projeto seja armazenado com segurança e acesso para toda a equipe, inclusive com backups constantes que permitem que recuperemos arquivos excluídos acidentalmente. Podemos chamar esse local de repositório de código.

Apesar dessa segurança adicional, ficamos um pouco restritos quanto a recuperar arquivos excluídos, não temos como desfazer alterações no nosso projeto seletivamente e também não temos informações suficientes sobre o projeto para saber exatamente qual versão desse arquivo eu devo recuperar do backup?. Podemos criar um histórico (log) textual e adicioná-lo como parte do projeto. Agora perceba que ficamos com um ambiente com requisitos demais para um simples "local de armazenamento de projeto".

Pensando nesse problema foram criadas ferramentas de controle de versão e esse curso apresentará uma das mais utilizadas hoje em dia, o Git. O Git é utilizado em muitos projetos de código aberto no mundo todo. Um dos maiores e mais importantes é o kernel do Linux. É possível, porém, utilizá-lo para projetos privados com todas as restrições e permissões de acesso necessárias.

Uma grande vantagem do Git é a existência de ferramentas comerciais de hospedagem de código na Web. A maior provedora de hospedagem de repositórios Git, abertos ou privados, hoje é o Github (http://www.github.com/). Ele permite criar gratuitamente repositórios abertos.

Para que seja possível utilizar o Git teremos que instalá-lo. O Git é uma ferramenta baseada em linha de comando, ou seja, realizamos as operações de controle dos arquivos pelo prompt de comando. Se você é adepto de ferramentas gráficas não se preocupe, existem algumas opções para facilitar seu trabalho e vamos conhecê-las no decorrer do curso.

Iniciaremos o curso utilizando o Git no prompt de comando, para que seja possível demonstrar suas funcionalidades que, de certa maneira, são mascaradas em botões e opções de menus nas ferramentas gráficas. O uso do Git no prompt de comando será muito importante para detalhar suas capacidades.

Download e instalação do Git
A instalação do Git é diferente para cada sistema operacional. A seguir, mostraremos como todo o processo é feito em cada um deles. Caso você já tenha o Git instalado, clique aqui para ir direto ao uso do Git.

Windows
Para instalar o Git, iniciaremos acessando a página http://msysgit.github.io/ e baixando o instalador do msysgit. O instalador da versão mais recente, no momento da escrita, é o Git-1.9.5-preview20141217.exe. Uma vez baixado, basta executar o programa e seguir as instruções (caso haja uma tela de instalação que não esteja aqui, pode aceitar com as opções padrão).

Na primeira tela de boas vindas, apenas clique em Next:

Instalação Windows: passo 1

Na próxima tela, indique o diretório onde deseja instalar o Git em seu computador:

Instalação Windows: passo 2

Em seguida, indique quais utilitários serão instalados junto do Git. Marque todas as opções, exceto "git-cheetah shell extension", como mostrado na imagem a seguir:

Instalação Windows: passo 3

A seguir, defina o nome do menu do Git para o menu Iniciar do Windows:

Instalação Windows: passo 4

O msysgit instala por padrão em seu computador um programa próprio chamado Git Bash, onde é possível manipular os repositórios de arquivos que trabalharemos no futuro. Caso você prefira, é possível usar o próprio prompt do Windows. Basta, na próxima janela, marcar a opção "Run Git from the Windows Command Prompt", como indicado na imagem a seguir:

Instalação Windows: passo 5

Na janela a seguir, indique que queremos que as quebras de linha sejam consideradas da mesma maneira, independente do sistema operacional trabalhado. Para isso, marque a primeira opção:

Instalação Windows: passo 6

Nesse instante, a cópia dos arquivos será feita para o computador, e em seguida a mensagem de que a instalação foi finalizada aparecerá:

Instalação Windows: passo 7

MacOS
Para instalar o Git no Mac OS X (Snow Leopard ou superior), há um instalador pronto. Basta baixá-lo em http://code.google.com/p/git-osx-installer/downloads/list?can=3. Na listagem, selecione o arquivo git-1.7.7.3-intel-universal-snow-leopard.dmg.

Após baixá-lo, basta clicar duas vezes para ter acesso ao pacote de instalação. Agora é só clicar duas vezes no arquivo "git-1.7.7.3-intel-universal-snow-leopard.pkg" (de acordo com a versão encontrada no momento da escrita) para iniciar o processo de instalação:

Instalação OS X: passo 1

Na tela seguinte, selecione a opção "Instalar para todos os usuários desse computador" para continuar:

Instalação OS X: passo 2

Depois é só prosseguir com a instalação padrão.

Instalação OS X: passo 3

Instalação OS X: passo 4

Para testar a instalação, abra a aplicação "Terminal" e digite o comando git. A saída deve ser similar à imagem:

Instalação OS X: passo 5

Opcionalmente, é possível configurar o Terminal para completar os comandos do Git ao pressionarmos a tecla "tab", além de mostrar na linha de comando se a pasta atual está sendo rastreada pelo Git. Para isso é necessário adicionar as seguintes linhas ao arquivo de perfil do usuário para o prompt de comando, habitualmente encontrado na pasta home do usuário com o nome de .bash_profile (ou .bashrc).

Adicione as seguintes linhas ao fim do arquivo:

if [ -f /usr/local/git/contrib/completion/git-completion.bash ]; then
    . /usr/local/git/contrib/completion/git-completion.bash
fi
GIT_PS1_SHOWDIRTYSTATE=true

PS1='\u@\h:\w $(__git_ps1 "(%s)")\$ '
Ao iniciar uma nova janela ou aba do Terminal, as alterações estarão aplicadas. Caso queira aplicar as alterações imediatamente no Terminal digite source ~/.bash_profile.

Obs.: Caso tenha efetuado a instalação do GIT via Homebrew (http://brew.sh/), alterar o endereço do arquivo git-completion.bash para /usr/local/Cellar/git/*/etc/bash_completion.d/git-completion.bash.

Linux
Em qualquer sistema Linux, podemos utilizar o gerenciador de pacotes da respectiva distribuição para instalar o Git. No Ubuntu e no Debian, por exemplo, basta instalar o pacote git-core para ter o Git instalado. No Fedora, o pacote git. E no Gentoo, o pacote dev-util/git.

Portanto, por exemplo, para fazer a instalação do Git no Ubuntu, basta executar o comando:

sudo apt-get install openssl git-core
Siga as instruções do prompt de comando, primeiro confirmando a instalação dos pacotes e suas dependências, depois confirmando a instalação do pacote git-core, como demonstrado na imagem:

Instalação no Linux 1

É possível testar se o Git foi corretamente instalado rodando o comando git no prompt de comando:

git
A saída deve ser uma mensagem de ajuda, similar à demonstrada na imagem:

Instalação no Linux 2

Ao instalar o Git, um script de ajuda que completa os comandos do Git no terminal é instalado, juntamente com um script que demonstra na linha de comando se estamos em um diretório que é um projeto rastreado pelo Git. Para ativá-los, é necessário modificar o arquivo de perfil do prompt de comando. Normalmente esse arquivo encontra-se na pasta home do usuário e chama-se .bash_profile (em alguns casos .bashrc ou .zshrc).

Caso nenhum dos arquivos citados exista, crie-o; caso exista, adicione as seguintes linhas ao final dele:

if [ -f /etc/bash_completion.d/git ]; then
    . /etc/bash_completion.d/git
fi
GIT_PS1_SHOWDIRTYSTATE=true

PS1='\u@\h:\w $(__git_ps1 "(%s)")\$ '
Salve o arquivo. A partir de agora, caso estivermos em uma pasta rastreada pelo Git no prompt de comando, seremos informados. Para ativar as alterações imediatamente, execute o comando source informando o arquivo de perfil que alteramos:

source ~/.bash_profile
Criando conta no Github
Agora que temos o Git instalado, podemos utilizar os serviços do Github. Primeiro precisamos criar uma conta. Para isso acessamos a página https://github.com/plans, escolhemos o tipo de conta que queremos criar e prosseguimos preenchendo os formulários pedidos.

Depois de criada nossa conta, precisamos gerar uma senha (chave de segurança) que será responsável por identificar nossa máquina quando fizermos as interações entre nosso projeto e o serviço do Github. Caso não exista essa configuração entre nossa máquina e a conta do Github, o acesso ao serviço pelos comandos do Git será negado.

O processo de criação da chave de segurança é similar em todos os sistemas operacionais: basta abrir o prompt de comando (no caso do Windows, é necessário abrir o Git Bash) e inserir o seguinte comando:

ssh-keygen -t rsa -C "seu_email@provedor.com"
Lembre-se de substituir seu_email@provedor.com pelo seu endereço real de email. A resposta do terminal vai perguntar em qual local do seu disco você quer salvar sua chave de segurança. Para evitar problemas, mantenha a opção padrão. Em algumas versões, pode ser necessário incluir também a opção -b 2048 ou -b 4096 para indicar o tamanho da chave a ser gerada.

A seguir, será solicitada a entrada de uma senha para a chave de segurança. Caso o computador seja público ou compartilhado, é recomendado que sua chave esteja protegida por uma senha. Caso contrário, recomendamos que a senha seja ignorada, bastando pressionar Enter ao ser solicitada a senha e a confirmação de senha.

Ao término do processo você deve ver uma mensagem similar à seguinte:

Your identification has been saved in /Users/seu_usuario/.ssh/id_rsa.
Your public key has been saved in /Users/seu_usuario/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db seu_email@provedor.com
The key's randomart image is:
+--[ RSA 2048]----+
|     .+   +      |
|       = o O .   |
|        = * *    |
|       o = +     |
|      o S .      |
|     o o =       |
|      o . E      |
|                 |
|                 |
+-----------------+
Com isso, dois arquivos serão gerados: a sua chave privada e a sua chave pública, conforme pode ser visto na imagem a seguir:

Arquivo chave

Agora será necessário realizar o login no http://github.com e seguir para as configurações do seu perfil. Siga "Settings", "SSH and GPG keys" e "New SSH key".

Insira na caixa de texto o conteúdo do seu arquivo id_rsa.pub. O local exato do arquivo foi informado na saída do processo de criação da chave. Cole-o exatamente como ele está, sem adição de espaços ou quebras de linha. Para isso, abra-o no editor de textos simples do seu sistema operacional (TextEditor, Bloco de Notas, GEdit), como pode ser visto na figura a seguir:

Cópia da chave no Github

Agora você tem o Git instalado em sua máquina, uma conta no Github e as configurações necessárias para utlizar o serviço com segurança.

Copiando o projeto para sua máquina: o comando clone
Iniciaremos o curso trabalhando em um repositório já existente. Para podermos fazer isso, nós temos que copiá-lo para nossa máquina. O repositório que vamos copiar está hospedado no Github. Para garantir que vamos adquirir todos os arquivos necessários, utilizaremos o comando git clone que, além de copiar os arquivos do projeto, traz todos os arquivos necessários para que o controle de versão dos arquivos continue sendo feito.

Abra o prompt de comando do computador e navegue até uma pasta que será a pasta "pai" do seu repositório local, por exemplo:

cd Documentos/Projetos
Lembre-se de que você pode escolher o local mais conveniente para você em seu computador. Agora vamos executar o comando que copiará o repositório para essa pasta:

git clone https://github.com/jcfonsecagit/repositorio.git
Esse comando clone criará uma pasta com o mesmo nome padrão do repositório (que no caso é "repositorio") e copiará para esse diretório todos os arquivos que estavam disponíveis nele.

Nosso projeto de exemplo contém páginas HTML. Para visualizar o projeto basta abrir o arquivo index.html em qualquer navegador (Chrome, Firefox, Internet Explorer, entre outros).

Você pode ver os arquivos do projeto navegando para a pasta "repositorio" e listando os arquivos no prompt de comando:

cd repositorio
ls
Controle geral de versões: o comando tag
Uma situação comum no desenvolvimento de um projeto de software é que, conforme ele vai evoluindo, vai ganhando novos releases e, consequentemente, novas versões. Com isso o software passa a ter a versão 1.0, 1.1, 2.0, 3.0 e assim por diante.

O Git nos permite, sempre que desejarmos, adicionarmos um marcador no repositório. Então, em determinado momento do projeto, é possível marcar o estado atual do repositório como a versão 1.0. Esse processo de adicionar um marcador, que habitualmente é o número da versão, é chamado de tag. É possível criar tags com o qualquer nome, para que não fiquemos presos a um determinado padrão de nomenclatura de versões. Isso nos permite inclusive marcarmos o repositório como "v0.1a", "v0.1b" com a finalidade de definirmos versões preliminares, de acordo com a necessidade do projeto atual.

Mas como é possível visualizar as tags existentes num projeto? No Git, é possível listar todas as Tags existentes em um projeto através do comando tag:

git tag
Feito isso, como podemos fazer para voltar o repositório para alguma dessas versões? Por exemplo, queremos visualizar como o nosso projeto, junto com todos os seus arquivos html, estava na versão v0.1. Para isso, basta dizer ao git que queremos buscar a versão v0.1. Chamamos esse processo de checkout e podemos executá-lo com o comando a seguir:

git checkout v0.1
Abrindo a página html novamente, podemos verificar como ela estava na versão v0.1.

Como saber o que mudou nos arquivos?
E se entre a versão v0.2 e a v0.1 surgiu um bug? Como descobrir o que mudou entre elas para isolar onde pode estar o bug? As ferramentas de controle de versão possuem tarefas específicas para mostrar a diferença (diff) entre duas versões de qualquer elemento do projeto, podendo ser um arquivo, um diretorio etc. No nosso caso, queremos ver as diferenças entre a versão v0.2 e a v0.1, o que conseguimos com o Git através do comando git diff, onde indicamos entre quais versões desejamos visualizar as diferenças.

git diff v0.1 v0.2
Com isso, serão mostradas as linhas existentes numa versão que não aparecem na outra versão. Também serão mostradas as alterações efetuadas entre as versões selecionadas.

Como descobrir quem realizou as alterações em um arquivo linha a linha?
Dentro do projeto, é comum encontrar linhas de código cuja compreensão não é imediata. Como descobrir o motivo pelo qual uma linha foi alterada ou o motivo para que ela tenha sido implementada de uma determinada maneira? Se analisando apenas o contexto não é possível compreender o motivo, que tal falar com o responsável por aquela modificação?

O Git nos fornece uma funcionalidade onde podemos consultar quem foi o autor de cada linha de um arquivo através do comando git blame:

git blame index.html
Para sair do blame, basta apertar a tecla q

Conclusão
Como vimos através dessa apresentação simples de apenas alguns comandos disponíveis no Git, temos uma ferramenta que permite muito mais segurança no controle de alterações de arquivos de um projeto. A utilidade dessa ferramenta é indiscutível: com ela, é possível realizar com facilidade alguns controles que antes eram muito trabalhosos ou até mesmo impossíveis de se fazer quando trabalhamos simplesmente com pastas compartilhadas em uma máquina ou servidor.

Durante este curso, aprenderemos outros comandos que o Git nos fornece para solucionar diversos problemas desde o trabalho básico de criação de um repositório, commits, branches, conflitos, como trabalhar no repositório sem conexão com a internet, trabalhar em diferentes implementações simultaneamente num mesmo projeto, modificação de um arquivo por mais de uma pessoa simultaneamente no projeto e tratar os conflitos, entre outros.

Agora que você aprendeu um pouco sobre o que é o Git, selecione quais das alternativas a seguir descrevem suas funções e características.

Manter um histórico das alterações feitas no projeto.
Cada alteração que você faz fica gravada em um histórico, podendo ser visualizada e restaurada a qualquer instante.

Marcar diferentes versões para o seu projeto.
O Git permite que você marque um dado estado do seu projeto com uma etiqueta, que pode ser usada para determinar uma versão dele.

Organizar o sistema de trabalho em equipe, centralizando os arquivos em um servidor.
Uma das funções do Git é centralizar os arquivos de trabalho, impedindo que haja confusão sobre o que foi e não foi modificado por cada um.

Selecione as alternativas que descrevem as funções e características do Github, como visto em aula.

Já inclui o controle de versão do Git.
Do mesmo modo que aquele servidor que vimos em aula, o Github mantém a integridade do código quando há diversos desenvolvedores trabalhando ao mesmo tempo.

É uma plataforma online na qual você pode hospedar o seu código fonte.
Do mesmo modo que aquele servidor que vimos em aula, o Github hospeda o código fonte do seu projeto.

Para clonar um repositório do Github, basta usar o comando git clone URL, substituindo URL pelo endereço de clonagem do Github. Como vimos em aula, o endereço de clonagem pode ser encontrado na página do repositório, ou adicionando-se o final .git ao endereço da página do repositório.
Por exemplo: o projeto repositório é visualizável pela página https://github.com/jcfonsecagit/repositorio. Basta adicionar .git ao final para obter a URL para clonagem.

Faça o teste! Clone o projeto com o comando a seguir e depois veja que arquivos foram copiados para o seu computador!

git clone https://github.com/jcfonsecagit/repositorio.git

Ao clonar um repositório, o Git vai te mostrar o progresso e enfim uma mensagem de sucesso, mais ou menos assim:
$ git clone https://github.com/jcfonsecagit/repositorio.git
Cloning into 'repositorio'...
remote: Counting objects: 18, done.
remote: Total 18 (delta 0), reused 0 (delta 0), pack-reused 18
Unpacking objects: 100% (18/18), done.
$
Para navegar pelo repositório, basta entrar no diretório criado, que pode ser visto entre aspas na primeira linha da saída ali acima, Cloning into 'repositorio'..., então basta usar o comando cd repositorio e então visualizar os arquivos que foram baixados com o comando ls.

A saída deve ser mais ou menos assim:

$ cd repositorio
$ ls
index.html
$

Vimos no video um comando que pode mostrar as versões do nosso projeto.
Utilize e descubra: quantas tags de versões existem no projeto repositorio?

2
Isso! Para visualizar as tags de um projeto, basta entrar no diretório do repositório e digitar o comando git tag. Neste projeto há duas versões: v0.1 e v0.2. A saída do comando vai a seguir:
$ git tag
v0.1
v0.2
$

Para trocar de versão para a 0.1, qual o comando que devemos utilizar?

$ git checkout v0.1
Isso mesmo! A opção checkout altera seu repositório local fazendo com que seus arquivos fiquem no mesmo estado em que estavam quando a tag v0.1 foram criados!

Para ver a diferença entre dois pontos do projeto, no caso duas versões, usamos a opção diff do git. Use o comando e escolha a opção que representa o que foi alterado da versão 0.1 pra 0.2.

A frase <h3>Versão 0.1</h3> foi removida.
Isso mesmo! Ao rodar o comando git diff v0.1 v0.2 vemos as alterações entre uma versão e a outra. No caso, a frase está com um símbolo - na frente, indicando que esta foi removida da versão 0.1 pra 0.2.

############### 2. O ciclo básico do Git ###############

Inicialização de um repositório
O Git é uma ferramenta de controle de versão baseada no sistema de arquivos, ou seja, podemos fazer a associação de uma pasta diretamente a um repositório. Então, vamos criar um novo diretório que conterá os arquivos do nosso projeto:

mkdir curso-git
cd curso-git
Mas, como essa é uma pasta como qualquer outra em nosso computador, será que o git já sabe que ela conterá os arquivos do nosso projeto? Como indicar que essa pasta será o nosso futuro repositório? Isso é feito a partir do seguinte comando:

git init
Será exibida uma mensagem similar a: Initialized empty Git repository in /diretorio/repositorio/do/git E pronto. Já temos um repositório.

Adicionando arquivos ao repositório
Agora começaremos o nosso projeto em si. Faremos um projeto que conterá páginas HTML. Então, vamos criar o primeiro arquivo, uma simples página HTML vazia chamado index.html:

<html>
    <head>
    </head>
    <body>
    </body>
</html>
Já temos o nosso primeiro arquivo em nosso projeto. Mas, será que o git já sabe que o arquivo criado pertence ao repositório? Para tal, podemos verificar quais os arquivos que pertencem ao nosso repositório. Isso pode ser feito digitando o comando:

git ls-files
E aí? Retornou algo? Nada? Onde está o nosso arquivo? Como fazemos para adiciona-lo no repositório? Para confirmar, podemos verificar o estado dos arquivos do nosso projeto:

git status
E teremos como saída:

# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add <file>..." to include in what will be committed)
#
#  index.html
Com isso, podemos verificar que o nosso arquivo está na condição de Untracked files, isto é, ele não está na lista de arquivos cujas alterações serão rastreadas, ou controladas. Isso acontece porque o Git não sabe que deve controlar as alterações deste arquivo, ou seja, que ele deva fazer o track. Então, como dizemos ao Git que ele deve realizar o track? Isso é feito a partir do comando git add passando o nome do arquivo do qual o Git deve fazer o track. No nosso caso, queremos adicionar o arquivo index.html ao repositório:

git add index.html
Vamos verificar novamente o estado dos arquivos do nosso repositório com o comando git status:

# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached <file>..." to unstage)
#
#  new file:   index.html
#
Vemos que o nosso arquivo passou para condição de Changes to be committed, isto é, na lista de arquivos que estão prontos para o commit. Mas o que é commit? Toda vez que terminamos de realizar as alterações nos arquivos de um projeto, precisamos "entregar" essas alterações, isto é, realizar um commit. E somente as alterações que estiverem sob a condição de "Changes to be commited" é que serão entregues.

Agora, podemos realizar o primeiro commit do nosso projeto. Mas como é que o Git sabe quem é o responsável pelo commit? Na seção anterior, vimos o comando git blame, o qual mostrava os responsáveis por cada linha de código. Nós precisamos informar ao Git o nosso nome e e-mail. Isso é feito com os seguintes comandos:

git config user.name "João Carlos Fonseca"
git config user.email "jcfonsecagit@gmail.com"
Com isso, o usuário João Carlos Fonseca será o responsável pelas alterações no repositório atual. Porém, se quisermos fazer isso para outros repositórios, temos que dar o mesmo comando toda vez? Felizmente, o Git nos fornece a opção de definir um nome de usuário e e-mail para todo o sistema, isto é, deixando esta configuração global:

git config --global user.name "João Carlos Fonseca"
git config --global user.email "jcfonsecagit@gmail.com"
Caso essa configuração não seja efetuada, o Git vai determinar o nome de usuário atual do terminal como o autor das alterações. É importante que essa configuração seja feita para que seja mais fácil encontrar suas próprias alterações e facilitar a comunicação entre os membros do time caso haja alguma dúvida sobre um código feito por outra pessoa.

Agora sim, estamos prontos para executar o nosso primeiro commit do projeto. Para que isso aconteça, devemos executar:

git commit -m "Início do projeto"
Com isso, realizamos o primeiro commit do sistema. A flag "-m", indica que o conteúdo a seguir é a mensagem que será utilizada para descrever o que está sendo feito no commit. Verificando os estados dos arquivos do nosso sistema com o comando git status, verificamos que não há nenhuma alteração em nosso projeto.

# On branch master
nothing to commit (working directory clean)
Alterando o projeto
Vamos continuar o nosso projeto modificando o arquivo index.html:

<html>
    <head>
    </head>         
    <body>          
        <h1>Git</h1>
        <h2>Trabalhando em Equipe com Controle e Segurança</h2>

        <p>Um curso que explora os benefícios de utilizar o Git como ferramenta de controle de versão para projetos em qualquer linguagem, em qualquer plataforma.</p>

        <h3>Principais benefícios:</h3>
        <ul>
            <li>Funciona de maneira distribuída</li>
            <li>Permite a edição concorrente de arquivos do projeto</li>
            <li>Não depende de uma conexão ativa com um servidor</li>
        </ul>
    </body>         
</html>
Verificando o estado dos arquivos novamente com o comando git status, percebemos que o Git já reconhece que temos arquivos que foram modificados no nosso projeto desde o nosso último commit:

# On branch master
# Changes not staged for commit:
#   (use "git add <file>..." to update what will be committed)
#   (use "git checkout -- <file>..." to discard changes in working directory)
#
#    modified:   index.html
#
no changes added to commit (use "git add" and/or "git commit -a")
Contudo, vemos que essas alterações ainda não fazem parte das alterações que serão adicionadas no próximo commit. Para adicionar esses arquivos para o próximo commit, precisamos rodar novamente o comando git add com o nome do arquivo.

Verificando o estado novamente, vemos que o nosso arquivo index.html está sob a condição "Changes to be committed".

# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#    modified:   index.html
#
Agora as alterações estão prontas para o commit. Ao rodar o comando git commit -m "Conteúdo da página index.html", temos o segundo commit do nosso projeto.

Recapitulação do processo
Durante o ciclo básico que demonstramos anteriormente, nós interagimos com 3 estágios diferentes do repositório. O primeiro deles enquanto nós criamos o repositório, mas não indicamos nenhum arquivo para ser rastreado.

Nesse estágio, estamos interagindo com um estado do projeto que chamamos de "Working Directory", ou seja, é o nosso sistema de arquivos atual. Nele estão as alterações que estamos realizando no momento.

O Working Directory pode estar "limpo", quando não há diferença entre os arquivos como armazenados no repositório e como estão atualmente. Quando há diferença (por exemplo, alteramos determinado arquivo, mesmo que uma alteração mínima), o Working Directory fica marcado como "sujo".

Em nosso caso o arquivo não existia para se ter uma comparação, pois tínhamos um repositório novo. Após modificarmos nossos arquivos a ponto de definirmos que um "passo" foi concluído, criamos uma visão desse passo, um ponto de controle preliminar com o comando "git add".

Esse comando cria um novo estágio do repositório, o que chamamos de "Index" ou "Staging Area". Esse estágio é transitório e pode ser alterado ainda antes de se tornar um passo do projeto: podemos adicionar novos arquivos, removê-los ou mesmo alterá-los.

Quando satisfeitos com o conteúdo do "Index", utilizamos o comando "git commit" para persistí-lo, gravar esse passo com todos os arquivos novos e alterações efetuadas. O comando "commit" criou um terceiro estágio do repositório que conhecemos como "HEAD". O HEAD é o último estado que o Git usa como referência, é a visão do último passo do projeto que foi concluído e entregue.

Conclusão
Uma ferramenta como o Git nos permite fazer alterações em nosso projeto com mais segurança pois sabemos que podemos controlar cada alteração, às vezes de maneira bem detalhada, de cada um dos nossos arquivos.

Apesar de poderosa, o Git não é uma ferramenta totalmente automatizada (automatizar esse processo seria impossível, pois o gerenciamento das versões varia muito de acordo com o ambiente do projeto e da equipe). Precisamos interagir com o Git constantemente para podermos extrair o melhor dos benefícios que ele oferece.

Apesar de demonstrarmos o uso do Git desde o início do projeto, podemos utilizar os mesmos passos em um projeto existente para que ele possa, a partir de um momento, ser controlado pelo Git.

Esse capítulo demonstrou o ciclo básico do trabalho de controle de versões de um projeto do ponto de vista de um único desenvolvedor. Com o Git podemos trabalhar em equipe, conforme veremos nos próximos capítulos. Apesar de podermos trabalhar em equipe, não precisamos, por enquanto, nos conectar a um servidor central; fizemos o controle local do nosso projeto. Isso permite que possamos trabalhar em um projeto mesmo sem ter acesso à rede ou à internet pois essas alterações podem ser aplicadas mais tarde ao repositório "central".

Qual comando utilizamos para informar ao Git que a pasta atual no prompt de comando deve ser tratada como um repositório?

git init
 
O comando git init inicia um novo repositório! É isso aí!

"O Git é uma ferramenta de controle de versão de arquivos que permite o rastreio de alterações em diversos arquivos em um mesmo repositório, não importando a localização dos mesmos no sistema de arquivos."
A afirmação acima é:

Falsa
 
Cada repositório deve ser associado diretamente com uma pasta no sistema de arquivos e, portanto, a afirmação é falsa.

Quais são os três estados de um repositório com os quais interagimos ao realizar o fluxo de controle com o Git?

working directory, index e HEAD
 
working directory representa o estado atual dos arquivos no repositório. Podemos utilizar o comando git add para adicioná-los ao index, ou staging area, que representa uma visão preliminar das modificações que queremos definir para nosso projeto, comparando essas ao HEAD, o último passo completo do nosso projeto, que serve de referência para comparação do trabalho com o working directory.

Como podemos verificar quais arquivos foram alterados, em comparação com o último passo (commit) do repositório?

O comando git status lista o estado atual de cada arquivo, caso tenha sido modificado
 
O comando git status exibe um resumo dos arquivos modificados, adicionados ou excluídos de seu working directory, em comparação com o HEAD.

Qual o comando utilizado para informarmos ao Git que desejamos rastrear determinado arquivo, incluindo-o no controle de versão?

git add
 
Correto! O comando git add, seguido pelo caminho relativo ou completo do arquivo, registra que o mesmo deve ser adicionado ao controle de versão!

Vimos que o comando git add pode receber como parâmetro o nome de um arquivo que deve ter suas alterações rastreadas. Assim, o mesmo será adicionado ao index do repositório. De que outras maneiras podemos utilizar o comando git add? Como podemos adicionar mais de um arquivo ao index ao mesmo tempo? Escolha as alternativas que representem corretamente estes outros modos.

git add arquivo1 arquivo2
 
Você pode adicionar arquivos específicos passando cada um como um parâmetro, separando cada arquivo por um espaço!

git add caminhoDeUmDiretorio
 
Você pode adicionar um diretório inteiro passando como parâmetro do comando git add o caminho do diretório!

git add .
 
O caminho git add . funciona do mesmo modo que passar o caminho de um diretório, pois o atalho . representa o diretório atual. Portanto, serão adicionados todos os arquivos que estiverem dentro do diretório atual!

O comando git add pode ser executado de modo interativo com a opção -i. Ao rodar o comando completo, git add -i, o modo interativo inicia um prompt de comando específico, aguardando as decisões do usuário sobre quais as alterações detectadas no working directory devem ser adicionadas ao index.
Realize uma alteração substancial ao arquivo index.html (por exemplo, adicione um novo parágrafo de texto dentro da tag <body> e altere um texto existente).

Agora adicione o arquivo utilizando o modo interativo:

Rode o comando git add -i
$ git add -i
           staged     unstaged path
  1:    unchanged        +1/-0 index.html

*** Commands ***
  1: status    2: update    3: revert    4: add untracked
  5: patch     6: diff      7: quit      8: help
What now>
Para adicionar arquivos alterados, utilize a opção update. Você pode digitar tanto o número, quanto a palavra escrita como também somente a primeira letra dela. No caso, utilizamos aqui a abreviação u e pressione enter.
What now> u
           staged     unstaged path
  1:    unchanged        +1/-0 index.html
Aparecerá uma listagem dos arquivos modificados, com um número atribuído a cada arquivo. Digite o número que representa o arquivo index.html e pressione enter .
Update>> 1
           staged     unstaged path
* 1:    unchanged        +1/-0 index.html
Aparecerá um asterisco ao lado do número do arquivo, indicando que ele será adicionado. Pressione enter novamente para confirmar e voltar ao menu principal.
Update>> 
updated one path

*** Commands ***
  1: status    2: update    3: revert    4: add untracked
  5: patch     6: diff      7: quit      8: help
Se quiser, confira as modificações. Utilize a opção status para conferir que o arquivo index.html foi adicionado corretamente, digitando a opção e pressionando enter.
What now> status
           staged     unstaged path
  1:        +1/-0      nothing index.html

*** Commands ***
  1: status    2: update    3: revert    4: add untracked
  5: patch     6: diff      7: quit      8: help
Utilize a opção quit para terminar a interação!
What now> 7
Bye.
$
Agora você pode fazer o commit do arquivo, que já está adicionado ao index. Confira usando o comando git status!

O comando git add -i é mais recomendado quando temos um número muito grande de alterações a serem adicionadas ao index e também um grande número de alterações que não gostaríamos de adicionar ao index. O modo interativo inclusive permite que adicionemos seletivamente trechos de um arquivo, deixando algumas modificações de fora mesmo estando no mesmo arquivo, com a opção patch.
A nomenclatura das opções não é consistente com os comandos que utilizamos até agora, porém perceba que sempre uma das opções é de ajuda, e podemos consultá-la a qualquer momento. Caso esteja em dúvida, sempre existe a opção de terminar o modo interativo e voltar ao prompt de comando.

Num ciclo simples de controle de um projeto com o Git, muitas vezes podemos querer adicionar ao HEAD todas as alterações que foram realizadas no working directory. O comando git commit oferece uma opção para que possamos evitar o passo de adicionar manualmente os arquivos ao index, gerando um commit que já inclui todas as modificações feitas no projeto.
Qual é essa opção? Utilize o comando git commit --help para ver quais as opções disponíveis!

git commit -a
 
A opção -a inclui imediatamente no commit todos os arquivos modificados ou removidos! Porém, ela não adiciona os arquivos novos. Podemos combinar a opção de mensagem com git commit -a -m 'Mensagem de commit' para não precisar escrever a mensagem no editor padrão do console.

O comando git commit pode também utilizado sem passar a opção -m. Neste caso, o editor de texto padrão de seu terminal vai abrir para que você digite a mensagem de commit. Ao salvar, caso a mensagem não esteja vazia, o commit será criado.

O editor abrirá com um espaço para preenchermos a mensagem e, logo abaixo, uma listagem dos arquivos que serão e não serão enviados. Essas linhas que começam com # não serão enviadas na mensagem, pois são comentários!
Esse modo de escrever a mensagem de commit é bastante interessante quando a mensagem que queremos escrever é um pouco mais complicada do que uma simples frase. Conseguimos, por exemplo, colocar itens na mensagem de commit, utilizando diversas linhas ao invés de uma única.

Dica: você pode alterar o editor padrão definindo a variável de ambiente EDITOR com o comando do editor de texto que você quer que ele execute.

############### 3. Sincronização dos dados com o repositório ###############

Onde gravo meus arquivos?
Apesar do Git nos permitir realizar os commits de maneira local, quando desejarmos trabalhar com uma equipe na qual várias pessoas precisarão de acesso aos arquivos em seus computadores, precisaremos de um local onde todas os arquivos e suas respectivas modificações estejam disponíveis.

Uma possibilidade inocente para resolver esse problema é, sempre que um arquivo for alterado, efetuarmos sua gravação em um pen-drive e distribuí-lo para as outras pessoas da equipe. No entanto, essa tarefa tende a se tornar muito trabalhosa com o passar do tempo. Imagine a qualquer alteração ter que ficar passando pen-drive para todos os colegas da equipe. Totalmente inviável.

Uma outra possibilidade é termos um diretório na rede onde todos possuem acesso e, sempre que uma informação for alterada por alguma pessoa, a alteração seja refletida nesse diretório. Assim, todos as outras pessoas da equipe também podem recuperar essas alterações.

Esse local remoto onde os arquivos ficam centralizados para todos os desenvolvedores é conhecido como repositório remoto, e é justamente o que o Github nos permite criar: repositórios para os quais podemos submeter nossos arquivos e outras pessoas de uma equipe possuam acesso e permissão para manipulá-los de maneira colaborativa. No entanto, ainda não temos nenhum repositório criado para começarmos a enviar nosso arquivo.

Criação de repositórios no Github para guardar os arquivos
Sempre que desejarmos armazenar os arquivos de um novo projeto, precisamos criar um novo repositório. O Github nos permite a criação de ilimitados repositórios, desde que eles sejam abertos e visíveis a todos os usuários. Em planos pagos, é possível ter repositórios privados, onde apenas determinados usuários possuam acesso.

Para conseguirmos criar nosso repositório, é preciso estar logado no Github, com uma conta já previamente criada e configurada, como visto no capítulo 1.

Uma vez logado no Github, existe na página inicial, do lado direito, um botão chamado "New Repository", que permitirá a criação do novo repositório. Em seguida, basta indicarmos o nome do projeto, que no nosso caso é "curso-git", e, opcionalmente, uma descrição. Nesse instante, você deverá estar em uma tela similar à abaixo.



Podemos também definir a visibilidade do repositório que, no caso, deixaremos como público. Pronto, clicando em "Create Repository" teremos o nosso novo repositório remoto, hospedado no Github.

Configuração do repositório remoto
No capítulo anterior, foram realizados commits. Porém, todos eles de maneira local, ou seja, eles só estão visíveis para o próprio autor do commit e ainda não estão disponíveis no repositório remoto.

Para conseguirmos compartilhar nosso projeto HTML, precisamos indicar que o diretório do nosso projeto apontará para um repositório remoto, no caso, o que acabamos de criar no Github. Para realizarmos esse processo, o Git possui o comando git remote add, com o qual podemos indicar a localização do repositório remoto e o nome que queremos dar para ele (um apelido ou alias).

A sintaxe completa do comando é:

git remote add [alias_do_repositorio] [uri_do_repositorio]
Portanto, precisamos ainda de duas informações para completar o comando, que são o alias do repositório e a url de onde ele estará disponível.

Uma convenção adotada é a utilização do nome do repositório remoto como "origin". No entanto, qualquer outro nome pode ser utilizado. Em seguida, devemos saber também a URI do repositório, que é um caminho único que indica o local onde ele ficará armazenado. O próprio Github, segue uma convenção com relação à URI de seus repositórios, sendo a seguinte:

https://github.com/[nome_do_usuario]/[nome_do_repositorio].git
Com isso, para o nosso projeto, teremos o seguinte caminho:

https://github.com/[seu_nome_do_usuario]/curso-git.git
Logo, o comando completo que devemos executar no prompt é:

git remote add origin https://github.com/[seu_nome_de_usuario]/curso-git.git
Ao executarmos o comando, nenhuma saída é mostrada no prompt.

Envio dos commits locais para o repositório
No capítulo anterior, realizamos alguns commits locais, os quais queremos enviar ao servidor para que outras pessoas consigam visualizar o trabalho feito.

Para isso, uma vez que o repositório já tenha sido inicializado com o comando git init, os commits locais já tenham sido realizados e o repositório remoto configurado, basta executarmos o comando git push, indicando qual é o repositório remoto para onde os commits serão enviados e a branch que será enviada para o servidor. O repositório remoto será o "origin", que acabamos de configurar, enquanto a branch será a "master", criada por padrão sempre que um repositório é criado. Aprederemos mais sobre branches nos próximos capítulos.

Com isso, teremos o comando: git push origin master.

Executando o push, teremos uma saída similar com a seguinte, no prompt:

Counting objects: 3, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 272 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/[seu_usuario_do_github]/curso-git.git
  * [new branch]      master -> master
Contribuição com o projeto: clone de repositórios
Agora que o repositório do projeto está disponível e inclusive já possui commits realizados, outros desenvolvedores podem querer contribuir com o projeto. O primeiro passo para que um outro usuário realize suas alterações é ter em seu próprio computador uma cópia do repositório. Dessa forma, ele terá todos os arquivos disponíveis em seu computador, para alterar como desejar.

O processo de copiar o repositório remoto para um computador, a fim de realizar alterações nos arquivos ou até mesmo para ter os arquivos no computador, é chamado de "clone" e pode ser realizado através do comando git clone [uri_do_repositorio].

O desenvolvedor que quiser colaborar em um repositório pode descobrir a URI de clonagem dele acessando sua página no Github. Nesse caso, o endereço de clonagem será:

https://github.com/[usuario_do_dono_do_repositorio]/curso-git.git.
Pronto, agora é possível que outros desenvolvedores trabalhem no projeto. Basta executar o clone com o comando: git clone https://github.com/[usuario_do_dono_do_repositorio]/curso-git.git.

Após a execução do comando, um diretório chamado "curso-git" será criado e a seguinte saída será exibida:

Cloning into curso-git...
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
Caso queira, é possível que o nome da pasta em seu computador seja diferente. Basta especificar o nome desejado no fim do comando:

git clone https://github.com/[usuario_do_dono_do_repositorio]/curso-git.git meuprojeto

O exemplo acima copia o repositório "curso-git" para uma pasta chamada "meuprojeto". Lembre-se de utilizar essa opção com cautela, quando o nome do repositório conflitar com outra pasta em seu computador por exemplo, pois é preferível manter a consistência entre o nome do repositório e o nome da pasta. Portanto, vamos manter o primeiro exemplo de comando.

Ao clonar um repositório, não precisamos adicionar o repositório remoto através do comando git remote add, pois tudo já é feito pelo comando git clone, dando um alias "origin" para o repositório.

É importante ter em mente que o processo de clonagem de um projeto pode demorar. O tempo pode variar de acordo com o tamanho do projeto que está sendo clonado e também com a velocidade de conexão.

Uma vez que o colaborador realizou o clone do repositório em seu computador e agora possui todos os arquivos localmente, as alterações desejadas por ele serão feitas localmente, igual aprendido na seção anterior. Ao final das alterações, ele realizará o envio dos commits para o repositório remoto através da execução do comando git push origin master.

Ao executar o "push", veremos uma mensagem similar à abaixo no prompt.

Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 304 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/[usuario_no_github]/curso-git.git
    c886b6a..b9aa50c  master -> master
A partir desse momento, acessando a página do repositório no Github, é possível ver a lista com os commits realizados.

Sincronização com as novas alterações do repositório
A partir do momento em que fizemos atualizações no repositório, os outros desenvolvedores que já o possuem em seus computadores não estarão sincronizados com estas alterações, ou seja, eles ainda não possuem em seus computadores as novas versões dos arquivos.

Para que a sincronização seja realizada e o desenvolvedor tenha em seu computador as novas versões dos arquivos, basta que ele execute o comando git pull origin master. A saída no prompt será similar à abaixo, indicando os arquivos que tiveram alterações e quantas linhas do arquivo foram afetadas.

remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From github.com:[usuario_no_github]/curso-git
    c886b6a..b9aa50c  master     -> origin/master
Updating c886b6a..b9aa50c
Fast-forward
  index.html |    1 +
  1 files changed, 1 insertions(+), 0 deletions(-)
Visualização de log de commits
Uma vez que o projeto possua commits no repositório remoto, conseguimos visualizar no próprio site do Github que os commits estão publicados. Basta acessar o endereço https://github.com/[seu_usuario_no_github]/[projeto]/commits/master, onde "master" é o nome da branch utilizada que, novamente, estudaremos melhor nos próximos capítulos.

Ao visualizarmos o log dos commits através da página do repositório no Github, temos uma visualização agradável do que acontece com o projeto e sua evolução. No entanto, muitos desenvolvedores podem achar o fato de ter que abrir o navegador para visualizar a lista de commits um processo muito trabalhoso.

Para facilitar a visualização dos commits, é possível também executar o comando git log em um prompt, no diretório de um projeto, que mostrará informações como o autor, a data e hora e a mensagem de commit utilizada. Uma possível saída para esse comando é:

commit b9aa50ccb68dc6c60bca197b7a5ee5e0b1d556f2
Author: Nome de Um Usuário <email1@servidor.com>
Date:   Tue Dec 27 17:35:50 2011 -0200

    Um outro commit de outro usuário 
commit c886b6ae3d8963ddba8cc80e434f572f72276ea8
Author: Nome de outro usuário <email2@servidor.com>
Date:   Tue Dec 27 16:47:15 2011 -0200

    Primeiro commit
Ao executar o comando git log, note que ele é extremamente rápido, pois, quando clonamos o repositório, todas as informações dele estão localmente em nosso computador, ou seja, não precisamos acessar nada de fora de nossa máquina.

Contudo, às vezes desejamos obter mais informações sobre os commits realizados: conhecer quais os arquivos que foram modificados no commit. Será que temos que colocar na mensagem do commit para saber quais os arquivos modificados? Felizmente, o Git nos fornece uma ferramenta que permite visualizar os arquivos modificados. O comando é o git whatchanged. Uma possível saída para esse comando é:

commit b9aa50ccb68dc6c60bca197b7a5ee5e0b1d556f2
Author: Nome de Um Usuário <email1@servidor.com>
Date:   Tue Dec 27 17:35:50 2011 -0200

    Um outro commit de outro usuário 
:100644 100644 6b6c919... 5270907... M index.html
Nesse caso, está sendo indicado que o arquivo index.html sofreu modificações (indicado pela letra M).

Controle de permissões do repositório do github
Muitas vezes queremos contribuir com um projeto, mas não possuímos permissão para realizarmos as contribuições como por, exemplo, novos commits.

Conseguimos perceber que não possuímos permissão para um repositório no Github ao acessarmos ele via o navegador e notar que a URL para clonarmos o projeto possui a mensagem "Read-Only access" ao seu lado. Um exemplo pode ser visualizado na imagem a seguir:



No nosso caso, como criamos o repositório curso-git no começo dessa seção, podemos também dar permissão para outros colaboradores. Por exemplo, caso queiramos adicionar o usuário fictício "João Carlos Fonseca" aos coloboradores do projeto, podemos acessar o endereço https://github.com/[seu_usuario_no_github]/curso-git/settings/collaboration e adicionarmos o id do usuário que, nesse caso, é jcfonsecagit.

No capítulo anterior, você gerou alguns commits, que ainda não foram enviados para o repositório remoto. Agora que configuramos ele, podemos enviar nossos commits para lá através do comando git push origin master.
Esse comando envia os dados da branch local master para a branch remota master, localizada no repositório origin.

Se tudo ocorreu certinho, a saída deve ser bem parecida com essa:
Counting objects: 3, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 272 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/[seu_usuario_do_github]/curso-git.git
  * [new branch]      master -> master
Outra alternativa é utilizar, no primeiro push, a opção -u ou --set-upstream. Ela atrela a branch remota à local, fazendo com que não seja mais necessário passar como parâmetros a origem e a branch no comando push, que fica então assim: git push.

Quando um desenvolvedor executa um git clone [repositorio], o que é copiado para sua máquina?

Tudo que existe naquele repositorio
 
Exatamente! Ao realizarmos a clonagem, uma cópia de todo o repositório remoto é criada em nossa máquina. Todos os arquivos, tags, histórico, branches e assim por diante ficam disponíveis localmente na máquina do desenvolvedor.

Às vezes desejamos visualizar mais informações do que o git log nos fornece, como por exemplo quais arquivos foram modificados no commit. Para isso existe o comando git whatchanged. Mas e se quisermos ver também quais as linhas modificadas?. Para isso, basta passar uma opção ao comando git whatchanged para que o Git nos forneça tal informação. Qual é essa opção?

git whatchanged -p
 
Ao executarmos o comando git whatchanged -p é possível visualizar quais as linhas que foram modificadas em cada commit do nosso projeto. Obs: também é possível utilizarmos git log -p, que imprime também os commits nos quais não houve modificação.

############### 4. Organização do trabalho com branches ###############

O que é branch e por que utilizá-las?
É comum, durante o desenvolvimento de novos recursos ou de correção de bugs, interrompermos o trabalho por falta de tempo ou porque surgiu uma nova prioridade do projeto. Mas o que fazer com as alterações que estão pela metade? Deletar e depois ter que refazer tudo novamente? Colocar no repositório algo pela metade, podendo quebrar todo o sistema?
Uma solução que é bem utilizada no dia a dia é a de criar uma seção separada do projeto, uma bifurcação, uma branch. Tal solução possibilita desenvolver separadamente cada uma das funcionalidades sem interferir no desenvolvimento de uma outra parte do projeto.

Trabalhando com branches: primeiros passos
Já sabemos que a utilização de branches facilita no dia a dia do desenvolvedor. Mas como criar uma nova branch? Para tal, utilizamos o comando git branch, passando como opção o nome da branch que desejamos criar. No nosso caso, criaremos a branch design, onde realizaremos algumas alterações referentes ao design da nossa página html:
git branch design

Ao executarmos o comando, nenhuma saída é mostrada no prompt.

Agora, como verificamos quais são as branches existentes em um projeto? Isso se resolve com o comando git branch. Ele nos fornece todas as branches criadas na máquina. Ele também possibilita visualizar qual a branch que estamos atualmente através de um "*" que precede o nome da branch atual.

git branch

  design 
* master
Observe que o "*" precede uma branch chamada master. Mas nós não a criamos agora. De onde ela surgiu? A branch master é criada quando executamos o nosso primeiro commit do projeto. Ela é considerada a branch principal do projeto.

Mas, se quisermos alterar o projeto numa outra branch, como é que fazemos para alterar a branch atual? Isto é feito através do comando git checkout, passando o nome da branch para a qual desejamos mudar. No nosso caso, temos:

git checkout design

Switched to branch 'design'

E pronto. Todas as alterações que realizaremos a partir de agora estarão na branch design.

Vamos adicionar estilo para a nossa página. Para tal, copie o seguinte código num arquivo chamado design.css. Adicione este arquivo na pasta do seu projeto.

body {
  background-color: blue;
}
Adicione também a seguinte linha no header do seu arquivo index.html:

<link rel="stylesheet" type="text/css" href="/design.css"/>
Porém, essas alterações ainda não foram atualizadas no repositório. Para isso, precisamos adicionar os arquivos e commitar as alterações:

git add design.css index.html
git commit -m "Adicionando estilo para a nossa página"
E pronto! As alterações estão salvas na branch design. O esquema do projeto com as branches pode ser vista na figura a seguir:



Se voltarmos para a branch master com o comando git checkout master, vemos que as alterações feitas anteriormente não estão mais presentes.

Por fim, perceba que todas essas alterações foram realizadas sem precisar de conexão com a internet. O Git nos permite trabalhar tanto com o repositório remoto quanto com o nosso próprio repositório local, ao contrário de outros controladores de versão como o SVN e CVS.

Compartilhando branches locais com outros desenvolvedores
Agora, o que acontece se você começou alguma alteração em um projeto e não terminou? Será que é bom manter apenas localmente? E se alguém quiser continuar as alterações que você iniciou?
E se criamos uma nova ferramenta que quebra a compatibilidade com as versões anteriores? Para resolver esses problemas, é bom manter também essas branches no repositório remoto.

Iniciaremos este trabalho enviando a branch criada localmente para o repositório remoto. Isso é feito utilizando o comando git push passando dois argumentos: o primeiro é o nome do repositório e o segundo, o nome da branch que deseja-se enviar. No nosso caso, temos:

git push origin design

Com isso, o repositório remoto conterá uma cópia fiel da branch design local. Isso pode ser visto na figura a seguir:



Porém, toda vez que atualizarmos tanto o nosso projeto local quanto o projeto remoto, precisaremos indicar qual o repositório e o nome da branch que a nossa branch local se refere no remoto, isto é, precisaremos digitar git pull origin design e git push origin design para atualizar os repositórios locais e remotos, respectivamente.

Para evitar tal trabalho, podemos indicar o caminho (track) da branch remota para a nossa branch local. Isso pode ser feito no instante em que criamos a branch remota através da opção "-u". No nosso caso, temos:

git push -u origin design

Com isso, a nossa branch local sabe qual a branch remota que ela se referencia.



E como podemos visualizar as branches já existentes em um repositório remoto? Isso é feito através da opção "-r" passado ao comando git branch.

git branch -r
origin/HEAD -> origin/master 
origin/design
Uma vez visto as branches remotas, como copiar uma delas para a máquina local? Isso é feito passando o nome do repositório e da branch remota ao comando git branch, além de indicar o nome da branch que será criada. Mais uma vez, temos o problema de indicar o caminho entre as branches. Para este caso, a opção -t resolve.

git branch -t design origin/design
Temos como resultado:

Branch design set up to track remote branch design from origin.
Switched to a new branch 'design'



